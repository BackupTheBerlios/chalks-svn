/*
This documents define the widget where multiple users write in the same time.
*/

// A good TextViewer tutorial
// http://www.moeraki.com/pygtktutorial/pygtk2tutorial/ch-TextViewWidget.html

using System;
using Gtk;
using GtkSourceView;

using Nemerle.Collections;
using Nemerle.Utility;

using Chalks.Gui.ChalksWindow; // access to the log function
using Chalks.ConcurrentEdition;

namespace Chalks.ConcurrentEditionWidget
{

    public class ConcurrentEditionWidget : SourceView, Chalks.ConcurrentEdition.ITextBuffer
    {

	static to_send_tag :TextTag = TextTag("to_send");
        static mutable applying_operation :bool = false;
        gui :Gui.ChalksWindow;
        
	public this(_gui :Gui.ChalksWindow)
        {
            gui = _gui;
            
	    ShowLineNumbers = true;
           
            // create the base Tags
            //to_send_tag = TextTag("to_send");
            //to_send_tag.Style = Pango.Style.Oblique;
            to_send_tag.ForegroundGdk = Gdk.Color(165b, 165b, 165b);
            to_send_tag.Underline = Pango.Underline.Low;
            Buffer.TagTable.Add(to_send_tag);
            
            // register handlers
            this.Buffer.InsertText += on_insert_text_event;
            this.Buffer.DeleteRange += on_delete_range_event;
            //this.Buffer.PasteClipboard += on_paste_clipboard_event;

            // call flush_inserted_text each second
            Timeout.Add(1000, flush_inserted_text); 
            
            // simple tag tests
            def t_tag = create_user_tag(Guid.NewGuid());
            Buffer.TagTable.Add(t_tag);

            
            mutable iter = Buffer.StartIter.Copy();
            applying_operation = true;
            Buffer.InsertWithTags(ref iter, "hello world\n", array[t_tag]);
            applying_operation = false;
            Buffer.InsertWithTags(ref iter, "This text has to be sent\n", array[to_send_tag]);

            /*
            // programatic "silent" insertion
            applying_operation = true;
            mutable start_iter1 = iter.Copy();
            mutable start_iter2 = iter.Copy();
            def end_iter = iter.Copy();
            Buffer.Insert(ref start_iter1, "This text has to be inserted without raising a handler\n");
            Buffer.ApplyTag(t_tag, start_iter2, end_iter);
            applying_operation = false;
            */
            
            // programatic "silent" deletion


           
            // end of simple tag tests   
            ;
        }

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        flush_inserted_text() :bool
        {
            /* Insertions are flushed:
               - each second
               - each time someone ends a word
               - each time someone ends a phrase
            */

            mutable found_a_region = false;
            
            def start_iter = this.Buffer.StartIter.Copy();
            def end_iter = this.Buffer.StartIter.Copy();

            found_a_region = start_iter.HasTag(to_send_tag);
            end_iter.ForwardToTagToggle(to_send_tag); // go to the first Toggle
            
            
            // search the first to_send tagger region
            when (! found_a_region) {
                start_iter.ForwardToTagToggle(to_send_tag);
                end_iter.ForwardToTagToggle(to_send_tag);
                
                found_a_region = ! start_iter.Equal(Buffer.EndIter);
            }

            //log($"flush: $(found_a_region) first region at [$(start_iter.Offset),$(end_iter.Offset)]");
            
            while(found_a_region)
            { // iterate over the different regions
                def text = Buffer.GetSlice(start_iter, end_iter, false);
                def pos = start_iter.Offset;
                gui.concurrent_editable.generate_operation(OperationType.Insert, pos, text);
                //Buffer.RemoveTag(to_send_tag, start_iter, end_iter);
                Buffer.RemoveAllTags(start_iter, end_iter); // inserted text has no tag

                // jump to the next section
                start_iter.ForwardToTagToggle(to_send_tag);
                end_iter.ForwardToTagToggle(to_send_tag);
                start_iter.ForwardToTagToggle(to_send_tag);
                end_iter.ForwardToTagToggle(to_send_tag);

                found_a_region = ! start_iter.Equal(Buffer.EndIter);
            }

            true; // return true to be called periodically
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region Buffer insertions and deletions events handlers
        
        /*        
        OnKeyPressEvent( _event :Gdk.EventKey) :bool
        {
            log("hi there !");
            true; // block the next handlers
        }         
        */

        protected override OnCopyClipboard():void
        { // avoid to copy the tags too
            mutable start_iter = TextIter();
            mutable end_iter = TextIter();
                      
            def clipboard = this.GetClipboard(Gdk.Selection.Clipboard);
            def non_zero_selection = this.Buffer.GetSelectionBounds( out start_iter, out end_iter);
            when(non_zero_selection) {
                def text = this.Buffer.GetSlice(start_iter, end_iter, false);
                clipboard.SetText(text);
            }
            ;
        }

    
    
        protected override OnPasteClipboard () :void
        {
            log("TextView.OnPasteClipboard called");
            def clipboard = this.GetClipboard(Gdk.Selection.Clipboard);
            // eliminate the tags in the clipboard
            // we do this getting only the text and setting only the text
            def PasteReceived ( clipboard :Clipboard, text :string) :void
            {
                //this.Buffer.InsertAtCursor(text);
                clipboard.SetText(text);
            }

            clipboard.RequestText ( ClipboardTextReceivedFunc (PasteReceived));

            
            this.Buffer.PasteClipboard(clipboard);
            ;
        }
        
        /*[GLib.ConnectBefore] // need to be static to be ConnectedBefore
        protected static on_paste_clipboard_event(_o :object, args :EventArgs) :bool
        {
            log("hi there !");
            false;

            when (false) {
            def clipboard = this.GetClipboard (Gdk.Selection.Clipboard);

            def PasteReceived ( clipboard :Clipboard, text :string) :void
            {
                this.Buffer.InsertAtCursor(text);
            }

            clipboard.RequestText ( ClipboardTextReceivedFunc (PasteReceived));
            
            true; // avoid the call of the following registered handlers
            }
        }*/

        on_insert_text_event(o :object, args :InsertTextArgs) :void
        { // args.Length :int, Pos :TextIter, Text :string

            when(!applying_operation) // detect if programatical or not
            { // inserted manually

                // apply to_send_tag
                def start_iter = args.Pos.Copy(); // can I do this _faster_ ?
                def end_iter = args.Pos.Copy(); // can I do this _faster_ ?
                //def start_iter = TextIter();
                //def end_iter = TextIter();
                //start_iter.Offset = args.Pos.Offset;
                //end_iter.Offset = args.Pos.Offset;
                
                // the handler is called after the text was inserted
                start_iter.BackwardChars(args.Length); 

                Buffer.RemoveAllTags(start_iter, end_iter);
                Buffer.ApplyTag(to_send_tag, start_iter, end_iter);
                //log(String.Format("Applying exclusive tag {0} from {1} to {2}", to_send_tag.Name.ToString(), start_iter.Offset.ToString(), end_iter.Offset.ToString())); 
                
                ;
            }
            
            // log("Inserted at offset " + args.Pos.Offset.ToString() + String.Format(" {0} chars that forms the text: {1}", args.Length, args.Text));

            ;
        }


        
        [GLib.ConnectBefore] // need to be static to be ConnectedBefore
	protected static on_delete_range_event(o :object, args :DeleteRangeArgs) :void
        {
            when(!applying_operation) // detect if programatical or not
            {
                log($"Will delete text in the range: $(args.Start.Offset), $(args.End.Offset). Length : $(args.End.Offset - args.Start.Offset)");

                //gui.concurrent_editable.generate_operation();
            }
            
            ;
        }

        #endregion
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region Helpers
                
        create_user_tag( site_id :Guid) :TextTag
        { // create a new tag with a new color

            def tag = TextTag(site_id.ToString());
            
            // local helper function
            def hsv_to_rgb(h :float, s :float, v :float) :array[float]
            {                
                if (s == 0.0f) 
                    array [v, v, v];
                else {
                    def i = Math.Floor((h*6.0f) :>double) :>float; 
                    def ii = i :>int;
                    def f = (h*6.0f) - i;
                    def p = v*(1.0f - s);
                    def q = v*(1.0f - s*f);
                    def t = v*(1.0f - s*(1.0f-f));
                    
                    if (ii%6 == 0) 
                        array [v, t, p];
                    else match (ii) {
                        | 1 => array [q,v,p];
                        | 2 => array [p,v,t];
                        | 3 => array [p,q,v];
                        | 4 => array [t,p,v];
                        | 5 => array [v,p,q];
                        | _ => array [q,v,p];
                    }
                        
                }
            }; // end of hsv_to_rgb

        
            // find a pleasant color randomly            
           
            // hue == tint is random
            // saturation: 0.0 white, 1.0 intense color
            def rgb = hsv_to_rgb(Random().NextDouble() :>float, 0.20f, 1.0f ); 
            // rgb to color, color to tag
            def rgb_bytes = array(rgb.Length)  :array[byte];
            for(mutable c=0; c < rgb.Length; c++ )
                rgb_bytes[c] = (rgb[c] * 255f) :>byte;


            def background_color = Gdk.Color(rgb_bytes[0],rgb_bytes[1],rgb_bytes[2]);
            tag.BackgroundGdk = background_color;            

            // how to show who wrote a text
            // http://svn.myrealbox.com/source/trunk/gtk-sharp/sample/GtkDemo/DemoHyperText.cs
            tag;
        }

        #endregion
                
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region ITextBuffer interface implementation, methods accessed by ConcurrentEditable and Gui
        
        public get_text() :string
        { 
            Buffer.Text;
        }


        public set_text(text:string) :void
        { 
            // <<< has to do any check before doing this ?
            Buffer.Text = text;
        }
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region ITextBuffer interface implementation, methods accessed by ConcurrentEditable

        public insert_text(offset:int, text:string) :void
        { 
            // check the tags of the user ? the user Id has to be included ?
            //ffun(foo = 3:int);
            
            applying_operation = true;

            applying_operation = false;

            ;
        }

        public delete_text(offset:int, length:int) :void
        {
            applying_operation = true;

            applying_operation = false;
            ;
        }

        #endregion
	
    }
}

/*
class SourceViewTest
{
	static string filename;

	static void Main (string[] args)
	{
		if (args.Length != 1 || !File.Exists (args[0]))
			PrintUsage ();
		filename = args[0];

		Application.Init ();
		new SourceViewTest ();
		Application.Run ();
	}

	static void PrintUsage ()
	{
		Console.WriteLine ("usage: SourceViewTest.exe <csfile>");
		Environment.Exit (0);
	}

	SourceViewTest ()
	{
		Window win = new Window ("SourceView test");
		win.SetDefaultSize (600, 400);
		win.WindowPosition = WindowPosition.Center;
		win.DeleteEvent += new DeleteEventHandler (OnWinDelete);
		win.Add (CreateView ());
		win.ShowAll ();
	}

	ScrolledWindow CreateView ()
	{
		ScrolledWindow sw = new ScrolledWindow ();
		SourceView view = new SourceView (CreateBuffer ());
		sw.Add (view);
		return sw;
	}

	SourceBuffer CreateBuffer ()
	{
		SourceLanguagesManager manager = new SourceLanguagesManager ();
		SourceLanguage lang = manager.GetLanguageFromMimeType ("text/x-csharp");

		SourceBuffer buffer = new SourceBuffer (lang);
		buffer.Highlight = true;
		StreamReader sr = File.OpenText (filename);
		buffer.Text = sr.ReadToEnd ();
		sr.Close ();
		return buffer;
	}

	void OnWinDelete (object sender, DeleteEventArgs a)
	{
		Application.Quit ();
		a.RetVal = true;
	}
}
*/
