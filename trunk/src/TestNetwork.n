/*
Test the Network class
*/

using System;

using Chalks.Gui;
using Chalks.Network;
using Chalks.ConcurrentEdition;
using Chalks.ConcurrentEditionWidget;


namespace Network
{    
    using NUnit.Framework;

    [TestFixture]
    public class NetworkTests
    {
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Manual testing
        public this()
        {
            Init();

            TestMessageBroadcast();
            //TestAdressedMessage();
            
            Dispose();
        }
        
        static public Main() :void
        {
            _ = NetworkTests();
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Global variables
        mutable nodes :array[NetworkNode] = array(5);
        mutable guis :array[GuiForNetworkTest] = array(5);

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region TestFixture SetUp and TearDown
        
        [TestFixtureSetUp]
        public Init() :void
        {

            Console.WriteLine("Doing the Network tests setup");
            
            // Create 5 nodes
            for(mutable c=0; c<nodes.Length; c+=1) {
            //foreach(n in nodes) {
                def dummy_gui = GuiForNetworkTest();
                def dummy_ce = CeForNetworkTest();

                guis[c] = dummy_gui;
                nodes[c] = NetworkNode(dummy_gui, dummy_ce, $"node$(c)");
                nodes[c].set_nickname($"Node$(c)");
            }

            
            // Connects them as shown in chalks/doc/schemas/network_example
            nodes[1].start_collaborating(nodes[0].get_self_uri());
            nodes[2].start_collaborating(nodes[0].get_self_uri());
            nodes[3].start_collaborating(nodes[0].get_self_uri());
            nodes[4].start_collaborating(nodes[3].get_self_uri());
            
            
            ;
        }

        [TestFixtureTearDown]
        public Dispose() :void
        {
            ;
        }
    
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Chat tests (adressed messages and broadcasted messages)
        
        [Test]
        public TestMessageBroadcast() :void
        {
            
            //Console.WriteLine("TestMessageBroadcast not yet implemented");
            Console.WriteLine("Running TestMessageBroadcast");
            Console.Out.Flush();
            
            def test_message = "Hello everyone !";
            def message_emitter = 3;
            
            // send a broadcast
            nodes[message_emitter].send_message(Guid.Empty, test_message);
                      
            // way one second
            System.Threading.Thread.Sleep(1000);
            
            // check that every node has received it 
            for(mutable c=0; c<4; c+=1) {
                when(c != message_emitter)
                    Assert.AreEqual(test_message, guis[c].received_messages);
            }
                
            ;
        }

        [Test]
        public TestAdressedMessage() :void
        {

            //Console.WriteLine("TestAdressedMessage not yet implemented");
            Console.WriteLine("Running test TestAdressedMessage");
            Console.Out.Flush();
            
            def test_message = "Hello you !";
            def message_emitter = 3;
            def message_adressee = 1;
            
            // send the message
            nodes[message_emitter].send_message(Guid.Empty, test_message);
                      
            // way one second
            System.Threading.Thread.Sleep(1000);
            
            // check that every node has received it 
            for(mutable c=0; c<4; c+=1) {
                when(c != message_emitter)
                    if (c == message_adressee)
                        Assert.AreEqual(test_message, guis[c].received_messages);
                    else
                        Assert.AreEqual("", guis[c].received_messages);
            }
                
            ;

            
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Operations emission reception tests

        // <<< TO BE IMPLEMENTED

        #endregion
        
        
    } // end of NetworkTests class


    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    #region Helper classes

    public class GuiForNetworkTest :IGuiForNetwork
    {
        // implements the basic methods that Network uses from Gui

        public mutable received_messages = "";
        
        public this()
        {
            ;
        }

        public set_site_id(site_id :Guid) :void
        {
            Console.WriteLine($"Gui: set_site_id($(site_id.ToString()))");
            ;
        }
        
        public receive_message(from :Guid, message :string) :void
        {
            Console.WriteLine($"Gui: Received from $(from.ToString()) the message $(message)");
            received_messages += message;
            ;
        }
        
    }
    


    public class CeForNetworkTest :ICeForNetwork
    {
        // implements the basic methods that Network uses from ConcurrentEdition.ConcurrentEditable

        public this()
        {
            ;
        }
        
        public set_network_interface(network_node_instance :NetworkNode) :void
        {
            Console.WriteLine($"Ce: Setting network interface using instance $(network_node_instance.ToString())");
            ;
        }

        public receive_operation(op :Operation) :void
        {
            Console.WriteLine($"Ce: Received operation $(op.ToString())");
            ;
        }

        public add_site(site_id :Guid) :void
        {
            Console.WriteLine($"Ce: Adding site $(site_id.ToString())");
            ;
        }

        public delete_site(site_id :Guid) :void
        {
            Console.WriteLine($"Ce: Deleting site $(site_id.ToString())");
            ;
        }

        public get_status() :ConcurrentEditableNodeStatus
        { // return a copy of the node status, to initialize another node
            
            def status = ConcurrentEditableNodeStatus();

            //status.Text = Text.Copy();
            //status.HB = HB.Copy();
            //status.SV = SV.Copy();
                        
            status;
        }

        public set_status(status :ConcurrentEditableNodeStatus) :void
        { // (re)initialize the internal state (occurs when entering in an existing session)

            ;

        }

    }

    #endregion

    
} // end of namespace