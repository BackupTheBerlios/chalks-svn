/*
The classes that manage the Human Machine Interface
*/

using System;
using System.IO;
using System.Collections;
using System.Guid;

using Gtk;
using Glade;
// For Glade usage look at 
// http://www.mono-project.com/GtkSharp 
// http://primates.ximian.com/~edasque/projects/Tutorial/glade2.html 
// for some hints

using Nini.Config;

using Nemerle.English;
using Nemerle.Collections;

using Chalks;
using Chalks.ConcurrentEditionWidget;
using Chalks.ConcurrentEdition;
using Chalks.Network;
using Chalks.Gui.ChalksWindow; // access to the log function


namespace Chalks.Gui
{
    
    public class ChalksWindow :IGuiForNetwork
    {
        #region Properties
        static public glade_resource_name :string = "chalks.glade";
        
        static config_source_name :string = "chalks.config";
        config_source :ConfigSourceBase;

        mutable current_file_path :string;
        chalks_window :Window;
        static mutable messages_textview :TextView = null;
        static mutable messages_textview_endmark :TextMark = null;
        command_entry :Entry;
        status_label :Label; 

        cce_widget :ConcurrentEditionWidget; // cce == ConcurrentEdition
        public concurrent_editable :ConcurrentEditable;
        network_node :INetworkForGui;

        mutable command_entry_last_key :Gdk.Key;
        commands_past_stack :Nemerle.Collections.Stack[string];
        commands_future_stack :Nemerle.Collections.Stack[string];

        mutable nickname :string = "you";
        nicknames :NicknamesWidget;
        #endregion

        public this()
        {
            // load configurations
            try {
                config_source = XmlConfigSource(config_source_name) :ConfigSourceBase;
            } 
            catch { 
                | _e is System.IO.FileNotFoundException =>
                  config_source = create_default_config_source();
                | _ => ();
            }
            config_source.AutoSave = true; // save at each change
            
                      
            // create our special widget
            cce_widget = ConcurrentEditionWidget(this); // cce == ConcurrentEdition
            cce_widget.CanFocus = true;

            // create the window


            Application.Init ();
            
            
            mutable gxml = GladeHelper.getXML(glade_resource_name, "chalks_window");
            
            chalks_window = gxml.GetWidget("chalks_window") :>Window;
            
            messages_textview = gxml.GetWidget("messages_textview") :>TextView;
            {
                def buffer = messages_textview.Buffer;
                messages_textview_endmark = buffer.CreateMark("end", buffer.EndIter, false);
            }
            command_entry = gxml.GetWidget("command_entry") :>Entry;
            commands_past_stack  = Nemerle.Collections.Stack();
            commands_future_stack = Nemerle.Collections.Stack();

            status_label = gxml.GetWidget("status_label") :>Label;
            update_statusbar_label();
            
            // Connect the custom widget with the existing layout

            def scrolledwindow3 = gxml.GetWidget("scrolledwindow3") :>ScrolledWindow;
            scrolledwindow3.Add(cce_widget);
            scrolledwindow3.ShowAll();
            
            gxml.Autoconnect (this);

            // instanciate the core objects
            concurrent_editable = ConcurrentEditable(cce_widget);
            network_node = NetworkNode(this, concurrent_editable);

            // setup the initial filename
            current_file_path = "Unsaved Document";
            def filename = Path.GetFileName(current_file_path);
            chalks_window.Title = $"$filename - Chalks";
            network_node.set_filename(filename);
            
            // setup the configuration values ---
            #region Setup the configuration values
            
            // gui editor font
            def font_name = config_source.Configs["Gui"].GetString("editor_font", null);
            when( font_name != null) {
                // change the editor font
                def font_desc = Pango.FontDescription.FromString(font_name);
                cce_widget.ModifyFont(font_desc);
            }
            
            // gui editor tabs
            // ??
            
            // nickname            
            nicknames = NicknamesWidget(this, gxml, cce_widget, network_node);
            def user_configurations = config_source.Configs["User"];
            def site_id = network_node.get_site_id();
            nickname = user_configurations.GetString("nickname", "");
            nicknames.Set(site_id, nickname);
            nicknames.SetStatus(site_id, user_configurations.GetString("status", ""));
            update_statusbar_label();
            network_node.set_nickname(nickname);
            
            // document password
            def default_password =
                        config_source.Configs["NetworkNode"].GetString("default_password", null);
            if(default_password != null) {
                network_node.set_password(default_password);
                //log($"The password for this document is: '$(default_password)'");
            }
            else {
                // will ask for a password when pertinent
            }

            #endregion
            
            // run
            cce_widget.HasFocus = true; //start with focus on the main text
            //Application.Run(); is called from Chalks.n
        }

        
        static quit() :void
        {
            //Console.WriteLine("Quitting"); Console.Out.Flush();
            Application.Quit ();
        }

        create_default_config_source() :ConfigSourceBase
        { // creates the default configuration file

            def config_source = XmlConfigSource();
            
            _ = config_source.AddConfig("User");

            { // nickname
                def dialog = SetNicknameDialog();
                def ret = dialog.Run(); 
                match (ret) {
                    | ResponseType.Ok => 
                      config_source.Configs["User"].Set("nickname", dialog.nickname_entry.Text);
                    | _ => config_source.Configs["User"].Set("nickname", "");
                }
            }

            config_source.Configs["User"].Set("status", "");
            
            _ = config_source.AddConfig("Gui");

            _ = config_source.AddConfig("NetworkNode");
            
            config_source.Save(config_source_name);
            config_source;

            /* // some Nini examples
            IConfig config = source.Configs["Logging"];
            logFileNameText.Text = config.Get ("File Name");
            maxFileSizeText.Text = config.GetString ("MaxFileSize");
            userNameText.Text = source.Configs["User"].GetInt ("Name");
            a_config.Set("a", b);
            source.Save();*/

        }
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region Methods called by Network, implementation of IGuiForNetwork

        public set_site_id(site_id :Guid) :void
        { // called once, during the startup of the application

            //nicknames.Set(site_id, nickname);
            cce_widget.set_site_id(site_id);
            
        }

        public receive_message(from :Guid, sender_nickname:string, message :string) :void
        {
            // register/update the nickname
            nicknames.Set(from, sender_nickname);
            
            
            // obtain the tag for the nickname
            def buffer = messages_textview.Buffer;
            mutable from_tag = buffer.TagTable.Lookup(from.ToString());
            when (from_tag == null) { // check if user known
                // create a new tag for the new user
                from_tag = TextTag(from.ToString());
                buffer.TagTable.Add(from_tag); // add it to the widget
                from_tag.BackgroundGdk = cce_widget.get_site_color(from);
            }
            
            // print the message
           
            mutable iter = buffer.EndIter.Copy();
            buffer.InsertWithTags(ref iter, $"\n$(sender_nickname):", array[from_tag]);
            buffer.InsertWithTags(ref iter, $" $message", array[]);
            messages_textview.ScrollMarkOnscreen(messages_textview_endmark);
        }

        public connection_closed(site_id :Guid) :void
        { // this method is called by the network layer when the connection is lost/closed

            
            log($"Site $(site_id.ToString().Substring(0,8)) closed his connection");

            // colateral effects
            // if site_id is us: we have finished our connection service

            // if site_id is us parent: we have lost our parent

            // if site_id is a children: a member of the session has disconnected
            
            
            //  <<< TO BE IMPLEMENTED
            log("to be implemented");

        }
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        
        
        #region Global log method        
        public log( verbosity :int, message :string) :void
        { // various verbosity levels
            when(verbosity <= Helpers.verbosity_level) log(message);
        }
        
        public log(message :string) :void 
        { // alias method
            log(message, array[]:array[TextTag]);
        }

        public log(message :string, tags :array[TextTag]) :void
        { // the global log method
            if (   (messages_textview         != null) 
                && (messages_textview_endmark != null)) 
            {
                def buffer = messages_textview.Buffer;
                mutable iter = buffer.EndIter.Copy();
                buffer.InsertWithTags(ref iter, "\n" + message, tags);
                messages_textview.ScrollMarkOnscreen(messages_textview_endmark);
                
            }
            else
            {
                Console.WriteLine(message);
                Console.Out.Flush();
            }
        }
        #endregion

        set_statusbar_label(message:string) :void
        { // update the text on the status bar
            status_label.Text = message;
        }

        public update_statusbar_label() :void
        { // make the text on the status bar coherent with the network status

            //def (self_uri, _, _) = network_node.get_connection_status();
            def self_uri = if(network_node != null) network_node.get_self_uri() else null;
            
            if (self_uri == null) {
                status_label.Text = "file not shared";
            } else {
                status_label.Text = $"$(nicknames.Count) users";
            }
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        #region Gui class helpers methods

        is_sharing() :bool
        { // returns true if the local node is able to receive connections

            def (self_uri, _, _) = network_node.get_connection_status();

            //log( //just for debugging
            //$"(self_uri, parent_id, childrens_ids) ($self_uri , $parent_id , $childrens_ids)");
            
            if(self_uri != null) {
                true; }
            else false;
        }

        
        is_connected() :bool
        { // returns true if the local node is connected to a parent or serving a children

            def (self_uri, parent_id, childrens_ids) = network_node.get_connection_status();

            //log( //just for debugging
            //$"(self_uri, parent_id, childrens_ids) ($self_uri , $parent_id , $childrens_ids)");
            
            if(self_uri != null) {
                if( parent_id != Guid.Empty or (not childrens_ids.IsEmpty) ) {
                    true; }
                else {                
                    false; }
            }            
            else false;
        }

        #endregion
        
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region SignalsHandlers
        // Connect the Signals defined in Glade
        
        static on_chalks_window_delete_event( _o :object, _args :DeleteEventArgs) :void
        {
            quit();
            _args.RetVal = true;
        }
        
        #region Menu items Handlers

        #region Files menu items handlers        

        #region Save and Save as menu items
        on_save_menu_item_activate(o :object,  args : EventArgs) : void
        {

            // if out file object already exist
            if(current_file_path != null) {
                concurrent_editable.save_file(current_file_path);
            }
            else {
                // if it does not exist
                // call the SaveAs menu
                on_save_as_menu_item_activate(o, args);
            }
        }

        on_save_as_menu_item_activate(_o :object,  _args : EventArgs) : void
        {
                        
            def dialog = FileChooserDialog("Save current document as...",
                                           chalks_window,
                                           FileChooserAction.Save,
                                           array[
                                                 Gtk.Stock.Cancel :object, ResponseType.Cancel,
                                                 Gtk.Stock.Save,   ResponseType.Ok]
                                           :array[object]);

            when(current_file_path != null)
            _ = dialog.SetFilename(current_file_path);

            // <<< when the user press Enter, should save the file
            
            def ret = dialog.Run() :> ResponseType;
            match(ret)
            {
                | ResponseType.Ok => 
                  Console.WriteLine ( "Ok");
                  Console.WriteLine ( dialog.Filename );
                  Console.WriteLine ( dialog.GetType().ToString() );
                  Console.WriteLine ( dialog.ToString );
                  
                  current_file_path = dialog.Filename;
                  concurrent_editable.save_file(current_file_path);
                  
                  // change the window title
                  def filename = Path.GetFileName(current_file_path);
                  chalks_window.Title = $"$filename - Chalks";
                  network_node.set_filename(filename);
                  // .set_filename will automatically update the ZeroConf information
              
                //| ResponseType.Cancel => 
                | _ =>
                  Console.WriteLine ( "Canceled" );
            }

            dialog.Destroy();
        }
        #endregion

        static on_quit_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            quit();
        }
        #endregion
        
        #region Help menu items handlers
        on_help_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            //<<< should implement something better...
            log("look at \nhttp://chalks.berlios.de\n for some hints...");
        }
        
        on_about_menu_item_activate(_o :object,  _args : EventArgs) :void
        {                       
            def dialog_name = "about_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            def dialog = gxml.GetWidget(dialog_name) :> Dialog;
            def _ret = dialog.Run() :> ResponseType;
            dialog.Destroy();
        }
        #endregion

        #region Open local, Open remote, Share and Disconnect
        on_open_local_menu_item_activate (_o :object,  _args : EventArgs) : void
        {

            when( is_sharing() ) {  // if sharing ask for disconnection

                def message = "You need to close your current connection in order to open a new file.\nDo you want to disconnect now ?";
                def dialog = MessageDialog(chalks_window, 
                                           DialogFlags.DestroyWithParent,
                                           MessageType.Warning, 
                                           ButtonsType.OkCancel,
                                           message);
                def ret = dialog.Run() :>ResponseType;
                dialog.Destroy();
                
                match(ret) {
                    | ResponseType.Ok =>
                      on_disconnect_menu_item_activate(null, null);
                      
                    | _ =>
                    //| ResponseType.Cancel =>
                      log("Canceled");
                }
            }
            

            // if disconnected load the file and then ask for sharing it or not
            when( not is_sharing() ) {

                // select the file to open
                def dialog = FileSelection("Open a text to edit");
                def ret = dialog.Run() :> ResponseType;
                match(ret)
                {
                    | ResponseType.Ok => 
                      Console.WriteLine ( "Ok");
                      Console.WriteLine ( dialog.Filename );
                      Console.WriteLine ( dialog.ToString );

                      mutable opening_succeed = false;
                      try {
                          // open the file
                          opening_succeed = concurrent_editable.open_file(dialog.Filename); 
                      } catch { e => log($"Error: $(e.Message)"); }
                    
                      if(opening_succeed)
                      {
                          current_file_path = dialog.Filename;
                          
                          // change the window title
                          def filename = Path.GetFileName(current_file_path);
                          chalks_window.Title = $"$filename - Chalks";
                          network_node.set_filename(filename);
                          // .set_filename will automatically update the ZeroConf information
                          
                          // ask for sharing the file
                          {
                              def message = "Do you want to share this file with remote users ?";
                              def dialog = MessageDialog(chalks_window, 
                                                         DialogFlags.DestroyWithParent,
                                                         MessageType.Question, 
                                                         ButtonsType.YesNo,
                                                         message);
                              def ret = dialog.Run() :>ResponseType;
                              dialog.Destroy();
                              
                              match(ret) {
                                  | ResponseType.Yes =>
                                    on_share_menu_item_activate(null, null);
                                    
                                  | _ =>
                                    //| ResponseType.No =>
                                    ();
                                    log("The current file is not yet being shared");
                              }
                          }
                          
                      }
                      else
                      {
                          log( $"Could not open the file located at $(dialog.Filename)" );
                      }
                          
                    | _ =>
                    //| ResponseType.Cancel =>                       
                      log( "Canceled" );
                }
                dialog.Destroy();
            }            
        } // end of on_open_local_menu_item_activate

        
        on_open_remote_menu_item_activate(_o :object, _args : EventArgs) :void
        { // open_remote_file == connect


            
            when( is_connected() ) { // if connected ask for disconnection

                def message = "You need to close your current connection in order to open a new file.\nDo you want to disconnect now ?";
                def dialog = MessageDialog(chalks_window, 
                                           DialogFlags.DestroyWithParent,
                                           MessageType.Warning, 
                                           ButtonsType.OkCancel,
                                           message);
                def ret = dialog.Run() :>ResponseType;
                dialog.Destroy();
                
                match(ret) {
                    | ResponseType.Ok =>
                      on_disconnect_menu_item_activate(null, null);
                      
                    | _ =>
                    //| ResponseType.Cancel =>
                      log("Canceled");
                }
            }

            
            // Check nickname
            nickname = config_source.Configs["User"].GetString("nickname", "");
            
            when (nickname == "") {
                def dialog = SetNicknameDialog();
                def ret = dialog.Run();
                match(ret) {
                    | ResponseType.Ok => 
                      nickname = dialog.nickname_entry.Text;
                      config_source.Configs["User"].Set("nickname", nickname);
                      nicknames.Set(network_node.get_site_id(), nickname);
                    | _ => log( "Canceled" );
                }
            }
             
            // Select connection
            when ((nickname != "") and (not is_connected())) {

                log("Your nickname is: " + nickname );
                // set nickname
                network_node.set_nickname(nickname);

                def connect_dialog = ConnectionDialog(this, network_node);
                def ret = connect_dialog.Run();

                match(ret)
                {
                    | ResponseType.Ok =>
                      def ip_and_port = connect_dialog.server_entry.Text; // 0.0.0.0:0
                      // request password
                      def password_dialog = GetPasswordDialog();
                      def ret = password_dialog.Run();
                      match(ret)
                      {
                          | ResponseType.Ok =>
                            // set password
                            def password = password_dialog.password_entry.Text;
                            network_node.set_password(password);
                            
                            // obtain the uri and connect to the server
                            assert(ip_and_port != "");
                            def uri = $"tcp://$(ip_and_port)/chalks"  ;
                            _ = network_node.start_collaborating(uri); // start the show !
                            
                          | _ =>
                          //| ResponseType.Cancel =>
                            log( "Canceled" );
                      }
                    
                    | _ =>
                    //| ResponseType.Cancel =>
                      log( "Canceled" );
                }

                ;
            } // end of when
        }


        on_share_menu_item_activate(_o :object, _args : EventArgs) :void
        { // publish online the document and allow other users to connect
            
            if( is_sharing() )
            {
                log("The current file is already being shared at address\n"
                    + network_node.get_self_uri());
            }
            else { // if not connected

                // set the password
                def password_ret = run_set_password_dialog();

                if (password_ret == ResponseType.Ok) {
                
                    def ret = network_node.start_collaborating();
                    when(not ret)
                    {
                        log("An error ocurred, could not share the file");
                    }
                } else {
                    log("No password was setup to share the document. File not shared");
                }
            }
            update_statusbar_label();
        }

        
        on_disconnect_menu_item_activate(_o :object,  _args : EventArgs) :void
        { // close all the connections aviable
            
            // check if connected or not
            def (_ , _ , childrens_ids) = network_node.get_connection_status();
            // self uri indicate about the service or not
            // parent_id indicate about if connected to a parent
            // childrens_ids indicate about the existing childrens
            
            if( is_sharing() )
            {
                
                def message = 
                if (childrens_ids.IsEmpty) {
                    "Are you sure you want to finish the collaboration ?"
                }
                else {
                    "Are you sure you want to finish the collaboration ?\n" +
                    $"($(childrens_ids.Count) users connected to you will also be disconnected)"
                };
                
                def dialog = MessageDialog(chalks_window, 
                                           DialogFlags.DestroyWithParent,
                                           MessageType.Warning, 
                                           ButtonsType.YesNo,
                                           message);
                def ret = dialog.Run() :>ResponseType;
                dialog.Destroy();
                
                match(ret) {
                    | ResponseType.Yes =>
                      log("Closing all the communications");
                      network_node.stop_collaborating();
                      
                      
                    | _ =>
                    //| ResponseType.No =>
                      ();
                      log("Canceled");
                }
            }
            else {
                log("You are already not connected");
            }
            update_statusbar_label();
        }


        run_set_password_dialog() :ResponseType
        {            
            // check if connected or not
            if(is_connected()) {
                //if connected the user should is not able to change the password
                log("Password can not be changed while sharing a document");
                ResponseType.None;
            }
            else { // if not connected
                
                def network_node_configurations = config_source.Configs["NetworkNode"];
                
                assert(network_node_configurations != null,
                       "Configuration file is corrupted (no NetworkNode configurations)");
                
                def default_password =
                    network_node_configurations.GetString("default_password", null);

                if (default_password != null) { // set default password
                    network_node.set_password(default_password);
                    log($"Using the preconfigured default password '$(default_password)'");
                    ResponseType.Ok;
                }
                else { // request password
                    def password_dialog = SetPasswordDialog();
                
                    def ret = password_dialog.Run();
                
                    match(ret)
                    {
                        | ResponseType.Ok =>
                          // set password
                          def password = password_dialog.password_entry.Text;
                          network_node.set_password(password);
                          
                          //check if have to be stored as default value
                          if (password_dialog.use_as_default_password_checkbutton.Active) {
                              // save the preference                      
                              network_node_configurations.Set("default_password", password);
                              
                              log($"Your new default password is: '$(password)'");
                          } 
                        else {
                            // disable "default_password" usage
                            network_node_configurations.Remove("default_password");
                        }
                    

                        | _ =>
                          //| ResponseType.Cancel =>
                          log( "Canceled" );
                    } // end of match

                    ret;
                } // end of 'if no default password'
            } // end of 'if not connected'
        } //end run_set_password_dialog
        
        #endregion


        #region Edit submenu

        on_undo_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            cce_widget.undo();
        }

        on_redo_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            cce_widget.redo();
        }

        on_copy_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            cce_widget.Buffer.CopyClipboard(clipboard);
        }

        on_cut_menu_item_activate(o :object,  args : EventArgs) :void
        {   // copy and delete
            on_copy_menu_item_activate(o,  args);
            on_delete_menu_item_activate(o,  args);
            ;
        }

        on_paste_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            cce_widget.Buffer.PasteClipboard(clipboard);
            ;
        }


        on_delete_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            _ = cce_widget.Buffer.DeleteSelection(true, true);
            /*
            mutable start_iter = TextIter();
            mutable end_iter = TextIter();
                      
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            def non_zero_selection = cce_widget.Buffer.GetSelectionBounds(out start_iter, out end_iter);
            when(non_zero_selection)
                cce_widget.Buffer.Delete(ref start_iter, ref end_iter);*/
            ;
        }

        on_preferences_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def dialog = PreferencesDialog();

            // set configured values ---

            // edition
            mutable t_font_name = config_source.Configs["Gui"].GetString("editor_font", null);
            when( t_font_name == null) { // get the default font name
                t_font_name = cce_widget.PangoContext.FontDescription.ToString();
            }
            dialog.editor_fontbutton.FontName = t_font_name;
            
            // connection
            // ??

            // node password
            /*
                def network_node_configurations = config_source.Configs["NetworkNode"];
                
                assert(network_node_configurations != null,
                       "Configuration file is corrupted (no NetworkNode configurations)");
                
                def default_password =
                    network_node_configurations.GetString("default_password", null);
                
                when(default_password != null) {
                    password_dialog.password_entry.Text = default_password;
                    password_dialog.use_as_default_password_checkbutton.Active = true;
                }

             */

            // run the dialog and interpret the response ---
            def ret = dialog.Run();
            match(ret) {
                | ResponseType.Ok =>
                  log("Configuration was modified");

                  // Edition options ---

                  // change the fonts
                  def font_name = dialog.editor_fontbutton.FontName;
                  def font_desc = Pango.FontDescription.FromString(font_name);
                  cce_widget.ModifyFont(font_desc);

                  config_source.Configs["Gui"].Set("editor_font", font_name);
                  
                  // change the tabs (how to do it ?)
                  // <<< TO BE IMPLEMENTED
                  log("Tabs configuration has to be implemented");

                  //config_source.Configs["Gui"].Set("tab_width", tab_width);
                  //config_source.Configs["Gui"].Set("tab_are_spaces", tab_are_spaces_bool);
                  
                  // Connection options ---


                  // Node password options ---
                  
                  /*
            // check if connected or not
            if(is_connected()) {
                //if connected the user should is not able to change the password
                log("Password can not be changed while sharing a document");
                log("Default password for future documents was modified");
                ResponseType.None;
            }
            else { // if not connected
                                
                      // set password
                      def password = password_dialog.password_entry.Text;
                      network_node.set_password(password);
                      
                      //check if have to be stored as default value
                      if (password_dialog.use_as_default_password_checkbutton.Active) {
                          // save the preference                      
                          network_node_configurations.Set("default_password", password);
                          
                          log($"Your new default password is: '$(password)'");
                      } 
                    else {
                        // disable "default_password" usage
                        network_node_configurations.Remove("default_password");
                    }
                    
            } // end of 'if not connected'



                   */

                  
                | _ => log( "Canceled" );
            }
        }
        #endregion

        #endregion

        on_command_entry_activate(_o :object, _args :EventArgs) :void
        {            
            // parse the command
            def command = ""; // <<< to be implemented
            def args = command_entry.Text;
            match(command) {

              | _ => // by default send the text as a message
                  def addressee = Guid.Empty; // broadcast
                  def message = args;
                  network_node.send_message(addressee, message);
                  // show it locally
                  receive_message(network_node.get_site_id(), nickname, message);
            }

            // keep the history
            
            foreach(command in commands_future_stack) {
                commands_past_stack.Push(command);
            }
            commands_past_stack.Push(command_entry.Text);
            command_entry.Text = "";
            commands_future_stack.Clear();   
            ;
        }

        on_command_entry_key_press_event(_o :object, args :KeyPressEventArgs) :void
        {
            match ( args.Event.Key )
            {
                | Gdk.Key.Up =>
                  try {
                      when(command_entry_last_key == Gdk.Key.Down) {
                          def text = commands_past_stack.Pop();
                          commands_future_stack.Push(text);
                      }
                      def text = commands_past_stack.Pop();
                      commands_future_stack.Push(text);
                      command_entry.Text = text;
                  } catch {
                      | _ is System.InvalidOperationException => ();
                      | e => log($"Internal error: $(e.Message)");
                  }
                  
                | Gdk.Key.Down =>
                  try {
                      when(command_entry_last_key == Gdk.Key.Up) {
                          def text = commands_future_stack.Pop();
                          commands_past_stack.Push(text);
                      }
                      def text = commands_future_stack.Pop();
                      commands_past_stack.Push(text);
                      command_entry.Text = text;
                      command_entry.Position = command_entry.Text.Length;
                  } catch {
                      | _ is System.InvalidOperationException => command_entry.Text = "";
                      | e => log($"Internal error: $(e.Message)");
                  }
                  
                  
                | _ => 
                  log(2, "Pressed " +  args.Event.Key.ToString() );
                  ();
            }
            command_entry_last_key = args.Event.Key;
        }

        on_command_entry_focus_out_event(_o :object, _args :FocusOutEventArgs) :void
        {
            // a good document on Gtk focus
            // http://mail.gnome.org/archives/gtk-devel-list/2000-October/msg00108.html

            when(command_entry_last_key == Gdk.Key.Up) {
                command_entry.GrabFocus();
                command_entry.SelectRegion(0,0);
                command_entry.Position = command_entry.Text.Length;
            }
        }
        

        #endregion    


        on_nickname_button_pressed(_o :object, _args :EventArgs) :void
        {
            def user_configurations = config_source.Configs["User"];
            def dialog = SetNicknameAndStatusDialog(user_configurations);
            def ret = dialog.Run(); 
            match (ret) {
                | ResponseType.Ok => 
                  def id = network_node.get_site_id();
                  nicknames.Set(id, dialog.nickname_entry.Text);
                  user_configurations.Set("nickname", dialog.nickname_entry.Text);
                  nicknames.SetStatus(id, dialog.status_entry.Text);
                  user_configurations.Set("status", dialog.status_entry.Text);
                | _ =>
                  ();
                  //log("Canceled");
            }            
        }
        

        on_nicknames_treeview_row_activated(_o :object, _args :EventArgs) :void
        {
            // check if row correspond to our nickname
            // <<< to be implemented
            def ret = true;
            
            when(ret) {
                on_nickname_button_pressed(null, null);
            }
        }

    } // end of ChalksWindow class

    #region Helper Dialogs classes
    class ConnectionDialog
    {

        dialog :Dialog;
        public server_entry :Entry;
        public documents_treeview :TreeView;
        public documents_treestore :ListStore;

        gui: ChalksWindow;
        network_node :INetworkForGui;

        site_id_column :int;
        address_column :int;
        ping_column :int;
        collaborator_column :int;
        document_name_column :int;
        
        
        public this(_gui: ChalksWindow, _network_node :INetworkForGui) 
        { 
            def dialog_name = "connection_dialog";
            def server_entry_name = "server_entry";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);

            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            server_entry = gxml.GetWidget(server_entry_name) :>Entry;
            documents_treeview = gxml.GetWidget("servers_treeview") :>TreeView;

            gui = _gui;
            network_node = _network_node;
            
            // set up the tree view
            documents_treestore = ListStore (typeof (Guid), // site_id
                                             typeof (string), // address ip:port
                                             typeof (int), // ping
                                             typeof (string), // collaborator nickname
                                             typeof (string) // document name
                                             );
            site_id_column = 0;
            address_column = 1;
            ping_column = 2;
            collaborator_column = 3;
            document_name_column = 4;

            
            documents_treeview.Model = documents_treestore;
            def renderer = CellRendererText();
            _ = documents_treeview.AppendColumn ("Collaborator", renderer,
                                                 "text", collaborator_column);
            _ = documents_treeview.AppendColumn ("Document", renderer,
                                                 "text", document_name_column);
            _ = documents_treeview.AppendColumn ("Latency", renderer,
                                                 "text", ping_column );
            _ = documents_treeview.AppendColumn ("Address", renderer,
                                                 "text", address_column);


            // dummy text
            /*
            _ = documents_treestore.AppendValues(Guid.NewGuid(),
                                                 "200.1.127.2:1000", 100,
                                                 "Ricardo", "A test file.txt");

            _ = documents_treestore.AppendValues(Guid.NewGuid(),
                                                 "158.12.53.1:1003", 254,
                                                 "Rodrigo", "Another file.txt");

            _ = documents_treestore.AppendValues(Guid.NewGuid(),
                                                 "125.67.12.23:1000", 732,
                                                 "AnnaPaola", "Another file.txt");
            */

            network_node.start_discovering_nodes(add_discovered_node, del_discovered_node);

            gxml.Autoconnect (this);
        }


        protected override Finalize() :void
        {
            network_node.stop_discovering_nodes();
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();

            // stop browsing !
            
            ret;
        }
        

        on_server_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

        on_servers_treeview_row_activated(_o :object, args :Gtk.RowActivatedArgs) :void
        {
            mutable iter = TreeIter();
            
            _ = documents_treestore.GetIter(out iter, args.Path);
            def address = documents_treestore.GetValue(iter, address_column) :>string;

            server_entry.Text = address;
        }

        
        add_discovered_node(site_id :string, address :string,
                            filename :string, nickname :string) :void
        {
            Console.WriteLine(
                    $"Adding node $(site_id.Substring(0,8)) $nickname @ $address  $filename");
            
            def default_ping = -1;
            _ = documents_treestore.AppendValues(Guid(site_id),
                                                 address, default_ping,
                                                 nickname, filename);
            gui.log(0, $"Adding treestore entry for site $site_id");
            //documents_treeview.QueueDraw(); // refresh the widget
        }
        

        del_discovered_node(site_id :string) :void
        {
            Console.WriteLine($"Deleting node $(site_id.Substring(0,8))");
            
            mutable iter = TreeIter();
            mutable list_is_not_finished = true;
            
            _ = documents_treestore.GetIterFirst(out iter);

            //find the adecuate row
            while(     (documents_treestore.GetValue(iter, site_id_column) :> Guid) != Guid(site_id)
                   and list_is_not_finished )
            {
                list_is_not_finished = documents_treestore.IterNext(ref iter);
            }

            when( (documents_treestore.GetValue(iter, site_id_column) :> Guid) == Guid(site_id))
            {
                _ = documents_treestore.Remove(ref iter);
                gui.log(0, $"Removing treestore entry for site $site_id");
                //documents_treeview.QueueDraw(); // refresh the widget
            }
        }
    
               
        
    } // end of class ConnectToDialog

    #region Nickname Dialog
    class SetNicknameDialog
    {
        dialog :Dialog;
        public nickname_entry :Entry;
        ok_button :Button;

        public this()
        { 
            def dialog_name = "set_nickname_dialog";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
                        
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            nickname_entry = gxml.GetWidget("nickname_entry") :>Entry;
            ok_button = gxml.GetWidget("ok_button") :>Button;
            gxml.Autoconnect (this);

            nickname_entry.Text = System.Environment.UserName;
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
        
        on_nickname_entry_changed(_o :object, _args :EventArgs) :void
        {
            if (nickname_entry.Text.Length < 3)
                ok_button.Sensitive = false;
            else
                ok_button.Sensitive = true;
        }            

        on_nickname_entry_activate(_o :object, _args :EventArgs) :void
        {
            when (nickname_entry.Text.Length > 3) dialog.Respond(ResponseType.Ok);
        }            
               
    } // end of class SetNicknameDialog
    #endregion

    #region Nickname and Status Dialog
    class SetNicknameAndStatusDialog
    {
        dialog :Dialog;
        public nickname_entry :Entry;
        public status_entry :Entry;
        ok_button :Button;

        public this(user_configurations :Nini.Config.IConfig)
        { 
            def dialog_name = "set_nickname_and_status_dialog";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
                        
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            nickname_entry = gxml.GetWidget("nickname_entry") :>Entry;
            status_entry = gxml.GetWidget("status_entry") :>Entry;
            ok_button = gxml.GetWidget("ok_button") :>Button;
            gxml.Autoconnect (this);
            
            nickname_entry.Text = user_configurations.GetString("nickname",
                                                                System.Environment.UserName);
            status_entry.Text = user_configurations.GetString("status", "");
            
            nickname_entry.HasFocus = true;
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
        on_nickname_entry_changed(_o :object, _args :EventArgs) :void
        {
            if (nickname_entry.Text.Length < 3)
                ok_button.Sensitive = false;
            else
                ok_button.Sensitive = true;
        }            

        on_nickname_entry_activate(_o :object, _args :EventArgs) :void
        {
            when (nickname_entry.Text.Length > 3) dialog.Respond(ResponseType.Ok);
        }

        on_status_entry_activate(_o :object, _args :EventArgs) :void
        {
            on_nickname_entry_activate(null, null);
        }
        
    } // end of class SetNicknameAndStatusDialog
    #endregion

    #region Set Password Dialog
    class SetPasswordDialog
    {
        dialog :Dialog;
        public password_entry :Entry;
        public use_as_default_password_checkbutton :CheckButton;

        public this()
        { 
            def dialog_name = "set_password_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            password_entry = gxml.GetWidget("password_entry") :>Entry;
            use_as_default_password_checkbutton =
                           gxml.GetWidget("use_as_default_password_checkbutton") :>CheckButton;
            gxml.Autoconnect (this);
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }

        on_password_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

    } // end of class SetPasswordDialog
    #endregion


    #region Set Password Dialog
    class GetPasswordDialog
    {
        dialog :Dialog;
        public password_entry :Entry;

        public this()
        { 
            def dialog_name = "get_password_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            password_entry = gxml.GetWidget("password_entry") :>Entry;
            gxml.Autoconnect (this);
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }

        on_password_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

    } // end of class GetPasswordDialog
    #endregion

    #region Preferences Dialog
    class PreferencesDialog
    {
        dialog :Dialog;
        public editor_fontbutton :FontButton;
        public tabswidth_spinbutton :SpinButton;
        public tabs_checkbutton :CheckButton;
        
        public this()
        { 
            def dialog_name = "preferences_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            dialog = gxml.GetWidget(dialog_name) :>Dialog;

            // edition parameters
            tabswidth_spinbutton = gxml.GetWidget("tabswidth_spinbutton") :>SpinButton;
            tabs_checkbutton     = gxml.GetWidget("tabs_checkbutton")     :>CheckButton;
            editor_fontbutton    = gxml.GetWidget("editor_fontbutton")    :>FontButton;
            
            // connection parameters
            
            gxml.Autoconnect (this);
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
    } // end of class PreferencesDialog
    #endregion

    #endregion

    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    #region Nicknames view helper

    class NicknamesWidget
    { // helper class that manage the nicknames

        // Treeview information aviable at
        // http://scentric.net/tutorial/treeview-tutorial.html
        // http://scentric.net/tutorial/sec-treeview-col-whole-row.html

        site_id :Guid;
        cce_widget :ConcurrentEditionWidget;
        network_node :INetworkForGui;
        
        nicknames :Nemerle.Collections.Hashtable[Guid, string] = Hashtable();
        statuses :Nemerle.Collections.Hashtable[Guid, string] = Hashtable();

        treeview :TreeView;
        treestore :ListStore;
        treeiters :Nemerle.Collections.Hashtable[Guid, TreeIter] = Hashtable();
        
        nickname_column :int = 0;
        color_column :int = 1;
        status_column :int = 2;

        nickname_button :Button;

        gui :ChalksWindow;
        
        public this( _gui: ChalksWindow, gxml :Glade.XML,
                    _cce_widget :ConcurrentEditionWidget, _network_node :INetworkForGui)
        {

            gui = _gui;
            treeview = gxml.GetWidget("nicknames_treeview") :>TreeView;
            assert(treeview != null);

            nickname_button = gxml.GetWidget("nickname_button") :>Button;
            assert(nickname_button != null);

            network_node = _network_node;
            site_id =  network_node.get_site_id();
            cce_widget = _cce_widget;

            treestore = ListStore (typeof (string), // nickname
                                   typeof(Gdk.Color), // color
                                   typeof (string) // status
                                   );

            treeview.Model = treestore;
            
            _ = treeview.AppendColumn ("Nickname", CellRendererText(),
                                       "text", nickname_column,
                                       "background-gdk", color_column);
            _ = treeview.AppendColumn ("Status", CellRendererText(), "text", status_column);
        }
        

        public Set(site_id:Guid, nickname :string ) :void
        {
            def old_nickname = nicknames[site_id];
            nicknames[site_id] = nickname;

            if(treeiters.Contains(site_id)) {
                treestore.SetValue(treeiters[site_id], nickname_column, nickname);
            } else {
                treeiters[site_id] = treestore.AppendValues(nickname,
                                                            cce_widget.get_site_color(site_id),
                                                            GetStatus(site_id));
            }

            when (site_id == this.site_id) {
                
                when(old_nickname != nickname)
                { // propage the change
                    nickname_button.Label = nickname.Replace("_", "__");
                    network_node.set_nickname(nickname);
                }
                
                gui.log($"Your nickname is: '$(nickname)'");      
            }

            gui.update_statusbar_label();
        }

        public Get(site_id:Guid) :string
        {
            when( ! nicknames.Contains(site_id)) {
                nicknames[site_id] = site_id.ToString().Substring(0,8);
            }
            
            nicknames[site_id];
        }

        public SetStatus(site_id:Guid, status :string ) :void
        {
            statuses[site_id] = status;

            if(treeiters.Contains(site_id)) {
                treestore.SetValue(treeiters[site_id], status_column, status);
            } else {
                treeiters[site_id] = treestore.AppendValues(Get(site_id),
                                                            cce_widget.get_site_color(site_id),
                                                            status);

                gui.update_statusbar_label();
            }
        }

        public GetStatus(site_id:Guid) :string
        {
            if(statuses.Contains(site_id)) statuses[site_id];
            else "";
        }

        public Contains(site_id:Guid) :bool
        {
            nicknames.Contains(site_id);
        }

        public Remove(site_id:Guid) :void
        {
            assert(treeiters.Contains(site_id),
                   "Fatal error, NicknamesWidget has an internal inconsistency");
            nicknames.Remove(site_id);
            statuses.Remove(site_id);
            mutable iter = treeiters[site_id];
            _ = treestore.Remove(ref iter);
            treeiters.Remove(site_id);

            gui.update_statusbar_label();
        }

        public Count :int
        {
            get { nicknames.Count }
        }
    }
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    
    #region class GladeHelper
    
    class GladeHelper 
    { // Helper class to access internal or external resources
        
        static public getXML(glade_resource_name :string, dialog_name :string) :Glade.XML
        {
            mutable gxml = null :Glade.XML;
            try {
                // chalks.glade file included as a resource "-res:chalks.glade"
                gxml = Glade.XML(null, glade_resource_name, dialog_name, null);
            } catch {
                | _ is System.ArgumentException => 
                  Console.WriteLine($"Could not find the Glade gui embedded resource file '$(glade_resource_name)'");
                  Console.WriteLine("Will search it as an external file.");
                | e => throw e;
            }
            
            when(gxml == null) {
                try {
                    // chalks.glade file is in the same directory than chalks.exe
                    gxml = Glade.XML("./" + glade_resource_name, dialog_name, null);
                } catch {
                    | e is System.ArgumentException => 
                      Console.WriteLine($"Could not find the Glade gui resource external file '$(glade_resource_name)'");
                      Console.WriteLine($"$e");
                    | e => throw e;
                }
            }
                        
            gxml;
        }
    }
	
    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    
} // end of namespace
