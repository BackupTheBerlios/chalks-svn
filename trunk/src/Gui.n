/*
The classes that manage the Human Machine Interface
*/

using System;
using System.IO;
using System.Collections;
using System.Guid;

using Gtk;
using Glade;
// For Glade usage look at 
// http://www.mono-project.com/GtkSharp 
// http://primates.ximian.com/~edasque/projects/Tutorial/glade2.html 
// for some hints

using Nini.Config;

using Nemerle.Collections;

using Chalks;
using Chalks.ConcurrentEditionWidget;
using Chalks.ConcurrentEdition;
using Chalks.Network;
using Chalks.Gui.ChalksWindow; // access to the log function


namespace Chalks.Gui
{
    
    public class ChalksWindow :IGuiForNetwork
    {
        #region Properties
        static public glade_resource_name :string = "chalks.glade";
        
        static config_source_name :string = "chalks.config";
        config_source :ConfigSourceBase;

        mutable current_file_path :string;
        chalks_window :Window;
        static mutable messages_textview :TextView = null;
        static mutable messages_textview_endmark :TextMark = null;
        command_entry :Entry;
        status_label :Label; 

        cce_widget :ConcurrentEditionWidget; // cce == ConcurrentEdition
        public concurrent_editable :ConcurrentEditable;
        network_node :NetworkNode;

        mutable command_entry_last_key :Gdk.Key;
        commands_past_stack :Nemerle.Collections.Stack[string];
        commands_future_stack :Nemerle.Collections.Stack[string];

        mutable nickname :string = "you";
        nicknames :NicknamesWidget;
        #endregion

        public this()
        {
            // load configurations
            try {
                config_source = XmlConfigSource(config_source_name) :ConfigSourceBase;
            } 
            catch { 
                | _e is System.IO.FileNotFoundException =>
                  config_source = create_default_config_source();
                | _ => ();
            }
            config_source.AutoSave = true; // save at each change
            
                      
            // create our special widget
            cce_widget = ConcurrentEditionWidget(this); // cce == ConcurrentEdition
            cce_widget.CanFocus = true;

            // create the window
            current_file_path = null;

            Application.Init ();
            
            
            mutable gxml = GladeHelper.getXML(glade_resource_name, "chalks_window");
            
            chalks_window = gxml.GetWidget("chalks_window") :>Window;

            messages_textview = gxml.GetWidget("messages_textview") :>TextView;
            {
                def buffer = messages_textview.Buffer;
                messages_textview_endmark = buffer.CreateMark("end", buffer.EndIter, false);
            }
            command_entry = gxml.GetWidget("command_entry") :>Entry;
            commands_past_stack  = Nemerle.Collections.Stack();
            commands_future_stack = Nemerle.Collections.Stack();

            status_label = gxml.GetWidget("status_label") :>Label;
            set_status("1 users");
            
            // Connect the custom widget with the existing layout

            def scrolledwindow3 = gxml.GetWidget("scrolledwindow3") :>ScrolledWindow;
            scrolledwindow3.Add(cce_widget);
            scrolledwindow3.ShowAll();
            
            gxml.Autoconnect (this);

            // instanciate the core objects
            concurrent_editable = ConcurrentEditable(cce_widget);
            network_node = NetworkNode(this, concurrent_editable);

            // setup the configuration values ---
            #region Setup the configuration values
            
            // gui editor font
            def font_name = config_source.Configs["Gui"].GetString("editor_font", null);
            when( font_name != null) {
                // change the editor font
                def font_desc = Pango.FontDescription.FromString(font_name);
                cce_widget.ModifyFont(font_desc);
            }
            
            // gui editor tabs
            // ??
            
            // nickname            
            nicknames = NicknamesWidget(gxml, network_node.get_site_id(), cce_widget);
            def user_configurations = config_source.Configs["User"];
            def site_id = network_node.get_site_id();
            nickname = user_configurations.GetString("nickname", "");
            nicknames.Set(site_id, nickname);
            nicknames.SetStatus(site_id, user_configurations.GetString("status", ""));
                        
            // document password
            def default_password =
                        config_source.Configs["NetworkNode"].GetString("default_password", null);
            if(default_password != null) {
                network_node.set_password(default_password);
                log("The password for this document is: '$(default_password)'");
            }
            else {
                /*network_node.set_password("");
                on_set_password_menu_item_activate(null, null); // ask for a password
                 */ // will ask for a password when pertinent
            }

            #endregion
            
            // run
            cce_widget.HasFocus = true; //start with focus on the main text
            //Application.Run(); is called from Chalks.n
        }

        
        static quit() :void
        {
            //Console.WriteLine("Quitting"); Console.Out.Flush();
            Application.Quit ();
        }

        create_default_config_source() :ConfigSourceBase
        { // creates the default configuration file

            def config_source = XmlConfigSource();
            
            _ = config_source.AddConfig("User");

            { // nickname
                def dialog = SetNicknameDialog();
                def ret = dialog.Run(); 
                match (ret) {
                    | ResponseType.Ok => 
                      config_source.Configs["User"].Set("nickname", dialog.nickname_entry.Text);
                    | _ => config_source.Configs["User"].Set("nickname", "");
                }
            }

            config_source.Configs["User"].Set("status", "");
            
            _ = config_source.AddConfig("Gui");

            _ = config_source.AddConfig("NetworkNode");
            
            config_source.Save(config_source_name);
            config_source;

            /* // some Nini examples
            IConfig config = source.Configs["Logging"];
            logFileNameText.Text = config.Get ("File Name");
            maxFileSizeText.Text = config.GetString ("MaxFileSize");
            userNameText.Text = source.Configs["User"].GetInt ("Name");
            a_config.Set("a", b);
            source.Save();*/

        }
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region Methods called by Network, implementation of IGuiForNetwork

        public set_site_id(site_id :Guid) :void
        { // called once, during the startup of the application
            
            //nicknames.Set(site_id, nickname);
            cce_widget.set_site_id(site_id);
        }

        public receive_message(from :Guid, sender_nickname:string, message :string) :void
        {
            // register/update the nickname
            nicknames.Set(from, sender_nickname);
            
            
            // obtain the tag for the nickname
            def buffer = messages_textview.Buffer;
            mutable from_tag = buffer.TagTable.Lookup(from.ToString());
            when (from_tag == null) { // check if user known
                // create a new tag for the new user
                from_tag = TextTag(from.ToString());
                buffer.TagTable.Add(from_tag); // add it to the widget
                from_tag.BackgroundGdk = cce_widget.get_site_color(from);
            }
            
            // print the message
           
            mutable iter = buffer.EndIter.Copy();
            buffer.InsertWithTags(ref iter, $"\n$(sender_nickname):", array[from_tag]);
            buffer.InsertWithTags(ref iter, $" $message", array[]);
            messages_textview.ScrollMarkOnscreen(messages_textview_endmark);
        }
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        
        
        #region Global log method        
        public log( verbosity :int, message :string) :void
        { // various verbosity levels
            when(verbosity <= Helpers.verbosity_level) log(message);
        }
        
        public log(message :string) :void 
        { // alias method
            log(message, array[]:array[TextTag]);
        }

        static public log(message :string, tags :array[TextTag]) :void
        { // the global log method
            if (   (messages_textview         != null) 
                && (messages_textview_endmark != null)) 
            {
                def buffer = messages_textview.Buffer;
                mutable iter = buffer.EndIter.Copy();
                buffer.InsertWithTags(ref iter, "\n" + message, tags);
                messages_textview.ScrollMarkOnscreen(messages_textview_endmark);
                
            }
            else
            {
                Console.WriteLine(message);
                Console.Out.Flush();
            }
        }
        #endregion

        // called from other modules too (mostly for debugging)
        public set_status(message:string) :void
        {
            status_label.Text = message;
        }
         
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~        

        #region SignalsHandlers
        // Connect the Signals defined in Glade
        
        static on_chalks_window_delete_event( _o :object, _args :DeleteEventArgs) :void
        {
            quit();
            _args.RetVal = true;
        }
        
        #region Menu items Handlers

        #region Files menu items handlers        
        on_open_local_menu_item_activate (_o :object,  _args : EventArgs) : void
        {
            
            //def _ = OpenFileDialog();
            /*def menu_item = o :> MenuItem;
            
            Console.WriteLine(menu_item.Name);
            
            def dialog = 
            match(menu_item.Name)
            {
                | "open_menu_item" => FileSelection("Open a text file");
                | "save_menu_item" => FileEntry("Save the current text file");
                | _ => null;
                  
            };*/


            /*
			| "Open" =>
                                def stream = IO.StreamReader (fs.Filename);
				input.Buffer.Text = stream.ReadToEnd();
 
			| "Save as..." =>
				def s = IO.StreamWriter(fs.Filename);
				s.Write(input.Buffer.Text);
				s.Close();

            */

            
            /*def dialog_name = "open_file_dialog";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            def dialog = gxml.GetWidget(dialog_name) :> Dialog;*/
            
            // if editing, confirm that the user wants to kill the session
            //<<<

            // kill the current session
            //<<<

            // select the file to open
            def dialog = FileSelection("Open a text to edit");
            def ret = dialog.Run() :> ResponseType;
            match(ret)
            {
                | ResponseType.Ok => 
                    Console.WriteLine ( "Ok");
                    Console.WriteLine ( dialog.Filename );
                    Console.WriteLine ( dialog.ToString );
                    
                    // <<< reading a new file should be managed at the ConcurrentEdition level

                    // read the file
                    def stream = IO.StreamReader (dialog.Filename);
                    def _text = stream.ReadToEnd();
                    stream.Close();
                    current_file_path = dialog.Filename;
                    // set the text in the current node
                    throw Exception("to be implemented");

                    // disconnect from actual session
                    // cce.set_status()
                    //<<< cce_widget.set_text(); ? is this good ? should not be in the node ?
                  

                | ResponseType.Cancel => Console.WriteLine ( "Canceled" );
                | _ => Console.WriteLine ( "Unknown answer" );
            }

            dialog.Destroy();
        }
        
        on_save_menu_item_activate(o :object,  args : EventArgs) : void
        {

            // if out file object already exist
            if(current_file_path != null) {   
                // simply flush the data
                def stream = IO.StreamWriter(current_file_path);
                stream.Write(cce_widget.get_text());
                stream.Close();
            }
            else {
                // if it does not exist
                // call the SaveAs menu
                on_save_as_menu_item_activate(o, args);
            }
        }

        on_save_as_menu_item_activate(_o :object,  _args : EventArgs) : void
        {
                        
            //def dialog = File???("Save current document as...");
            // Could not found the default Gtk.Dialog
            def dialog_name = "save_file_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);            
            def dialog = gxml.GetWidget(dialog_name) :> FileChooserDialog; //Dialog;

            def ret = dialog.Run() :> ResponseType;
            match(ret)
            {
                | ResponseType.Ok => 
                  Console.WriteLine ( "Ok");
                    Console.WriteLine ( dialog.Filename );
                    Console.WriteLine ( dialog.GetType().ToString() );
                    Console.WriteLine ( dialog.ToString );

                    current_file_path = dialog.Filename;
                    // flush the data to the new out file object
                    def stream = IO.StreamWriter(current_file_path);
                    stream.Write(cce_widget.get_text());
                    stream.Close();

                    // change the window title
                    // <<<
                    def filename = Path.GetFileName(current_file_path);
                    chalks_window.Title = filename;

                    // change the RendezVous published object
                    // <<<

                | ResponseType.Cancel => Console.WriteLine ( "Canceled" );
                | _ => Console.WriteLine ( "Unknown answer" );
            }

            dialog.Destroy();
        }

        static on_quit_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            quit();
        }
        #endregion
        
        #region Help menu items handlers
        on_help_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            //<<< should implement something better...
            log("look at http://chalks.berlios.de for some hints...");
        }
        
        on_about_menu_item_activate(_o :object,  _args : EventArgs) :void
        {                       
            def dialog_name = "about_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            def dialog = gxml.GetWidget(dialog_name) :> Dialog;
            def _ret = dialog.Run() :> ResponseType;
            dialog.Destroy();
        }
        #endregion

        #region Open remote, Share and Disconnect
        on_open_remote_menu_item_activate(_o :object, _args : EventArgs) :void
        { // open_remote_file == connect
            
            // Check nickname
            nickname = config_source.Configs["User"].GetString("nickname", "");
            
            when (nickname == "") {
                def dialog = SetNicknameDialog();
                def ret = dialog.Run();
                match(ret) {
                    | ResponseType.Ok => 
                      nickname = dialog.nickname_entry.Text;
                      config_source.Configs["User"].Set("nickname", nickname);
                      nicknames.Set(network_node.get_site_id(), nickname);
                    | _ => log( "Canceled" );
                }
            }
             
            // Select connection
            when (nickname != "") {

                log("Your nickname is: " + nickname );
                // set nickname
                network_node.set_nickname(nickname);

                def connect_dialog = ConnectionDialog();
                def ret = connect_dialog.Run();

                match(ret)
                {
                    | ResponseType.Ok =>
                      def ip_and_port = connect_dialog.server_entry.Text; // 0.0.0.0:0
                      // request password
                      def password_dialog = GetPasswordDialog();
                      def ret = password_dialog.Run();
                      match(ret)
                      {
                          | ResponseType.Ok =>
                            // set password
                            def password = password_dialog.password_entry.Text;
                            network_node.set_password(password);
                            
                            // obtain the uri and connect to the server
                            assert(ip_and_port != "");
                            def uri = $"tcp://$(ip_and_port)/chalks"  ;
                            _ = network_node.start_collaborating(uri); // start the show !
                            
                          | _ =>
                          //| ResponseType.Cancel =>
                            log( "Canceled" );
                      }
                    
                    | _ =>
                    //| ResponseType.Cancel =>
                      log( "Canceled" );
                }

                ;
            } // end of when
        }


        on_share_menu_item_activate(_o :object, _args : EventArgs) :void
        {
            //  <<< TO BE IMPLEMENTED
            log("to be implemented");
        }
        
        on_disconnect_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            // check if connected or not 
            // <<< TO BE IMPLEMENTED
            
            def dialog = MessageDialog(chalks_window, 
                                       DialogFlags.DestroyWithParent,
                                       MessageType.Warning, 
                                       ButtonsType.YesNo,
                                       "Are you sure you want to finish the collaboration ?"
                                     + "\n(users connected to you will also be disconnected)");
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            match(ret) {
                | ResponseType.Yes =>
                  log("to be implemented");
                  
                | _ =>
                //| ResponseType.No =>
                  ();
                  log("Canceled");
            }
        }

        on_set_password_menu_item_activate(_o :object,  _args : EventArgs) :void
        {

            // check if connected or not

            //<<< if connected the user should not be able to change the password

            
            // request password
            def password_dialog = SetPasswordDialog();

            def network_node_configurations = config_source.Configs["NetworkNode"];

            assert(network_node_configurations != null,
                   "Configuration file is corrupted (no NetworkNode configurations)");
            
            def default_password =
                        network_node_configurations.GetString("default_password", null);
            when(default_password != null) {
                password_dialog.password_entry.Text = default_password;
                password_dialog.use_as_default_password_checkbutton.Active = true;
            }
            
            def ret = password_dialog.Run();
            
            match(ret)
            {
                | ResponseType.Ok =>
                  // set password
                  def password = password_dialog.password_entry.Text;
                  network_node.set_password(password);

                  //check if have to be stored as default value
                  if (password_dialog.use_as_default_password_checkbutton.Active) {
                      // save the preference                      
                      network_node_configurations.Set("default_password", password);
                                                                                           
                      log($"Your new default password is: '$(password)'");
                  } 
                  else {
                      // disable "default_password" usage
                      network_node_configurations.Remove("default_password");
                  }
                

                | _ =>
                //| ResponseType.Cancel =>
                  log( "Canceled" );
            }
        }
        #region


        #region Edit submenu

        on_undo_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            cce_widget.undo();
        }

        on_redo_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            cce_widget.redo();
        }

        on_copy_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            cce_widget.Buffer.CopyClipboard(clipboard);
        }

        on_cut_menu_item_activate(o :object,  args : EventArgs) :void
        {   // copy and delete
            on_copy_menu_item_activate(o,  args);
            on_delete_menu_item_activate(o,  args);
            ;
        }

        on_paste_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            cce_widget.Buffer.PasteClipboard(clipboard);
            ;
        }


        on_delete_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            _ = cce_widget.Buffer.DeleteSelection(true, true);
            /*
            mutable start_iter = TextIter();
            mutable end_iter = TextIter();
                      
            def clipboard = cce_widget.GetClipboard(Gdk.Selection.Clipboard);
            def non_zero_selection = cce_widget.Buffer.GetSelectionBounds(out start_iter, out end_iter);
            when(non_zero_selection)
                cce_widget.Buffer.Delete(ref start_iter, ref end_iter);*/
            ;
        }

        on_preferences_menu_item_activate(_o :object,  _args : EventArgs) :void
        {
            def dialog = PreferencesDialog();

            // set configured values ---

            // edition
            mutable t_font_name = config_source.Configs["Gui"].GetString("editor_font", null);
            when( t_font_name == null) { // get the default font name
                t_font_name = cce_widget.PangoContext.FontDescription.ToString();
            }
            dialog.editor_fontbutton.FontName = t_font_name;
            
            // connection
            // ??
                        
            def ret = dialog.Run();
            match(ret) {
                | ResponseType.Ok =>
                  log("Configuration was modified");

                  // Edition options ---

                  // change the fonts
                  def font_name = dialog.editor_fontbutton.FontName;
                  def font_desc = Pango.FontDescription.FromString(font_name);
                  cce_widget.ModifyFont(font_desc);

                  config_source.Configs["Gui"].Set("editor_font", font_name);
                  
                  // change the tabs (how to do it ?)
                  // <<< TO BE IMPLEMENTED
                  log("Tabs configuration has to be implemented");

                  //config_source.Configs["Gui"].Set("tab_width", tab_width);
                  //config_source.Configs["Gui"].Set("tab_are_spaces", tab_are_spaces_bool);
                  
                  // Connection options ---

                  

                  
                | _ => log( "Canceled" );
            }
        }
        #endregion

        #endregion

        on_command_entry_activate(_o :object, _args :EventArgs) :void
        {            
            // parse the command
            def command = ""; // <<< to be implemented
            def args = command_entry.Text;
            match(command) {

              | _ => // by default send the text as a message
                  def addressee = Guid.Empty; // broadcast
                  def message = args;
                  network_node.send_message(addressee, message);
                  // show it locally
                  receive_message(network_node.get_site_id(), nickname, message);
            }

            // keep the history
            
            foreach(command in commands_future_stack) {
                commands_past_stack.Push(command);
            }
            commands_past_stack.Push(command_entry.Text);
            command_entry.Text = "";
            commands_future_stack.Clear();   
            ;
        }

        on_command_entry_key_press_event(_o :object, args :KeyPressEventArgs) :void
        {
            match ( args.Event.Key )
            {
                | Gdk.Key.Up =>
                  try {
                      when(command_entry_last_key == Gdk.Key.Down) {
                          def text = commands_past_stack.Pop();
                          commands_future_stack.Push(text);
                      }
                      def text = commands_past_stack.Pop();
                      commands_future_stack.Push(text);
                      command_entry.Text = text;
                  } catch {
                      | _ is System.InvalidOperationException => ();
                      | e => log($"Internal error: $(e.Message)");
                  }
                  
                | Gdk.Key.Down =>
                  try {
                      when(command_entry_last_key == Gdk.Key.Up) {
                          def text = commands_future_stack.Pop();
                          commands_past_stack.Push(text);
                      }
                      def text = commands_future_stack.Pop();
                      commands_past_stack.Push(text);
                      command_entry.Text = text;
                      command_entry.Position = command_entry.Text.Length;
                  } catch {
                      | _ is System.InvalidOperationException => command_entry.Text = "";
                      | e => log($"Internal error: $(e.Message)");
                  }
                  
                  
                | _ => 
                  log(2, "Pressed " +  args.Event.Key.ToString() );
                  ();
            }
            command_entry_last_key = args.Event.Key;
        }

        on_command_entry_focus_out_event(_o :object, _args :FocusOutEventArgs) :void
        {
            // a good document on Gtk focus
            // http://mail.gnome.org/archives/gtk-devel-list/2000-October/msg00108.html

            when(command_entry_last_key == Gdk.Key.Up) {
                command_entry.GrabFocus();
                command_entry.SelectRegion(0,0);
                command_entry.Position = command_entry.Text.Length;
            }
        }
        

        #endregion    


        on_nickname_button_pressed(_o :object, _args :EventArgs) :void
        {
            def user_configurations = config_source.Configs["User"];
            def dialog = SetNicknameAndStatusDialog(user_configurations);
            def ret = dialog.Run(); 
            match (ret) {
                | ResponseType.Ok => 
                  def id = network_node.get_site_id();
                  nicknames.Set(id, dialog.nickname_entry.Text);
                  user_configurations.Set("nickname", dialog.nickname_entry.Text);
                  nicknames.SetStatus(id, dialog.status_entry.Text);
                  user_configurations.Set("status", dialog.status_entry.Text);
                | _ =>
                  ();
                  //log("Canceled");
            }            
        }
        

        on_nicknames_treeview_row_activated(_o :object, _args :EventArgs) :void
        {
            // check if row correspond to our nickname
            // <<< to be implemented
            def ret = true;
            
            when(ret) {
                on_nickname_button_pressed(null, null);
            }
        }

    } // end of ChalksWindow class

    #region Helper Dialogs classes
    class ConnectionDialog
    {

        dialog :Dialog;
        public server_entry :Entry;
        public documents_treeview :TreeView;
        public documents_treestore :ListStore;

        address_column :int;
        ping_column :int;
        collaborator_column :int;
        document_name_column :int;
        
        
        public this() 
        { 
            def dialog_name = "connection_dialog";
            def server_entry_name = "server_entry";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);

            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            server_entry = gxml.GetWidget(server_entry_name) :>Entry;
            documents_treeview = gxml.GetWidget("servers_treeview") :>TreeView;

            // set up the tree view
            documents_treestore = ListStore (typeof (string), // address ip:port
                                             typeof (int), // ping
                                             typeof (string), // collaborator nickname
                                             typeof (string) // document name
                                             );
            address_column = 0;
            ping_column = 1;
            collaborator_column = 2;
            document_name_column = 3;


            documents_treeview.Model = documents_treestore;
            def renderer = CellRendererText();
            _ = documents_treeview.AppendColumn ("Collaborator", renderer,
                                                 "text", collaborator_column);
            _ = documents_treeview.AppendColumn ("Document", renderer,
                                                 "text", document_name_column);
            _ = documents_treeview.AppendColumn ("Latency", renderer,
                                                 "text", ping_column );
            _ = documents_treeview.AppendColumn ("Address", renderer,
                                                 "text", address_column);


            // dummy text
            _ = documents_treestore.AppendValues("200.1.127.2:1000", 100,
                                                 "Ricardo", "A test file.txt");

            _ = documents_treestore.AppendValues("158.12.53.1:1003", 254,
                                                 "Rodrigo", "Another file.txt");

            _ = documents_treestore.AppendValues("125.67.12.23:1000", 732,
                                                 "AnnaPaola", "Another file.txt");

            gxml.Autoconnect (this);
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        

        on_server_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

        on_servers_treeview_row_activated(_o :object, args :Gtk.RowActivatedArgs) :void
        {
            mutable iter = TreeIter();
            
            _ = documents_treestore.GetIter(out iter, args.Path);
            def address = documents_treestore.GetValue(iter, address_column) :>string;

            server_entry.Text = address;
        }
        
        
        
    } // end of class ConnectToDialog

    #region Nickname Dialog
    class SetNicknameDialog
    {
        dialog :Dialog;
        public nickname_entry :Entry;
        ok_button :Button;

        public this()
        { 
            def dialog_name = "set_nickname_dialog";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
                        
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            nickname_entry = gxml.GetWidget("nickname_entry") :>Entry;
            ok_button = gxml.GetWidget("ok_button") :>Button;
            gxml.Autoconnect (this);

            nickname_entry.Text = System.Environment.UserName;
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
        
        on_nickname_entry_changed(_o :object, _args :EventArgs) :void
        {
            if (nickname_entry.Text.Length < 3)
                ok_button.Sensitive = false;
            else
                ok_button.Sensitive = true;
        }            

        on_nickname_entry_activate(_o :object, _args :EventArgs) :void
        {
            when (nickname_entry.Text.Length > 3) dialog.Respond(ResponseType.Ok);
        }            
               
    } // end of class SetNicknameDialog
    #endregion

    #region Nickname and Status Dialog
    class SetNicknameAndStatusDialog
    {
        dialog :Dialog;
        public nickname_entry :Entry;
        public status_entry :Entry;
        ok_button :Button;

        public this(user_configurations :Nini.Config.IConfig)
        { 
            def dialog_name = "set_nickname_and_status_dialog";
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
                        
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            nickname_entry = gxml.GetWidget("nickname_entry") :>Entry;
            status_entry = gxml.GetWidget("status_entry") :>Entry;
            ok_button = gxml.GetWidget("ok_button") :>Button;
            gxml.Autoconnect (this);
            
            nickname_entry.Text = user_configurations.GetString("nickname",
                                                                System.Environment.UserName);
            status_entry.Text = user_configurations.GetString("status", "");
            
            nickname_entry.HasFocus = true;
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
        on_nickname_entry_changed(_o :object, _args :EventArgs) :void
        {
            if (nickname_entry.Text.Length < 3)
                ok_button.Sensitive = false;
            else
                ok_button.Sensitive = true;
        }            

        on_nickname_entry_activate(_o :object, _args :EventArgs) :void
        {
            when (nickname_entry.Text.Length > 3) dialog.Respond(ResponseType.Ok);
        }

        on_status_entry_activate(_o :object, _args :EventArgs) :void
        {
            on_nickname_entry_activate(null, null);
        }
        
    } // end of class SetNicknameAndStatusDialog
    #endregion

    #region Set Password Dialog
    class SetPasswordDialog
    {
        dialog :Dialog;
        public password_entry :Entry;
        public use_as_default_password_checkbutton :CheckButton;

        public this()
        { 
            def dialog_name = "set_password_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            password_entry = gxml.GetWidget("password_entry") :>Entry;
            use_as_default_password_checkbutton =
                           gxml.GetWidget("use_as_default_password_checkbutton") :>CheckButton;
            gxml.Autoconnect (this);
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }

        on_password_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

    } // end of class SetPasswordDialog
    #endregion


    #region Set Password Dialog
    class GetPasswordDialog
    {
        dialog :Dialog;
        public password_entry :Entry;

        public this()
        { 
            def dialog_name = "get_password_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            
            dialog = gxml.GetWidget(dialog_name) :>Dialog;
            password_entry = gxml.GetWidget("password_entry") :>Entry;
            gxml.Autoconnect (this);
            
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }

        on_password_entry_activate(_o :object, _args :EventArgs) :void
        {
            dialog.Respond(ResponseType.Ok);
        }            

    } // end of class GetPasswordDialog
    #endregion

    #region Preferences Dialog
    class PreferencesDialog
    {
        dialog :Dialog;
        public editor_fontbutton :FontButton;
        public tabswidth_spinbutton :SpinButton;
        public tabs_checkbutton :CheckButton;
        
        public this()
        { 
            def dialog_name = "preferences_dialog";            
            def gxml = GladeHelper.getXML(glade_resource_name, dialog_name);
            dialog = gxml.GetWidget(dialog_name) :>Dialog;

            // edition parameters
            tabswidth_spinbutton = gxml.GetWidget("tabswidth_spinbutton") :>SpinButton;
            tabs_checkbutton     = gxml.GetWidget("tabs_checkbutton")     :>CheckButton;
            editor_fontbutton    = gxml.GetWidget("editor_fontbutton")    :>FontButton;
            
            // connection parameters
            
            gxml.Autoconnect (this);
        }
        
        public Run() :ResponseType
        {
            def ret = dialog.Run() :>ResponseType;
            dialog.Destroy();
            ret;
        }
        
    } // end of class PreferencesDialog
    #endregion

    #endregion

    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    #region Nicknames view helper

    class NicknamesWidget
    { // helper class that manage the nicknames

        // Treeview information aviable at
        // http://scentric.net/tutorial/treeview-tutorial.html
        // http://scentric.net/tutorial/sec-treeview-col-whole-row.html

        site_id :Guid;
        cce_widget :ConcurrentEditionWidget;
        
        nicknames :Nemerle.Collections.Hashtable[Guid, string] = Hashtable();
        statuses :Nemerle.Collections.Hashtable[Guid, string] = Hashtable();

        treeview :TreeView;
        treestore :ListStore;
        treeiters :Nemerle.Collections.Hashtable[Guid, TreeIter] = Hashtable();
        
        nickname_column :int = 0;
        color_column :int = 1;
        status_column :int = 2;

        nickname_button :Button;
        status_label :Label;
        
        public this( gxml :Glade.XML, _site_id:Guid,
                    _cce_widget :ConcurrentEditionWidget)
        {

            treeview = gxml.GetWidget("nicknames_treeview") :>TreeView;
            assert(treeview != null);

            nickname_button = gxml.GetWidget("nickname_button") :>Button;
            assert(nickname_button != null);

            status_label = gxml.GetWidget("status_label") :>Label;
            assert(status_label != null);
            
            site_id = _site_id;
            cce_widget = _cce_widget;


            treestore = ListStore (typeof (string), // nickname
                                   typeof(Gdk.Color), // color
                                   typeof (string) // status
                                   );

            treeview.Model = treestore;
            
            _ = treeview.AppendColumn ("Nickname", CellRendererText(),
                                       "text", nickname_column,
                                       "background-gdk", color_column);
            _ = treeview.AppendColumn ("Status", CellRendererText(), "text", status_column);
        }
        

        public Set(site_id:Guid, nickname :string ) :void
        {
            nicknames[site_id] = nickname;

            if(treeiters.Contains(site_id)) {
                treestore.SetValue(treeiters[site_id], nickname_column, nickname);
            } else {
                treeiters[site_id] = treestore.AppendValues(nickname,
                                                            cce_widget.get_site_color(site_id),
                                                            GetStatus(site_id));
            }

            when (site_id == this.site_id) {
                nickname_button.Label = nickname;
                log($"Your nickname is: '$(nickname)'", array[] :array[TextTag]);
            }

            status_label.Text = $"$(nicknames.Count) users";
        }

        public Get(site_id:Guid) :string
        {
            when( ! nicknames.Contains(site_id)) {
                nicknames[site_id] = site_id.ToString().Substring(0,8);
            }
            
            nicknames[site_id];
        }

        public SetStatus(site_id:Guid, status :string ) :void
        {
            statuses[site_id] = status;

            if(treeiters.Contains(site_id)) {
                treestore.SetValue(treeiters[site_id], status_column, status);
            } else {
                treeiters[site_id] = treestore.AppendValues(Get(site_id),
                                                            cce_widget.get_site_color(site_id),
                                                            status);

                status_label.Text = $"$(nicknames.Count) users";
            }
        }

        public GetStatus(site_id:Guid) :string
        {
            if(statuses.Contains(site_id)) statuses[site_id];
            else "";
        }

        public Contains(site_id:Guid) :bool
        {
            nicknames.Contains(site_id);
        }

        public Remove(site_id:Guid) :void
        {
            assert(treeiters.Contains(site_id),
                   "Fatal error, NicknamesWidget has an internal inconsistency");
            nicknames.Remove(site_id);
            statuses.Remove(site_id);
            mutable iter = treeiters[site_id];
            _ = treestore.Remove(ref iter);
            treeiters.Remove(site_id);

            status_label.Text = $"$(nicknames.Count) users";
        }
    }
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    
    #region class GladeHelper
    
    class GladeHelper 
    { // Helper class to access internal or external resources
        
        static public getXML(glade_resource_name :string, dialog_name :string) :Glade.XML
        {
            mutable gxml = null :Glade.XML;
            try {
                // chalks.glade file included as a resource "-res:chalks.glade"
                gxml = Glade.XML(null, glade_resource_name, dialog_name, null);
            } catch {
                | _ is System.ArgumentException => 
                  Console.WriteLine($"Could not find the Glade gui embedded resource file '$(glade_resource_name)'");
                  Console.WriteLine("Will search it as an external file.");
                | e => throw e;
            }
            
            when(gxml == null) {
                try {
                    // chalks.glade file is in the same directory than chalks.exe
                    gxml = Glade.XML("./" + glade_resource_name, dialog_name, null);
                } catch {
                    | e is System.ArgumentException => 
                      Console.WriteLine($"Could not find the Glade gui resource external file '$(glade_resource_name)'");
                      Console.WriteLine($"$e");
                    | e => throw e;
                }
            }
                        
            gxml;
        }
    }
	
    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~


} // end of namespace
