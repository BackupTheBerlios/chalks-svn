/*

*/

using Nemerle.Collections; // For Hashtable

using System;
using System.Guid;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Remoting.Messaging;
using System.Threading;

using Chalks.ConcurrentEdition;
using Chalks.Gui;
using Chalks.Gui.ChalksWindow; // give access to the log



            
namespace Chalks.Network
{


    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    class AuthenticationRealm :MarshalByRefObject
    { // object that allow login of remote users
      // all his public methods are exposed to remote calls

        local_node :NetworkNode;
        
        public this(_local_node :NetworkNode)
        {
            local_node = _local_node; // this object is private
            
            ;
        }
        
        public login(site_id :Guid,
                     nickname :string, password :string
                     ) :ConcurrentEditableNodeProxy * Guid * string
        {
            when (local_node.remote_sites.Contains(site_id))
                throw RemotingException("Fatal error: overlapping site_ids");

            when (nickname.Length < 3)
                throw RemotingException("Nickname has to have at least three characters");

            if (local_node.is_equal_to_password(password)) {

                //
                
                // return a reference to a concurrenteditablenodeproxy
                (ConcurrentEditableNodeProxy(site_id, local_node),
                local_node.site_id, local_node.nickname);
            }
            else {
                throw RemotingException("Password does not match");
            }  
        }
    } // end of AuthenticationRealm class
        
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
    public class ConcurrentEditableNodeProxy :MarshalByRefObject
    // manage the network calls to the local calls
    // all his public methods are exposed to remote calls
    // this is the object that is passed to other nodes when login
    {

        local_node :NetworkNode;
        remote_site_id :Guid;
        
        public this(_site_id :Guid, _local_node :NetworkNode)
        {
            local_node = _local_node; // this object is private
            // store the id of the remote node that uses the reference to this proxy instance
            remote_site_id = _site_id; 
            ;
        }


        public add_node(remote_node :ConcurrentEditableNodeProxy) :ConcurrentEditableNodeStatus
        { // a remote node connects himself
          // return the "Set text" operation and send all the HB  

          // register the new remote_node_proxy reference
          local_node.remote_sites[remote_site_id] = remote_node;

          local_node.cce.get_status();
        }
        
        
        public receive_operation(op :Operation) :void
        {
            ;
        }

        public receive_message(message :string) :void
        {
            ;
        }

        public get_site_id() :Guid
        {
            local_node.get_site_id();
        }

        public get_nickname() :string
        {
            "get_nickname is not yet implemented";
        }

    }

    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
            
    public class NetworkNode
    {
        static default_service_name = "chalks";
        min_port = 1080;
        max_port = 1090;
        
        public site_id :Guid = System.Guid.NewGuid();

        gui :IGuiForNetwork;
        public cce :ICeForNetwork;
        
        public mutable nickname :string = "";
        mutable password :string = "";

        authentication_realm :AuthenticationRealm;
        self_uri :string;

        // site_id => ConcurrentEditableNodeProxy references (give access to other sites)
        public remote_sites :Hashtable[Guid, ConcurrentEditableNodeProxy] = Hashtable();
        // site_id => ConcurrentEditableNodeProxy instances (give access from other sites)
        public local_proxies :Hashtable[Guid, ConcurrentEditableNodeProxy] = Hashtable();
        // site_id => nickname
        public sites_nicknames :Hashtable[Guid, string] = Hashtable(); 
        
        
        
        public this(_gui :IGuiForNetwork, _cce :ICeForNetwork)
        {
            this(_gui, _cce, default_service_name);
            // service_name management is a trick for tests,
            // it should not be used in the application
        }
                
        public this(_gui :IGuiForNetwork, _cce :ICeForNetwork, service_name :string) 
        {
            
            gui = _gui; // store the gui reference
            gui.set_site_id(site_id); // configure the cce_widget

            cce = _cce; // store concurrent editable reference
            
            // search channel for the service
            mutable channel = null :TcpChannel;
            mutable found_port = false;
            mutable port = min_port;

            while( (!found_port) && port <= max_port)
            {
                try {
                    channel = /*Remoting.Channels.Tcp.*/TcpServerChannel ("", port);
                    ChannelServices.RegisterChannel (channel);
                    found_port = true;
                }
                catch {
                    e => match(e)
                    {
                        | _ is Net.Sockets.SocketException // raised by occupied ports
                        // | _ is System.Runtime.Remoting.RemotingException // raised by already occupied uri
                        =>
                          ChannelServices.UnregisterChannel (channel);
                          port +=1;
                          //Console.WriteLine($"Going to tests port $(port.ToString())");
                          // Console.Out.Flush();
                          
                          //| _ => (); // other exception are not managed
                      }
                      
                  }
              }
              
            
            //Assert.IsTrue(found_port < max_port,
            //       $"Could not find an aviable port in the range $(min_port)-> $(max_port)");

            Console.WriteLine($"Found available port $(port)");
            Console.Out.Flush();

            
            // Publish the authentification service
            authentication_realm = AuthenticationRealm(this);
            _ = RemotingServices.Marshal (authentication_realm, service_name);
       
            //Console.WriteLine($"obj_ref $(obj_ref.ToString()) $(obj_ref.URI)");

            // obtain the uri of the published object
            // take a look at
            // http://www.thinktecture.com/Resources/RemotingFAQ/GETMARSHALBYREFOBJECTSURL.html
            // get self_ip // <<< should use a better method
            def host = Net.Dns.GetHostByName(Net.Dns.GetHostName());
            def self_ip = Net.IPAddress(host.AddressList[0].Address).ToString();
            
            // set the uri
            self_uri = $"tcp://$(self_ip):$(port)/$(service_name)";

            // register ourself with the cce object (we give him network access)
            cce.set_network_interface(this);

            log($"Chalks service aviable at:\n$(self_uri)\n");

        }

        public is_equal_to_password(credential :string) :bool
        {
            credential == password;
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        # region Methods used by the Gui


        public start_collaborating(uri :string) :bool
        { // this implement the protocol described in the schema at
          // chalks/doc/schemas/chalks.dia
          
            mutable ret = true;
            try {
            
                
                log($"Starting collaboration with $(uri)");
                log("Trying to connect");

                // requesting the realm remote object
                ChannelServices.RegisterChannel (TcpClientChannel ()); // create a client channel

                def remote_authentication_realm =
                    Activator.GetObject( typeof(AuthenticationRealm), uri) :> AuthenticationRealm; 
                log("Starting authentication process");
                def (parent_node, parent_site_id, parent_nickname) =
                    remote_authentication_realm.login(site_id, nickname, password);


                def self_node_proxy = ConcurrentEditableNodeProxy(parent_site_id, this);
                def parent_status = parent_node.add_node(self_node_proxy);

                // store the references
                remote_sites[parent_site_id] = parent_node;
                local_proxies[parent_site_id] = self_node_proxy;
                sites_nicknames[parent_site_id] = parent_nickname;
                
                cce.set_status(parent_status);
                
                ;
            }
            catch {
                | e =>
                  ret = false;
                  log($"Connection failed : $(e.Message)")
            }

            ret;
        }
        

        public delegate receive_message_delegate(_ :string) :void;
        
        public send_message(site_id :Guid, message :string) :void 
        { // sends a message to another user
            // when site_id == Guid.Empty, the message is a broadcast

            def remote_async_callback(async_result :IAsyncResult) :void 
            { // local definition of the remote method callback
                def _delegate = ((async_result :> AsyncResult).AsyncDelegate) :>receive_message_delegate;
                // receive_message returns void, so, we only show success
                log("Message sent to $(site_id.ToString()) was received");
                //+ _delegate.EndInvoke(async_result).ToString() );
                    
            }

            
            def send_a_message(site :ConcurrentEditableNodeProxy, message :string) :void
            { // local helper function that send a message to a remote instance
              // the action is asyncronous
                
                //site.receive_message(message);
                def remote_method_delegate = receive_message_delegate(site.receive_message);
                def args = array[message]; // <<<
                def callback = /*null;*/  remote_async_callback;

                //async_call(remote_method_delegate, args, callback)
                def remote_callback = AsyncCallback(callback);
                def rem_async_res =
                    remote_method_delegate.BeginInvoke(message, remote_callback, null);// :IAsyncResult;
                //rem_async_res is of type :IAsyncResult
            }
            
            if (   site_id != Guid.Empty //adressed message
                && remote_sites.ContainsKey(site_id)) { // and we know the adressee
                    def site = remote_sites[site_id];
                    send_a_message(site, message);
                    
                ; // return void
            } // if we do not know the adressee, we broadcast the message

            else { // broadcast message
                foreach(site in remote_sites.Values) {
                    send_a_message(site, message);
                    
                    
                }
                ; // return void
            }
            ;
        }

        public get_self_uri() :string
        // get the uri of the published object
        { 
            self_uri;
        }

        public get_site_nickname(site_id :Guid) :string
        // return the nickname of a remote user
        {
            sites_nicknames[site_id];
        }

        public discover_nodes() :void
        // return a list of published documents->uri
        // this method use RendezVous services 
        { 
            ;
        }

        public set_nickname(_nickname:string) :void
        {
            nickname = _nickname;
            // this event should be propagated to the remote nodes
        }
        
        public set_password() :void
        // set the access password for the local document
        // it is also the password used to connect to other nodes
        {
            // if users are already connected to the local node, disconnect them, they need a new credential
            ;
        }
        #endregion

        
        #region Methods used by the ConcurrentEditable object

        public delegate receive_operation_delegate(_ :Operation) :void;
        
        public send_operation(op :Operation) :void
        { // broadcast an operation to the other sites
            foreach(site in remote_sites.Values) {
                //site.receive_operation(op);
                def remote_method_delegate = receive_operation_delegate(site.receive_operation);
                def args = array[op]; // <<<
                def callback = null;
                //async_call(remote_method_delegate, args, null);
                def remote_callback = AsyncCallback(callback);
                def rem_async_res =
                    remote_method_delegate.BeginInvoke(op, remote_callback, null) :IAsyncResult;
                //rem_async_res is of type :IAsyncResult
            }
            
            ;
        }

        public get_site_id() : Guid
        { // return the unique site id for the local document
            site_id;
        }

        #endregion


        #region Helpers methods

        // << This method can not exist ... sorry
        /*async_call(remote_method_delegate :object, args :array[object],
                   callback :object) :IAsyncResult
        { // creates an asynchronous call and attach a callback method
            //http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconasynchronousremoting.asp
            //http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconRemotingExampleAsynchronousRemoting.asp
            // http://msdn.microsoft.com/msdnmag/issues/01/08/Async/

            def remote_callback = AsyncCallback(callback);
            def rem_async_res =
                    remote_method_delegate.BeginInvoke(remote_callback, args) :IAsyncResult;
            //rem_async_res.AsyncWaitHandle.WaitOne();
            rem_async_res;
        }*/
        
        #endregion
        
    } // end of class NetworkNode

}