/*

*/

using Nemerle.Collections; // for Hashtable

using System;
using System.Net;
using System.IO;
using System.Guid;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Remoting.Messaging;
using System.Threading;

using Chalks; 
using Chalks.ConcurrentEdition;
using Chalks.Gui;
using Chalks.Gui.ChalksWindow; // give access to the log


namespace Chalks.Network
{


    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    class AuthenticationRealm :MarshalByRefObject
    { // object that allow login of remote users
      // all his public methods are exposed to remote calls

        local_node :NetworkNode;
        
        public this(_local_node :NetworkNode)
        {
            local_node = _local_node; // this object is private

            // just for debugging
            log($"AuthenticationRealm instance created $(this.GetHashCode())"); 
            ;
        }
        
        public login(site_id :Guid,
                     nickname :string, password :string
                     ) :ConcurrentEditableNodeProxy * Guid * string
        {
            when (local_node.remote_sites.Contains(site_id))
                throw RemotingException("Fatal error: overlapping site_ids");

            when (nickname.Length < 3)
                throw RemotingException(
                $"Nickname has to have at least three characters. Yours was '$(nickname)'.");

            when ( ! local_node.is_equal_to_password(password) )
                throw RemotingException("Password does not match");
            
            
            log(1, $"Site $(site_id) named as '$(nickname)' was accepted in the realm");
            
            // give access to the local node, send us identifiers
            (ConcurrentEditableNodeProxy(site_id, local_node),
             local_node.get_site_id(), local_node.nickname);
            
            //(null :ConcurrentEditableNodeProxy, Guid.Empty, ""); // <<< just as a test
        }
        
    } // end of AuthenticationRealm class
        
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
    public class ConcurrentEditableNodeProxy :MarshalByRefObject
    // manage the network calls to the local calls
    // all his public methods are exposed to remote calls
    // this is the object that is passed to other nodes when login
    {

        local_node :NetworkNode;
        remote_site_id :Guid;
        
        public this(_site_id :Guid, _local_node :NetworkNode)
        {
            local_node = _local_node; // this object is private
            // store the id of the remote node that uses the reference to this proxy instance
            remote_site_id = _site_id; 
            ;
        }


        public add_node(remote_node :ConcurrentEditableNodeProxy) :ConcurrentEditableNodeStatus
        { // a remote node connects himself
          // return the "Set text" operation and send all the HB  

          // register the new remote_node_proxy reference
          local_node.remote_sites[remote_site_id] = remote_node;

          local_node.cce.get_status();
        }
        
        
        public receive_operation(_op :Operation) :void
        {
            throw Exception("to be implemented");
        }

        public receive_message(_message :string) :void
        {
            throw Exception("to be implemented");
        }

        public get_site_id() :Guid
        {
            local_node.get_site_id();
        }

        public get_nickname() :string
        {
            "get_nickname is not yet implemented";
        }

    }

    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
            
    public class NetworkNode :INetworkForCe
    {
        static default_service_name = "chalks";
        min_port = 1080;
        max_port = 1090;
        
        site_id :Guid = System.Guid.NewGuid();

        gui :IGuiForNetwork;
        public cce :ICeForNetwork;
        
        public mutable nickname :string = "";
        mutable password :string = "";

        authentication_realm :AuthenticationRealm;
        self_uri :string;

        // site_id => ConcurrentEditableNodeProxy references (give access to other sites)
        public remote_sites :Hashtable[Guid, ConcurrentEditableNodeProxy] = Hashtable();
        // site_id => ConcurrentEditableNodeProxy instances (give access from other sites)
        public local_proxies :Hashtable[Guid, ConcurrentEditableNodeProxy] = Hashtable();
        // site_id => nickname
        public sites_nicknames :Hashtable[Guid, string] = Hashtable(); 
        
        
        
        public this(_gui :IGuiForNetwork, _cce :ICeForNetwork)
        {
            this(_gui, _cce, default_service_name);
            // service_name management is a trick for tests,
            // it should not be used in the application
        }
                
        public this(_gui :IGuiForNetwork, _cce :ICeForNetwork, service_name :string) 
        {
            
            gui = _gui; // store the gui reference
            gui.set_site_id(site_id); // configure the cce_widget

            cce = _cce; // store concurrent editable reference
            
            // search channel for the service
            mutable channel = null :TcpChannel;
            mutable found_port = false;
            mutable port = min_port;

            while( (!found_port) && port <= max_port)
            {
                try {
                    channel = /*Remoting.Channels.Tcp.*/ TcpServerChannel("", port);
                    ChannelServices.RegisterChannel (channel);
                    found_port = true;
                }
                catch {
                    e => match(e)
                    {
                        | _ is Net.Sockets.SocketException
                        // raised by occupied ports

                        //| _ is System.Runtime.Remoting.RemotingException
                        // raised by already occupied uri

                        =>
                          ChannelServices.UnregisterChannel (channel);
                          port +=1;
                          //Console.WriteLine($"Going to tests port $(port.ToString())"); 
                          //Console.Out.Flush();
                          
                        | e => throw e; // other exception are not managed
                      }
                      
                  }
              }
              

            assert(port < max_port,
                   $"Could not find an aviable port in the range $(min_port)-> $(max_port)");

            Console.WriteLine($"Found available port $(port)"); Console.Out.Flush();
            
            // Publish the authentification service
            authentication_realm = AuthenticationRealm(this);
            _ = RemotingServices.Marshal (authentication_realm,
                                          service_name, typeof(AuthenticationRealm));
       
            // set the uri of the published object
            def self_ip = find_self_ip();
            self_uri = $"tcp://$(self_ip):$(port)/$(service_name)";

            // register ourself with the cce object (we give him network access)
            cce.set_network_interface(this);

            log($"Chalks service aviable at:\n$(self_uri)\n");
        }

        public is_equal_to_password(credential :string) :bool
        {
            credential == password;
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        # region Methods used by the Gui

        public start_collaborating(uri :string) :bool
        { // this implement the protocol described in the schema at
          // chalks/doc/schemas/chalks.dia
          
            mutable ret = true;
            try {
                log($"Starting collaboration with $(uri)");
                log($"Client : $(this.self_uri) -> Server $(uri)"); // just for debugging
                log("Trying to connect");

                // requesting the realm remote object
                ChannelServices.RegisterChannel(TcpClientChannel ()); // create a client channel

                def remote_authentication_realm =
                    Activator.GetObject( typeof(AuthenticationRealm), uri) :> AuthenticationRealm; 
                log("Starting authentication process");
                def ret_tuple = remote_authentication_realm.login(site_id, nickname, password);
                def (parent_node, parent_site_id, parent_nickname) = ret_tuple;
                
                log("Credentials accepted, retrieving document");
                def self_node_proxy = ConcurrentEditableNodeProxy(parent_site_id, this);
                def parent_status = parent_node.add_node(self_node_proxy);

                // store the references
                remote_sites[parent_site_id] = parent_node;
                local_proxies[parent_site_id] = self_node_proxy;
                sites_nicknames[parent_site_id] = parent_nickname;

                log("Starting collaboration");
                cce.set_status(parent_status);
            }
            catch {
                | e =>
                  ret = false;
                  log($"Connection failed : \n$e\n\n");
                  when (Chalks.Gui.ChalksWindow.verbosity_level > 0)
                        throw e; // just for debugging
            }

            ret;
        } // end of start_collaborating
        

        public delegate receive_message_delegate(_ :string) :void;
        
        public send_message(site_id :Guid, message :string) :void 
        { // sends a message to another user
            // when site_id == Guid.Empty, the message is a broadcast

            def async_callback(async_result :IAsyncResult) :void 
            { // local definition of the remote method callback
                def _delegate = ((async_result :> AsyncResult).AsyncDelegate) :>receive_message_delegate;
                // receive_message returns void, so, we only show success
                log("Message sent to $(site_id.ToString()) was received");
                //+ _delegate.EndInvoke(async_result).ToString() );
            }

            
            def send_a_message(site :ConcurrentEditableNodeProxy, message :string) :void
            { // local helper function that send a message to a remote instance
              // the action is asyncronous
                
                def remote_method_delegate = receive_message_delegate(site.receive_message);
                _ = remote_method_delegate.BeginInvoke(message,
                                                       AsyncCallback(async_callback), null);
            }
            
            if (   site_id != Guid.Empty //adressed message
                && remote_sites.ContainsKey(site_id)) { // and we know the adressee
                    def site = remote_sites[site_id];
                    send_a_message(site, message);
            } // if we do not know the adressee, we broadcast the message
            
            else { // broadcast message
                foreach(site in remote_sites.Values)
                    send_a_message(site, message);
            }
            ; // return void
        }

        
        public get_self_uri() :string
        {// get the uri of the published object
            self_uri;
        }

        public get_site_nickname(site_id :Guid) :string
        { // return the nickname of a remote user
            sites_nicknames[site_id];
        }

        public discover_nodes() :void
        { // return a list of published documents->uri
          // this method use RendezVous services 

            ;
        }

        public set_nickname(_nickname :string) :void
        {
            nickname = _nickname;
            // this event should be propagated to the remote nodes
        }
        
        public set_password(_password :string) :void
        { // set the access password for the local document
          // it is also the password used to connect to other nodes
            // if users are already connected to the local node, disconnect them, they need a new credential
            ;
        }
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Methods used by the ConcurrentEditable object

        public delegate receive_operation_delegate(_ :Operation) :void;
        
        public send_operation(op :Operation) :void
        { // broadcast an operation to the other sites
            
            foreach(site in remote_sites.Values) {
                def remote_method_delegate = receive_operation_delegate(site.receive_operation);
                _ =  remote_method_delegate.BeginInvoke(op,
                                                        AsyncCallback(null), null);
            }
            ; // return void
        }

        public get_site_id() : Guid
        { // return the unique site id for the local document
            site_id;
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Helpers methods

        find_self_ip() :string
        { // get the best estimate of our network ip
            
            mutable ip="127.0.0.1";
            
            try {
                def url = "http://imgseek.sourceforge.net/cgi-bin/getMyAddress.pl";
                def http_web_request = WebRequest.Create(url);
                http_web_request.Method = "GET";
                def http_web_response = http_web_request.GetResponse();
                def stream = StreamReader(http_web_response.GetResponseStream());
                ip = stream.ReadToEnd();
                stream.Close();
            }
            catch { // could not do the webpage trick
                | _ =>
                    def host = Net.Dns.GetHostByName(Net.Dns.GetHostName());
                    ip = Net.IPAddress(host.AddressList[0].Address).ToString();      
            }
    
            ip;
        }
               
        #endregion
        
    } // end of class NetworkNode

    public interface INetworkForCe
    { // this are the methods that the ConcurrentEdition layer use of the NetworkNode object
        get_site_id() :Guid;
        send_operation( op:Operation) :void;
    }

}