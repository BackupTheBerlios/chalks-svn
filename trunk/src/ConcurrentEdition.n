/*
This code correspond to an implementation of a Concurrent Editable Text buffer.

The code is strictly based on the works of Chengzheng Sun.

Actually all the function were written in order to follow as much as possible the notation introduced in his papers. So most of the code is procedure oriented and not strictly pythonic.

Search at http://www.researchindex.com for the files:

    operational_transformation_issues_algorithms_achievements.djvu
    sun98achieving.pdf (<- the must)
    sun97generic.pdf (citeseer.nec.jp.com/sun97generic.htm)
    sun98operational.pdf
    sun98reversible.pdf

You need this documents to understand the code.
*/


using Nemerle.Collections;

using System;
using System.IO;
using System.Guid;

using Chalks;
using Chalks.Network;
using Chalks.Gui.ChalksWindow; // get access to log function

using System.Runtime.Remoting;

namespace Chalks.ConcurrentEdition
{	  
	  
    public class ConcurrentEditable :ICeForNetwork
    { //This is the core object of Chalks.
      //This class defines an object that is able to manage concurrent edition from diferent sites.
      	// Definition of the members
        mutable network_node  :INetworkForCe;
        mutable site_id :Guid;
        
        // internal state
        state_vector :Hashtable[Guid, int]; 
                
        state_vector_table :Hashtable[Guid, Hashtable[Guid, int]];
        minimum_state_vector :Hashtable[Guid, int]; 

        HB :Chalks.ArrayList[Operation]; // history buffer
        delayed_operations :Chalks.ArrayList[Operation]; 

        text_buffer :ITextBuffer;


        // Constructors
        public this(text_buffer_instance :ITextBuffer)
        {
            site_id = Guid.Empty;
            text_buffer = text_buffer_instance;

            // intialize the internal state

            throw Exception("to be implemented");
            /*
            def __init__(self, site_index, num_of_sites):
            //if site_index == None then the site is and Observer
            
            self.site_index   = site_index
            self.state_vector = [0] * num_of_sites
            
            self.state_vector_table   = [[0]* num_of_sites]* num_of_sites # required by the garbage collector (SVT)
            self.minimum_state_vector = [0]*num_of_sites # required by the garbage collector (MSV)
            
            if self.site_index != None:
               self.state_vector_table [self.site_index] = self.state_vector # link with local state_vector
  
            self.HB = [] # history buffer
            self.delayed_operations = [] 
            */
            
            //log("Concurrent editable instance created");
            ;   
            
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Methods used by Gui

        public save_file(file_path :string) :void
        {
            def file_extension =  Path.GetExtension(file_path);
            match(file_extension)
            {
                | ".txt" =>
                    def stream = IO.StreamWriter(file_path);
                    stream.Write(text_buffer.get_text());
                    stream.Close();
                  
                | _ => 
                  Console.WriteLine("Do not know how to save the content in the format " + file_extension);
              }
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Methods used by ConcurrentEditionWidget
        
        public generate_operation(optype :OperationType, pos :int, text :string) :Operation
        {
            assert(this.site_id != Guid.Empty);
            assert(optype == OperationType.Insert);

            log($"generating insert($(pos), '$(text)')");
            //throw Exception("to be implemented");
            // create operation object
            def op = Operation(optype, pos, text);
            
            // apply localy
            // send to the peers
            
            op;
        }
        
        public generate_operation(optype :OperationType, pos :int, length :int) :Operation
        {
            assert(this.site_id != Guid.Empty);
            assert(optype == OperationType.Delete);

            log($"generating delete($(pos), $(length))");
            //throw Exception("to be implemented");
            // create operation object
            def op = Operation(optype, pos, length);

            // apply localy
            // send to the peers
            
            op;
        }

        
        #endregion

        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Methods used by Network, implementation of ICeForNetwork

        public set_network_interface(network_node_instance :INetworkForCe) :void
        {
            network_node = network_node_instance;
            site_id = network_node_instance.get_site_id();
            //log("ConcurrentEditable has setup his network interface");
            ;
        }

        public receive_operation(op :Operation) :void
        { // receive an operation to execute
          // check if it is causally ready
          // if not delay it
          // else execute it
          // if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
          // ---
          // The workflow is receive->apply->execute

            log(1, $"Site $(site_id);%(state_vector); receiving $(op)");

            if( is_causally_ready(op) ) { // if it is causally ready

                // execute it (apply to local buffer)
                apply(op); 
                
                // check the delayed buffer to check for operation that now can be operated
                // (and so on until no operation is executable)			
                mutable applied_an_operation = true;
                
                while (applied_an_operation){

                    applied_an_operation = false;
                    def iterator = delayed_operations.GetEnumerator();
                    mutable t_op = iterator.Current :> Operation;
                    
                    do {
                        t_op = iterator.Current :> Operation;
                        when ( is_causally_ready(t_op) ) {
                            apply(t_op);
                            delayed_operations.Remove(t_op);
                            applied_an_operation = true;
                        }
                    } while (   iterator.MoveNext() // returns false at the end of the list
                             && (applied_an_operation == false) )
                    
                } // end of while
                
            }
            else{ // if not causally ready we delay it
                delayed_operations.Add(op);
            }
        

            log(1, $"Site $(site_id); HB $(HB)");
            log(1, $"Site $(site_id);%(state_vector); delayed_ops: $(delayed_operations)\n");
            ;
        } // end of receive_operation

        
        public add_site(site_id :Guid) :void
        {
            throw Exception("to be implemented");
            ;
        }

        public delete_site(site_id :Guid) :void
        { // erase a reference to a site

            throw Exception("to be implemented");
            ;
        }

        public get_status() :ConcurrentEditableNodeStatus
        { // return a copy of the node status, to initialize another node
            
            def status = ConcurrentEditableNodeStatus();

            //status.Text = Text.Copy();
            //status.HB = HB.Copy();
            //status.SV = SV.Copy();

            throw Exception("to be implemented");
            
            status;
        }

        public set_status(status :ConcurrentEditableNodeStatus) :void
        { // (re)initialize the internal state (occurs when entering in an existing session)

            throw Exception("to be implemented");
            ;

        }
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Method used for tests

        override public ToString():string
        {
            $"Site $site_id";
        }

        public get_SV() :Hashtable[Guid, int] 
        {
            state_vector;
        }
        
        public get_MSV() :Hashtable[Guid, int]
        {
            minimum_state_vector;
        }

        public get_HB() :ArrayList[Operation]
        {
            HB;
        }
        
        public get_delayed_operations() :ArrayList[Operation]
        {
            delayed_operations;
        }

        
        #endregion
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Private methods (related to the concurrent edition algorithm)

        
        apply(o_new :Operation) :void
        { // Algorithm 3: The undo/transform-do/transform-redo scheme (sun98generic)
          //
          // Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
          //  1. Undo operations in HB from right to left until
          //     an operation EOm is found such that EOm => Onew .
          //  2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
          //  3. Transform each operation EOm+i in HB[m+1,n] into
          //     the new execution form EO'm+i as follows:
          //  - EO'm+1 := IT (EOm+1, EOnew ).
          //  - For 2 <= i <= (n - m),
          //      (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
          //      (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
          //  Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
          //
          //  After the execution of the above steps, the contents of
          //  the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
          //  ---
          //  This function manage the History Buffer and update the State Vector Table.


            assert(   T(o_new) == OperationType.Insert
                   || T(o_new) == OperationType.Delete,
                   "Invalid operation request.");

            log(1, $"Site $(site_id);$(state_vector); '$(text_buffer.get_text())'; applying $(o_new)");
    
            // 1.
            mutable m = 0; // manage the case HB == []
            def undoed = ArrayList() :Chalks.ArrayList[Operation];
              
            {
                def enumerator = range(len(HB), 0).GetEnumerator();
                mutable not_in_total_ordering = true;
                                
                do{ //foreach( m in range(len(HB), 0) ) {	 // from right to left
                    m = enumerator.Current;
                    def EOm = HB[m];
                    //log("check_total_ordering($(EOm), $(o_new)) => $(check_total_ordering(EOm, o_new))"); // just for debugging
                    
                    if (not check_total_ordering(EOm, o_new)) {
                        undo(EOm);
                        // operations do should not be erased from HB,
                        // because they will later be transformed !
                        undoed.Add(EOm);
                    }
                    else {
                        not_in_total_ordering = false; // break;
                    }
                    
                } while(enumerator.MoveNext() && not_in_total_ordering);
                
            }
            
            when ( (len(HB) != 0)  && (len(undoed) == len(HB)) ) {
                log(2, "No previous op found !");
                m = -1; // to indicate that no previous op was found
            }


            // 2.
            def eo_new = GOT( o_new, HB.Slice(':', m+1)); // pass o_new and HB = [EO1, EO2, ..., EOm ]
            execute(eo_new);
            // eo_new will be inserted after step 3 to follow better the paper notation.
            log(2, "m $(m); [EO1, ..., EOm ] $(HB.Slice(':',m+1)); HB.Slice(m+1,':') $(HB.Slice(m+1,':'))");
    
        
            // 3.
            when (len(undoed) > 0) { // if there was an undo, then redo
                
                log(1, // just for debugging
                    "Site $(site_id); '$(text_buffer.get_text())'; undoed $(undoed); executed $(eo_new);");
                
                def EOoL = ArrayList() :ArrayList[Operation]; // EO'm+1 List
    
                EOoL.Add( IT( HB[m+1], eo_new ) );
                
                foreach (i in range(1, len(undoed))) {
                    // C# indexes start from 'zero' (in the paper they start from 'one')

                    // paper [m+1,m+i - 1] -> c# [m+1:m+i +1]
                    def TO = LET( HB[m+1+i], reversed(HB.Slice(m+1, m+i +1)));

                    def t_list = ArrayList() :> ArrayList[Operation];
                    t_list.Add(eo_new);  t_list.Append(EOoL);  //[eo_new] + EOoL
                    EOoL.Add( LIT( TO, t_list) );
                }
                
                //log(1, "m: $(m); len(EOoL) ($EOoL.Length);EOoL $(EOoL)"); // just for debugging
                
                foreach ( i in range(len(EOoL)) ) {			
                    def t_op = EOoL[i];
                    execute(t_op);
                    HB[m+1+i] = t_op; // c# indexes start from 'zero'
                }
            } // end of 'when(undoed)'
    
            // After the execution of the above steps [...]
            // HB = [EO1,..., EOm, eo_new, EO'm+1,..., EO'n ].
            HB.Insert(m + 1, eo_new); // insert into the HB, just after EOm
            
            
            // Update local State vector
            def t_site_id = o_new.SourceSite;
            
            assert(state_vector.ContainsKey(t_site_id),
                   "Received an operation from a source_site not listed in the state_vector");
            state_vector[t_site_id] += 1;
        
            // Update the State Vector Table (via a copy)
            // (it store what we know about the status of each site, including ourself)
            state_vector_table[eo_new.SourceSite] = eo_new.TimeStamp.Clone();
            
            // call the garbage collector (over a dummy periodic condition)
            when ((len(HB) % 10) == 0) collect_garbage();
                                
            ;
        }

        
        execute(eo :Operation, splitted_part :bool) :void
        { // Modify the text buffer.
          // The lost information is stored into the operators for future undos.

            if (eo.is_splitted) {
                execute(eo.splitted_head, true); //splitted_part = true
                execute(eo.splitted_tail, true); //splitted_part = true
            }
            else {
                match (T(eo)) {
                    | OperationType.Insert =>
                      text_buffer.insert_text(site_id, P(eo), S(eo));
                      
                    | OperationType.Delete =>
                      // stores the erased text for future undos
                      eo.deleted_text = text_buffer.delete_text(P(eo), L(eo));
                      
                    | _ => throw Exception("Tried to execute an Unmanaged Operation type $(eo)");
                }
            }
            ;
        }
        
        execute(eo :Operation) :void
        {
            execute(eo, false); // if omited, it is not a splitted_part operation
        }

        redo(op :Operation) :void
        { // an alias
            execute(op); 
        }


        undo(op :Operation) :void
        {
            throw Exception("to be implemented");
            ;
        }
        
        public collect_garbage() :void // public for tests
        {
            throw Exception("to be implemented");
            ;
        }

        public update_SVT( site_id:Guid, state_vector :Hashtable[Guid, int]) :void 
        { // public for tests
          // update_StateVectorTable
          //
          // sun98achievings.pdf, page 19 paragraph 2.
          // If one site happens to be silent for an unusually long period of time,
          // other sites will not know what its state is [a 'mostly observer' site].
          // Therefore, it is required for a site to broadcast a short state message
          // containing its state vector when it has not generated an operation for a
          // certain period of time and/or after executing a certain number of remote
          // operations. Upon receiving a state message from a remote site r, site k
          // simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
          // ---
          // Can update the SVT sending dummy Insert(0, "") operations
            
            state_vector_table[site_id] = state_vector;
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Internal GOT algorithm functions
        
        is_causally_ready(op :Operation) :bool
        { // Definition 5: Conditions for executing remote operations
          //  
          // Let O be an operation generated at site s and timestamped by SVo .
          // O is causally-ready for execution at site d (d != s) with a state vector SVd
          // only if the following conditions are satisfied:
          // 1. SVo [s] = SVd [s] + 1, and
          // 2. SVo [i] <= SVd [i], for all i in {0,1, ..., N - 1} and i != s.


            def SVd = this.state_vector;
            def SVo = op.TimeStamp;
            def s  = op.SourceSite;
            
            // <<< to be implemented
            throw Exception("to be implemented");
            
            true;
        }

        check_total_ordering(_:Operation, _:Operation) :bool
        {
            throw Exception("to be implemented");
            ;
        }

        // Definition 1: Causal ordering relation "->"
        // 
        // Given two operations Oa and Ob , generated at sites i and j, then Oa -> Ob , 
        // iff:
        //     1. i = j and the generation of Oa happened before the generation of Ob , 
        // or
        //     2. i != j and the execution of Oa at site j happened before the 
        // generation of Ob , or
        //     3. there exists an operation Ox, such that Oa -> Ox and Ox -> Ob.
        // 
        // Definition 2: Dependent and independent operations
        // 
        // Given any two operations Oa and Ob.
        //     1. Ob is said to be dependent on Oa iff Oa -> Ob.
        //     2. Oa and Ob are said to be independent (or concurrent) iff neither Oa 
        // -> Ob , nor Ob -> Oa , which is expressed as Oa || Ob.
        // 
        // (nor == not or; 0,0 => 1 , 0 else)
        // 

        are_dependent(oa :Operation, ob :Operation) :bool
        { // Implement a less than strict check.
          // Will return true if (Oa->Ob) or if there is a Ox such as (Oa->Ox and Ox->Ob)
          // After reading in detail the papers I propose:
          //  Oa -> Ob iff :
          //  if i==j: return SVoa[i] < SVob[i]
          //  else:    return SVoa[i] <= SVob[i]

            def i = oa.SourceSite;
            def j = ob.SourceSite;
    
    
            if (i == j) oa.TimeStamp[i] <  ob.TimeStamp[i];
            else oa.TimeStamp[i] <= ob.TimeStamp[i];
        }

        
        are_concurrent(oa :Operation, ob :Operation) :bool        
        { // Check if both operations are independent (or concurrent)
          // return Oa->Ob nor Ob->Oa
          // (nor == not or; 0,0 => 1 , 0 else)

            //not (are_dependent(oa,ob) or are_dependent(ob,oa) );
            not (are_dependent(oa,ob) || are_dependent(ob,oa) );
        }
        
        are_independent :Operation * Operation -> bool = are_concurrent; // just an alias

        
        GOT(Onew :Operation, HB :Chalks.ArrayList[Operation]) :Operation
        {
            throw Exception("to be implemented");
            ;
        }


        LIT(o :Operation, ol :Chalks.ArrayList[Operation]) :Operation
        { // Inclusion transform over a list
            
            if (ol.Count == 0) {
                o;
            }
            else {
                LIT( IT(o, ol[0]),
                     ol.GetRange(1, (ol.Count -1)) // ol[1:]
                     );
            }
        }
        
        LET(o :Operation, ol :Chalks.ArrayList[Operation]) :Operation
        { // Exclusion transform over a list

            if (ol.Count == 0) {
                o;
            }
            else {
                LET( ET(o, ol[0]),
                     ol.GetRange(1, (ol.Count -1)) // ol[1:]
                     );
            }
        }


        IT(oa :Operation, ob :Operation) :Operation
        {
            throw Exception("to be implemented");
            oa;
        }

        
        IT_II(oa :Operation, ob :Operation) :Operation
        {
            if ( P (oa) < P (ob) ) {
                oa;
            }
            else {
                Op( OperationType.Insert, P(oa) + L(ob), S(oa));
            }
        }

        IT_ID() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        IT_DI() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        IT_DD() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        ET(oa :Operation, ob :Operation) :Operation
        {
            throw Exception("to be implemented");
            oa;
        }

        ET_II(oa :Operation, ob :Operation) :Operation
        {
            if ( P(oa) <= P(ob) ) {
                oa;
            }
            else if ( P(oa) >= (P(ob) + L(ob)) ) {
                Op( OperationType.Insert, P(oa) - L(ob),  S(oa));
            }
            else {
                def ooa = Op( OperationType.Insert, P(oa) - P(ob), S(oa) );
                Save_RA(ooa, ob);
                ooa;
            }
        }

        ET_ID() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        ET_DI() :void 
        {
            throw Exception("to be implemented");
            ;
        }
        
        ET_DD() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Helper method to keep a clear syntax

        // Syntax shortcuts
        T(o :Operation) :OperationType
        { // Return the type of operation ("Insert" or "Delete")
           o.Type;
        }

        P(o :Operation) :int        
        {// Return the position where the operation is executed.
            o.Pos;
        }

        L(o :Operation) :int
        { // Return length of the deletion operation.
          // For safness if the operation is no a deletion it return the length of the inserted text. (stricly it should raise an error...)

            match(o.Type)
            {
              | OperationType.Delete => o.Length;
              | OperationType.Insert => o.Text.Length;
              | _ => throw Exception("L(o) invalid for $(o.ToString())");
            }
        }

        S(o :Operation) :string
        { // Return the string that the insert operation is trying to insert.
            assert(o.Type == OperationType.Insert,
                   "S(o) is only valid for Insertion operation.");
            o.Text;
        }

        
        reversed( in_list :Chalks.ArrayList[Operation]) :Chalks.ArrayList[Operation]
        { //Helper function used to have a compact notation

            def out_list = in_list.Clone(); //create a copy
            out_list.Reverse(); //in place operator
            out_list;
        }

        
        Splitted(o1 :Operation, o2 :Operation) :Operation
        { // Return an operation that is splitted.
          // (this should used in function 'execute' and 'undo')

            assert (T(o1) == T(o2),
                    "Splitted operations are of different types, this is not sane.");
            
            assert( not(o1.is_splitted || o2.is_splitted),
                   "Recursive splitted operation not yet supported" );
            
            assert(T(o1) == OperationType.Delete,
                   "Splitted(o1,o2) is not implemented for operations of type $(T(o1).ToString())");
            mutable oo_pos = 0;
            mutable oo_length = 0;
            
            match(())
            {
              | _ when P(o1) < P(o2) =>
                  oo_pos =  P(o1);
                  oo_length =  ( P(o2) + L(o2) ) - P(o1);

              | _ when P(o1) > P(o2) =>
                  oo_pos = P(o2);
                  oo_length = ( P(o1) + L(o1) ) - P(o2);
                  
              | _ =>
                  throw
                  Exception("Weird split P(O1) == P(O2) ($(o1.ToString()), $(o2.ToString())");                }

            def oo = Operation(T(o1), oo_pos, oo_length);
            oo.is_splitted = true;
            oo.splitted_head = o1;
            oo.splitted_tail = o2;

            oo;
        }

        // Lost information
        Check_LI() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        Save_LI() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        Recover_LI() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        // Relative adresses
        Check_RA(oa :Operation) :bool    
        { // Is Oa relatively addressed ?
                
            oa.relatively_addressed == true;
        }

        Save_RA(oa :Operation, ob :Operation) :void
        { // Stores the information to mark Oa as having a relative address to over Ob.
            
            log(2, $"called Save_RA($oa, $ob)"); // just for debugging
            
            oa.relatively_addressed = true;
            oa.base_operation = ob;
            oa.delta_pos = P(oa) - P(ob); // Abis = P(Obbis) + A.delta_pos
            ;
        }

        
        Check_BO(oa :Operation, ob :Operation) :bool        
        { //Ob is the base operation of Oa ? (in the relative address context)

            // look at the definition of Equals in the Operation class
            ob.Equals( oa.base_operation );
        }

        Convert_AA(oa :Operation, ob :Operation) :Operation
        { // Obtain Oaa, which is an absolute address operation based on Oa,
          // over the relative position of Ob.
            
            assert( Check_BO(oa,ob), "Convert_AA: Ob is not the base_operation of Oa" );
            log(2, $"called Convert_AA($oa, $ob)"); // just for debugging
            
            match(T(oa)) {
                | OperationType.Insert =>
                  Operation( oa.Type,	oa.delta_pos + ob.Pos, oa.Text );

                | OperationType.Delete =>
                  Operation( oa.Type,	oa.delta_pos + ob.Pos, oa.Length );
                  
                | _ => throw Exception( $"Convert_AA, unmanaged operation type $(oa.Type)");
            }
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
          
    } // end of class ConcurrentEditable

      
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
      
    #region Definition of the Operation class
    
    public enum OperationType { |Insert |Delete |SetText };

    type Op = Operation;
    type op = Operation;
    
    [Serializable]
    public class Operation
    {

        // Definitions of members
        public Type :OperationType;
        public mutable Pos  :int;
        public mutable Text :string;
        public mutable Length :int;
        public SourceSite :Guid;
        public TimeStamp :Hashtable[Guid, int];

        // non trivial cases members
        public mutable deleted_text :string; // deletions
  
        public mutable is_splitted :bool; // splits
        public mutable splitted_head :Operation;
        public mutable splitted_tail :Operation;

        public mutable relatively_addressed :bool; // relative addresses
        public mutable base_operation :Operation;
        public mutable delta_pos :int;

        public mutable lost_information :object; // lost information
        public mutable LI_base_op :Operation;

        
        // Constructors
        public this(optype :OperationType, pos :int, text :string)
        {
            assert(optype == OperationType.Insert);
            Type = optype;
            Pos = pos;
            Text = text;
            Length = 0;
            ;
        }

        public this(optype :OperationType, pos :int, length :int)
        {
            assert(optype != OperationType.Delete);
            Type = optype;
            Pos = pos;
            Length = length;
            Text = "";
            ;
        }

        public this(optype :OperationType, text :string)
        {
            assert(optype != OperationType.SetText);
            Type = optype;
            Pos = 0;
            Length = 0;
            Text = "";
            ;
        }

        // Methods
        Equal() :void        
        {
            ;
        }

        override public ToString() :string
        {
            $"$Type $Pos $Length $Text $SourceSite"; // <<< implement better
        }

        set_timestamp() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        get_timestamp() :void        
        {
            throw Exception("to be implemented");
            ;
        }

        public Equals(op :Operation) :bool
        {
            // same place, same moment
            (SourceSite.Equals(op.SourceSite)) && (TimeStamp.Equals(op.TimeStamp)); 
        }

    } // end of class Operation

    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    #region Concurrent Editable node Status

    [Serializable]
    public class ConcurrentEditableNodeStatus
    { // this class is a container to initialize a new node into a running session
        
        public mutable Text :string;
        public mutable HB : array[Operation];
        public mutable SV : array[uint];
        
        public this()
        {
            throw Exception("to be implemented");
            ;
        }
    }
    
    
    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    public interface ITextBuffer
    { // This interface define a recipient where the ConcurrentEdition system store the up to date version of the text.
        
        insert_text(site_id :Guid, offset:int, text:string):void;
        // Due of UTF-8 encoding character counts are referred to as "offsets", 
        // this is consistent with the GTK code
        
        delete_text(offset:int, length:int): string;
        // returns the deleted text
        
        get_text():string;
        // return all the text in the buffer
        
        set_text(text:string):void;
        // overwrite the buffer text content
    }
    


    public interface ICeForNetwork
    { // Elements of ConcurrentEditable used by the Network module
        set_network_interface(network_node_instance :NetworkNode) :void;
        receive_operation(op :Operation) :void;
        add_site(site_id :Guid) :void;
        delete_site(site_id :Guid) :void;
        get_status() :ConcurrentEditableNodeStatus;
        set_status(status :ConcurrentEditableNodeStatus) :void;
    }



    
} // end the namespace Chalks.ConcurrentEditable



