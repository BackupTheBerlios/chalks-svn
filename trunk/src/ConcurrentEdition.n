/*
This code correspond to an implementation of a Concurrent Editable Text buffer.

The code is strictly based on the works of Chengzheng Sun.

Actually all the function were written in order to follow as much as possible the notation introduced in his papers. So most of the code is procedure oriented and not strictly pythonic.

Search at http://www.researchindex.com for the files:

    operational_transformation_issues_algorithms_achievements.djvu
    sun98achieving.pdf (<- the must)
    sun97generic.pdf (citeseer.nec.jp.com/sun97generic.htm)
    sun98operational.pdf
    sun98reversible.pdf

You need this documents to understand the code.
*/


using System;
using System.IO;
using System.Guid;

using Nemerle.Collections;

using Chalks; 
using Chalks.Helpers; // for HashToString
using Chalks.Network;


using System.Runtime.Remoting;

namespace Chalks.ConcurrentEdition
{	  
	  
    public class ConcurrentEditable :ICeForNetwork
    { //This is the core object of Chalks.
      //This class defines an object that is able to manage concurrent edition from diferent sites.
      	// Definition of the members
        mutable network_node  :INetworkForCe;
        mutable log :int*string->void;
        mutable site_id :Guid;
        
        // internal state
        state_vector :Hashtable[Guid, int] = Hashtable(); 
                
        state_vector_table :Hashtable[Guid, Hashtable[Guid, int]] = Hashtable();
        minimum_state_vector :Hashtable[Guid, int] = Hashtable(); 

        HB :Chalks.ArrayList[Operation] = ArrayList(); // history buffer
        delayed_operations :Chalks.ArrayList[Operation] = ArrayList(); 

        text_buffer :ITextBuffer;


        // Constructors
        public this(text_buffer_instance :ITextBuffer)
        {
            site_id = Guid.Empty;
            text_buffer = text_buffer_instance;

            // intialize the internal state

            // no site_id is aviable until network interface registration (set_network_interface)
            // state_vector (id -> int) is empty, because no site_id is aviable

            
            // state_vector_table (id->(id->int)) is empty, because no site_id is aviable
            // the SVT is required by the garbage collector
            // minimum_state_vector (id->int) is empty, because no site_id is aviable
            // the MSV is required by the garbage collector
            
            // HB is an empty list
            // delayed_operations is also an empty list

            // initializations are done in set_network_interface, add_site and delete_site
            
            
            //log("Concurrent editable instance created");
            ;   
        }
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Methods used by Network, implementation of ICeForNetwork

        public set_network_interface(network_node_instance :INetworkForCe) :void
        {
            network_node = network_node_instance;
            site_id = network_node_instance.get_site_id();
            log = network_node_instance.log;
            
            state_vector[site_id] = 0;
            
            state_vector_table[site_id] = state_vector; // link with local state_vector
            minimum_state_vector[site_id] = 0;
            
            //log("ConcurrentEditable has setup his network interface");
            ;
        }
        
        public add_site(site_id :Guid) :void
        { // called when we detect a new site collaborating

            when(! state_vector.Contains(site_id)) { // security check
                
                // expand the state variables ---

                // expand the local SV
                state_vector[site_id] = 0; 
                
                // expand the entries in the SVT
                foreach(sv in state_vector_table.Values) {
                    when(! object.ReferenceEquals (sv, state_vector)) {
                        sv[site_id] = 0; }}
            
                def t_sv = state_vector.Clone(); 
                foreach(s_id in t_sv.Keys) t_sv[s_id] = 0; // create a blank state_vector
                state_vector_table[site_id] = t_sv; // add it to the local SVT
            
                // expand the local MSV
                minimum_state_vector[site_id] = 0;
                
                // assert state_vector.Keys == state_vector_table.Keys
                // assert state_vector.Keys == minimum_state_vector.Keys
                
                // expand the timestamps of the stored operations (HB + delayed_operations) ---
            
                def expand_timestamp(op :Operation) :void // helper local function
                {
                    op.TimeStamp[site_id] = 0;
                    
                    when(op.relatively_addressed) expand_timestamp(op.base_operation);
                    
                    when(op.is_splitted) {
                        expand_timestamp(op.splitted_head);
                        expand_timestamp(op.splitted_tail);
                    }
                    
                    when(op.lost_information != null) {
                        expand_timestamp( (op.lost_information :Operation) );
                        expand_timestamp(op.LI_base_op); 
                    }
                }
                
                foreach(op in HB                ) expand_timestamp(op);
                foreach(op in delayed_operations) expand_timestamp(op);


                log(2, "After adding a site to the node");
                log(2, "$this HB $HB");
            }
            ;
        }

        public delete_site(site_id :Guid) :void
        { // erase a reference to a site
          // called when we detect a site has quited the collaborating session
          // essentially implemented to avoid inecessary memory and bandwith usage and
          // to avoid a possible 'connect, disconnect, reconnect' denial of service attack

            // contract the state variables ---
            state_vector.Remove(site_id);

            foreach(sv in state_vector_table.Values) sv.Remove(site_id);
            state_vector_table.Remove(site_id);
            minimum_state_vector.Remove(site_id);

            
            // contract the timestamps of the stored operations (HB + delayed_operations) ---

            def contract_timestamp(op :Operation) :void // helper local function
            {
                op.TimeStamp[site_id] = 0;

                when(op.relatively_addressed) contract_timestamp(op.base_operation);
                
                when(op.is_splitted) {
                    contract_timestamp(op.splitted_head);
                    contract_timestamp(op.splitted_tail);
                }

                when(op.lost_information != null) {
                    contract_timestamp( (op.lost_information :Operation) );
                    contract_timestamp(op.LI_base_op); 
                }
            }

            foreach(op in HB                ) contract_timestamp(op);
            foreach(op in delayed_operations) contract_timestamp(op);
                        
            ;
        }

        public get_status() :ConcurrentEditableNodeStatus
        { // return a copy of the node status, to initialize another node
            
            def status = ConcurrentEditableNodeStatus();

            status.Text = String.Copy( text_buffer.get_text() );

            status.SV = state_vector.Clone();
            status.MSV = minimum_state_vector.Clone();

            status.HB = HB.Clone();
            status.delayed_operations = delayed_operations.Clone();
                        
            status;
        }

        public set_status(status :ConcurrentEditableNodeStatus) :void
        { // (re)initialize the internal state (occurs when entering in an existing session)

            // clean all the state vectors ---
            state_vector.Clear();
            state_vector[site_id] = 0;
            
            state_vector_table.Clear();
            state_vector_table[site_id] = state_vector; // link with local state_vector

            minimum_state_vector.Clear();
            minimum_state_vector[site_id] = 0;

            HB.Clear(); // history buffer
            delayed_operations.Clear();
            
            text_buffer.set_text("");

            // set with new values ---
            text_buffer.set_text(status.Text);

            foreach((k,v) in status.SV.KeyValuePairs) state_vector[k] = v;
            foreach((k,v) in status.MSV.KeyValuePairs) minimum_state_vector[k] = v;

            foreach(op in status.HB) HB.Add(op);
            foreach(op in status.delayed_operations) delayed_operations.Add(op);
            
            // done
            ;
        }

        public receive_operation(op :Operation) :void
        { // receive an operation to execute
          // check if it is causally ready
          // if not delay it
          // else execute it
          // if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
          // ---
          // The workflow is receive->apply->execute

            log(1, $"Site $(site_id.ToString().Substring(0,8));$(HashToString(state_vector)); receiving $(op)");

            if( is_causally_ready(op) ) { // if it is causally ready

                // execute it (apply to local buffer)
                apply(op); 
                
                // check the delayed buffer to check for operation that now can be operated
                // (and so on until no operation is executable)			
                mutable applied_an_operation = true;
                
                while (applied_an_operation){

                    applied_an_operation = false;
                    def enumerator = delayed_operations.GetEnumerator(); enumerator.Reset();
                    mutable t_op = null : Operation;
                    
                    while (   (applied_an_operation == false) 
                           && enumerator.MoveNext() // returns false at the end of the list
                           ){
                        t_op = enumerator.Current :Operation;
                        when ( is_causally_ready(t_op) ) {
                            apply(t_op);
                            delayed_operations.Remove(t_op);
                            applied_an_operation = true;
                        }
                    }
                    
                } // end of while applied_an_operation
                
            }
            else{ // if not causally ready we delay it
                delayed_operations.Add(op);
            }
        

            log(1, $"Site $(site_id.ToString().Substring(0,8)); HB $(HB)");
            log(1, $"Site $(site_id.ToString().Substring(0,8));$(HashToString(state_vector)); delayed_ops: $(delayed_operations)\n");
            ;
        } // end of receive_operation

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Methods used by ConcurrentEditionWidget
        public generate_operation(optype :OperationType, pos :int, text :string) :Operation
        {
            generate_operation(false, optype, pos, text)
        }

        public generate_operation(optype :OperationType, pos :int, length :int) :Operation
        {
            generate_operation(false, optype, pos, length)
        }

        
        public generate_operation(_executed_before_creation :bool,
                                  optype :OperationType, pos :int, text :string) :Operation
        { // The site generate an operation, and apply it locally.
            
            assert(this.site_id != Guid.Empty,
                   "Can not generate operations before the network interface has been set");
            assert(optype == OperationType.Insert);

            def t_SV = state_vector.Clone();
            t_SV[site_id] += 1;
            
            // create operation object
            def op = Operation(optype, pos, text, site_id, t_SV);
            op.executed_before_creation = _executed_before_creation;
            //log($"generating $op");
            
            // apply localy 
            receive_operation(op);

            //send it to the peers
            network_node.send_operation(site_id, op);
            
            op;
        }
        
        public generate_operation(_executed_before_creation :bool,
                                  optype :OperationType, pos :int, length :int) :Operation
        { // The site generate an operation, and apply it locally.
            assert(this.site_id != Guid.Empty,
                   "Can not generate operations before the network interface has been set");
            assert(optype == OperationType.Delete);

            def t_SV = state_vector.Clone();
            t_SV[site_id] += 1;

            // create operation object
            def op = Operation(optype, pos, length, site_id, t_SV);
            op.executed_before_creation = _executed_before_creation;
            //log($"generating $op");
            
            // apply localy 
            receive_operation(op);

            //sent it to the peers
            network_node.send_operation(site_id, op);
            
            op;
        }

        
        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

        #region Methods used by Gui

        public save_file(file_path :string) :void
        {
            def file_extension =  Path.GetExtension(file_path);
            match(file_extension)
            {
                | ".txt" =>
                    def stream = IO.StreamWriter(file_path);
                    stream.Write(text_buffer.get_text());
                    stream.Close();
                  
                | _ => 
                  Console.WriteLine("Do not know how to save the content in the format " + file_extension);
              }
        }

        #endregion
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
                
        #region Method used for tests

        override public ToString():string
        {
            $"Site $(site_id.ToString().Substring(0,8))";
        }

        public get_SV() :Hashtable[Guid, int] 
        {
            state_vector;
        }
        
        public get_MSV() :Hashtable[Guid, int]
        {
            minimum_state_vector;
        }

        public get_HB() :ArrayList[Operation]
        {
            HB;
        }
        
        public get_delayed_operations() :ArrayList[Operation]
        {
            delayed_operations;
        }

        
        #endregion
        
        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Private methods (related to the concurrent edition algorithm)

        
        apply(o_new :Operation) :void
        { // Algorithm 3: The undo/transform-do/transform-redo scheme (sun97generic, page 9)
          //
          // Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
          //  1. Undo operations in HB from right to left until
          //     an operation EOm is found such that EOm => Onew .
          //  2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
          //  3. Transform each operation EOm+i in HB[m+1,n] into
          //     the new execution form EO'm+i as follows:
          //  - EO'm+1 := IT (EOm+1, EOnew ).
          //  - For 2 <= i <= (n - m),
          //      (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
          //      (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
          //  Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
          //
          //  After the execution of the above steps, the contents of
          //  the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
          //  ---
          //  This function manage the History Buffer and update the State Vector Table.


            assert(   T(o_new) == OperationType.Insert
                   || T(o_new) == OperationType.Delete,
                   "Invalid operation request.");

            log(1, $"Site $(site_id.ToString().Substring(0,8));$(HashToString(state_vector)); '$(text_buffer.get_text())'; applying $(o_new)");
    
            // 1.
            mutable m = -1; // manage the case HB == [] // (was  m = 0 in python)
            def undoed = ArrayList() :Chalks.ArrayList[Operation];
              
            {
                def enumerator = range(len(HB), 0).GetEnumerator(); enumerator.Reset();
                mutable not_in_total_ordering = true;
                //foreach( m in range(len(HB), 0) ) {
                // from right to left
                while(enumerator.MoveNext() && not_in_total_ordering) {
                    m = enumerator.Current;
                    log(4, $"apply: m == $m"); // just for debugging
                    def EOm = HB[m];
                    //log("check_total_ordering($(EOm), $(o_new)) => $(check_total_ordering(EOm, o_new))"); // just for debugging
                    
                    if (! check_total_ordering(EOm, o_new)) {
                        undo(EOm);
                        // operations do should not be erased from HB,
                        // because they will later be transformed !
                        undoed.Add(EOm);
                    }
                    else {
                        not_in_total_ordering = false; // break;
                    }
                } 
            }
              
            when ( (len(HB) != 0)  && (len(undoed) == len(HB)) ) {
                log(2, "No previous op found !");
                m = -1; // to indicate that no previous op was found
            }
              
            
            // 2.
            def eo_new = GOT( o_new, HB.Slice(':', m+1)); // pass o_new and HB = [EO1, EO2, ..., EOm ]
            execute(eo_new);
            // eo_new will be inserted after step 3 to follow better the paper notation.
            log(2, "m $(m); [EO1, ..., EOm ] $(HB.Slice(':',m+1)); HB.Slice(m+1,':') $(HB.Slice(m+1,':'))");
    
        
            // 3.
            when (len(undoed) > 0) { // if there was an undo, then redo
                
                log(1, // just for debugging
                    $"Site $(site_id.ToString().Substring(0,8)); '$(text_buffer.get_text())'; undoed $(undoed); executed $(eo_new);");
                
                def EOoL = ArrayList() :ArrayList[Operation]; // EO'm+1 List
    
                EOoL.Add( IT( HB[m+1], eo_new ) );
                
                foreach (i in range(1, len(undoed))) {
                    // C# indexes start from 'zero' (in the paper they start from 'one')

                    // paper [m+1,m+i - 1] -> c# [m+1:m+i +1]
                    def TO = LET( HB[m+1+i], reversed(HB.Slice(m+1, m+i +1)));

                    def t_list = ArrayList() :ArrayList[Operation];
                    t_list.Add(eo_new);  t_list.Append(EOoL);  //[eo_new] + EOoL
                    EOoL.Add( LIT( TO, t_list) );
                }
                
                //log(1, "m: $(m); len(EOoL) ($EOoL.Length);EOoL $(EOoL)"); // just for debugging
                
                foreach ( i in range(len(EOoL)) ) {			
                    def t_op = EOoL[i];
                    execute(t_op);
                    HB[m+1+i] = t_op; // c# indexes start from 'zero'
                }
            } // end of 'when(undoed)'
    
            // After the execution of the above steps [...]
            // HB = [EO1,..., EOm, eo_new, EO'm+1,..., EO'n ].
            HB.Insert(m + 1, eo_new); // insert into the HB, just after EOm
            
            
            // Update local State vector
            def t_site_id = o_new.SourceSite;
            
            assert(state_vector.ContainsKey(t_site_id),
                   "Received an operation from a source_site not listed in the state_vector");
            state_vector[t_site_id] += 1;
        
            // Update the State Vector Table (via a copy)
            // (it store what we know about the status of each site, including ourself)
            state_vector_table[eo_new.SourceSite] = eo_new.TimeStamp.Clone();
            
            // call the garbage collector (over a dummy periodic condition)
            when ((len(HB) % 10) == 0) {
                _ = collect_garbage(); // returns the garbage
            }
                                
            ;
        }

        
        execute(eo :Operation, splitted_part :bool) :void
        { // Modify the text buffer.
          // The lost information is stored into the operators for future undos.

            // local operations already where executed before being executed
            if (! eo.executed_before_creation ) { 
            
                log(4, $"Executing $eo");
                if (eo.is_splitted) {
                    execute(eo.splitted_head, true); //splitted_part = true
                    execute(eo.splitted_tail, true); //splitted_part = true
                }
                else {
                    match (T(eo)) {
                        | OperationType.Insert =>
                          text_buffer.insert_text(eo.SourceSite, P(eo), S(eo));
                          
                        | OperationType.Delete =>
                          // stores the erased text for future undos
                          eo.deleted_text = text_buffer.delete_text(P(eo), L(eo));
                          
                        | _ => throw Exception("Tried to execute an unmanaged operation type $(eo)");
                    }
                }
            }
            else {
                eo.executed_before_creation = false;
            }
            ;
        }
        
        execute(eo :Operation) :void
        {
            execute(eo, false); // if omited, it is not a splitted_part operation
        }

        //redo(op :Operation) :void
        //{ // an alias // never used
        //    execute(op); 
        //}


        undo(EO :Operation) :void
        { // Undo an operation. Transform the text to his previous state.
          // The undo operation supose that EO is the last operation executed over the buffer.


            when(EO.relatively_addressed) {
                throw Exception(
                      "Undo of a relatively addressed operation is not managed/implemented");
            }
            
            if (EO.is_splitted) {
                undo(EO.splitted_head);
                undo(EO.splitted_tail);
            }
            else {

                match(T(EO)) {
                  | OperationType.Delete =>
                      assert( EO.deleted_text != null,
                               "Undoable operation (no undo info stored)"
                             + $"(deleted_text == $(EO.deleted_text))");
                      // create the undo operation and execute it
                      execute( Operation(OperationType.Insert, P(EO), EO.deleted_text) );
                      
                  | OperationType.Insert =>
                      // create the undo operation and execute it
                      execute( Operation(OperationType.Delete, P(EO), S(EO).Length ) ); 
                      
                  | _ =>
                      throw Exception("Trying to undo an Unmanaged Operation.");
                }
            }
            ;
        }
        
        public collect_garbage() :ArrayList[Operation] // public for tests
        { //
          // Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
          // Scan HB from left to right. Let EO be the current operation under inspection.
          // Suppose that EO was generated at site i and timestamped by SVEO.
          //  (1) If SVEO [i] <= MSVk[i], then EO is removed from HB and continue scanning.
          //  (2) Otherwise stop scanning and return.
          //  
          // (The garbage collection procedure can be invoked periodically, or
          // after processing each remote operation/message, or
          // when the number of buffered operations in HB goes beyond a preset threshold value.)
    
                    
            // reference asignations (local aliases)
            
            def SVT = state_vector_table;
            def MSV = minimum_state_vector;
    
        
            log(1, $"Site $(site_id.ToString().Substring(0,8)); before garbage collector; HB $(HB)");
            //"%s" % map(lambda x: "{from S%i%s}"%(x["source_site"], x["timestamp"]) , HB)));
        
            // compute the MSV
            foreach( site_id in MSV.Keys ) {
                //MSV[i] = min( [ sv[i] for sv in SVT ] ) ;

                def f(_k:Guid, v:Hashtable[Guid, int], b:int) {
                    System.Math.Min(v[site_id], b)
                }
                
                MSV[site_id] =  SVT.Fold(0, f);
            }
        

            log(1, $"Site $(site_id.ToString().Substring(0,8)); garbage collector; MSV $((MSV)); SVT $((SVT));");
            //log(1, $"Site $(site_id.ToString().Substring(0,8)); garbage collector; MSV "+ HashToString(MSV) + "; SVT " + HashToString(SVT) + ";");
            
            // collect the garbage
            def deleted_operations_list = ArrayList() :ArrayList[Operation];

            // iterate over a copy of HB (to be able to mutate HB while iterating over it)
            {
                def enumerator = HB.Clone().GetEnumerator(); enumerator.Reset();
                mutable condition = true;
                while(enumerator.MoveNext() && condition) {

                    def EO = enumerator.Current;
                    def i    = EO.SourceSite;
                    def SVEO = EO.TimeStamp;
                
                
                    log(1,   $"Site $(site_id.ToString().Substring(0,8)); garbage collector; EO $(EO);"
                           + $"i $(i); $(SVEO[i])<=? $(MSV[i])" );
            
                    condition = SVEO[i] <= MSV[i];
                    
                    when ( condition ) {
                        deleted_operations_list.Add(EO);
                        HB.Remove(EO);
                        
                        log(1, $"Site $(site_id.ToString().Substring(0,8)); garbage collector; removing $(EO)");
                    }
                    //if condition == false, stop scanning HB
                } 
            }
            
            log(1, $"Site $(site_id.ToString().Substring(0,8)); after garbage collector; HB $(HB)");
            //"%s"% map(lambda x: "{from S%i%s}"%(x["source_site"], x["timestamp"]) , HB)
            
            deleted_operations_list;
        }

        public update_SVT( site_id:Guid, state_vector :Hashtable[Guid, int]) :void 
        { // public for tests
          // update_StateVectorTable
          //
          // sun98achievings.pdf, page 19 paragraph 2.
          // If one site happens to be silent for an unusually long period of time,
          // other sites will not know what its state is [a 'mostly observer' site].
          // Therefore, it is required for a site to broadcast a short state message
          // containing its state vector when it has not generated an operation for a
          // certain period of time and/or after executing a certain number of remote
          // operations. Upon receiving a state message from a remote site r, site k
          // simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
          // ---
          // Can update the SVT sending dummy Insert(0, "") operations
            
            state_vector_table[site_id] = state_vector;
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Internal GOT algorithm functions
        
        is_causally_ready(op :Operation) :bool
        { // Definition 5: Conditions for executing remote operations
          //  
          // Let O be an operation generated at site s and timestamped by SVo .
          // O is causally-ready for execution at site d (d != s) with a state vector SVd
          // only if the following conditions are satisfied:
          // 1. SVo [s] = SVd [s] + 1, and
          // 2. SVo [i] <= SVd [i], for all i in {0,1, ..., N - 1} and i != s.


            def SVd = this.state_vector;
            def SVo = op.TimeStamp;
            def op_site = op.SourceSite;

            
            foreach (site_id in SVd.Keys) {
                assert( SVo.Contains(site_id),
                         "State vectors are not comparable, keys does not match "
                       + $"SVd.Keys $(SVd.Keys) versus SVo.Keys $(SVo.Keys)" );
            }
            assert( op_site != Guid.Empty, $"The operation $op has no source site");

            // 1.
            def condition1 = ( SVo[op_site] == SVd[op_site] + 1 );

            // 2.
            mutable condition2 = true;
            foreach( site_id in SVd.Keys ) {
                when( site_id != op_site ) {
                    condition2 = condition2 && (SVo[site_id] <= SVd[site_id]); }
            }

            condition1 && condition2; // return value
        }

        check_total_ordering( Oa :Operation, Ob :Operation) :bool
        { // Check if Oa => Ob.
          // Definition 6: Total ordering relation "=>"
          // Given two operations Oa and Ob, generated at sites i and j and
          // timestamped by SVOa and SVOb, respectively, then Oa => O b, iff:
          //   1. sum(SVOa) < sum(SVOb), or
          //   2. i < j when sum(SVOa) = sum(SVOb),
          // where sum(SV) = $\sum_{i=0}^{N-1} SV[i]$.	
            
            #region local helper functions
            def sum( t_list :Hashtable[Guid, int]) :int
            { // sum = lambda t_list: reduce(lambda x,y: x+y, t_list)

                def f(_k:Guid, v:int, b:int) {
                    v + b;
                }
                
                t_list.Fold(0, f);
            }

            def is_minor = Chalks.Helpers.is_minor;            
            #endregion
            
            def SVOa = Oa.TimeStamp;
            def SVOb = Ob.TimeStamp;
    
            assert( (len(SVOa) != 0) && (len(SVOb) != 0),
                   $"can not check operations without timestamp. (Oa:$(Oa); Ob:$(Ob))");

            assert( len(SVOa) == len(SVOb),
                     "can not check operations with timestamp of different length"
                   + $"(with different keys) (Oa:$(Oa); Ob:$(Ob))");
    
            // 1.
            def condition1 = sum(SVOa) < sum(SVOb);
    
            //2.
            def i = Oa.SourceSite;
            def j = Ob.SourceSite;
            
            def condition2 =  (sum(SVOa) == sum(SVOb)) && is_minor(i, j); // ... and (i < j)
        
            condition1 || condition2;
        }

        // Definition 1: Causal ordering relation "->"
        // 
        // Given two operations Oa and Ob , generated at sites i and j, then Oa -> Ob , 
        // iff:
        //     1. i = j and the generation of Oa happened before the generation of Ob , 
        // or
        //     2. i != j and the execution of Oa at site j happened before the 
        // generation of Ob , or
        //     3. there exists an operation Ox, such that Oa -> Ox and Ox -> Ob.
        // 
        // Definition 2: Dependent and independent operations
        // 
        // Given any two operations Oa and Ob.
        //     1. Ob is said to be dependent on Oa iff Oa -> Ob.
        //     2. Oa and Ob are said to be independent (or concurrent) iff neither Oa 
        // -> Ob , nor Ob -> Oa , which is expressed as Oa || Ob.
        // 
        // (nor == not or; 0,0 => 1 , 0 else)
        // 

        are_dependent(oa :Operation, ob :Operation) :bool
        { // Implement a less than strict check.
          // Will return true if (Oa->Ob) or if there is a Ox such as (Oa->Ox and Ox->Ob)
          // After reading in detail the papers I propose:
          //  Oa -> Ob iff :
          //  if i==j: return SVoa[i] < SVob[i]
          //  else:    return SVoa[i] <= SVob[i]

            def i = oa.SourceSite;
            def j = ob.SourceSite;
    
    
            if (i == j) oa.TimeStamp[i] <  ob.TimeStamp[i];
            else oa.TimeStamp[i] <= ob.TimeStamp[i];
        }

        
        are_concurrent(oa :Operation, ob :Operation) :bool        
        { // Check if both operations are independent (or concurrent)
          // return Oa->Ob nor Ob->Oa
          // (nor == not or; 0,0 => 1 , 0 else)

            //not (are_dependent(oa,ob) or are_dependent(ob,oa) );
            ! (are_dependent(oa,ob) || are_dependent(ob,oa) );
        }
        
        are_independent :Operation * Operation -> bool = are_concurrent; // just an alias

        
        GOT(Onew :Operation, HB :Chalks.ArrayList[Operation]) :Operation
        { // GOT: Generic Operation Transform
          // Algorithm 2: The GOT control scheme (sun97generic) 
          // Given a new causally-ready operation Onew , and HB = [EO1 , EO2, ..., EOm ].
          // The following steps are executed to obtain EOnew :
          //  
          //   1. Scanning the HB from left to right to find the first operation EOk such that
          // EOk || Onew (EOk and Onew are concurrent (or independent)).
          // If no such an operation EOk is found, then EOnew := Onew.
          //  
          //   2. Otherwise, search the range of HB[k+1,m] to find all operations which
          // are causally preceding Onew, and let EOL denote these operations.
          // If EOL = [ ], then EOnew := LIT (Onew , HB[k,m]).
          //
          //   3. Otherwise, suppose EOL = [EOc1, ..., EOcr ], the following steps are executed:
          //     (a) Get EOL' = [EO'c1, ..., EO'cr ] as follows:
          //       i. EO'c1 := LET (EOc1, reverse(HB[k, c1 - 1]) ):
          //       ii. For 2 <= i <= r,
          //           TO := LET (EOci , reverse(HB[k, ci - 1]) );
          //           EO'ci := LIT (TO, [EO'c1, ..., EO'ci-1]).
          //     (b) O'new := LET (Onew, reverse(EOL') ).
          //     (c) EOnew := LIT (O'new, HB[k,m]).
            
            
            mutable EOnew = Onew; // the default result
              
            foreach ( k in range(len(HB))) {
                def EOk = HB[k];
                when ( are_concurrent(EOk, Onew) )
                {
                    def EOL = HB.Slice(k+1, ':');
                    def c1 = k+1; // it is this variable necessary ?
                    
                    if ( len(EOL) == 0 )
                    {
                        EOnew = LIT(Onew, HB.Slice(k, ':'));
                    }
                    else
                    {
                        // (a) i.
                        def r = len(EOL); 

                        // ArrayList(r) fix the capacity of the list to r elements
                        def EOLl = ArrayList(r) :ArrayList[Operation]; // EOLl <=> EOL'

                        // just for debugging
                        log(1,
                            $"GOT (a) i.; r $(r); (k,c1 - 1) $((k,c1 - 1)); len(HB) $(len(HB))");
                        
                        EOLl.Add( /*EOLl[0] =*/
                                 LET(EOL[0], reversed(HB.Slice(k,c1 - 1 +1))) );
                        // +1 because in paper notation ranges are incluse, incluse ('[]');
                        // while in python  they are incluse, exclusive ('[)')
                        // (this behaviour is copied in this pythonic nemerle code)
                        
                        // (a) ii.
                        foreach (i in range(1, r))
                        {
                            def TO = LET(EOL[i], reversed(HB.Slice(k, c1 + i - 1 + 1)));
                            EOLl.Add( /*EOLl[i] =*/
                                     LIT(TO, EOLl.Slice(1,i-1+1)) );
                        }
                
                        // (b)
                        def Oonew = LET(Onew, reversed(EOLl));
                        
                        // (c)
                        EOnew = LIT(Oonew, HB.Slice(k,':'));
                    }
                }
            }
            
            EOnew;
        }


        LIT(o :Operation, ol :Chalks.ArrayList[Operation]) :Operation
        { // Inclusion transform over a list
            
            if (ol.Count == 0) {
                o;
            }
            else {
                LIT( IT(o, ol[0]),
                     ol.Slice(1, ':') // ol[1:]
                     );
            }
        }
        
        LET(o :Operation, ol :Chalks.ArrayList[Operation]) :Operation
        { // Exclusion transform over a list

            if (ol.Count == 0) {
                o;
            }
            else {
                LET( ET(o, ol[0]),
                     ol.Slice(1, ':') // ol[1:]
                     );
            }
        }


        IT(Oa :Operation, Ob :Operation) :Operation
        { // Inclusion Transform.
          // Return a transformed Oa, named Ooa, such that the impact of
          // the independent operation Ob (against Oa) is efectively included into Oa.
          // Also define the timestamp of the virtual operation.
 
            def Ooa =
            if ( Check_RA(Oa) ) {
                //just for debugging
                log(2, $"Check_BO(\n\t$(Oa), \n\t$(Ob) \n)\t\t=> $(Check_BO(Oa, Ob))");
                
                if ( Check_BO(Oa, Ob) ) {
                    Convert_AA(Oa, Ob) }
                else {
                    Oa } }
            else
            match((T(Oa), T(Ob))) {
              | (OperationType.Insert, OperationType.Insert) => IT_II(Oa, Ob)
              | (OperationType.Insert, OperationType.Delete) => IT_ID(Oa, Ob)
              | (OperationType.Delete, OperationType.Insert) => IT_DI(Oa, Ob)
              | (OperationType.Delete, OperationType.Delete) => IT_DD(Oa, Ob)
              | _ => IT_DD(Oa, Ob)                  
            }; // end of 'def Ooa = ... ;'
            
            
            Ooa.SourceSite = Oa.SourceSite;
            Ooa.TimeStamp  = Oa.TimeStamp.Clone(); //copy
    
   	    log(2, $"IT(\n\t$(Oa), \n\t$(Ob)\n)\t\t=> $(Ooa);"); // just for debugging
        
            Ooa;
        }

        
        IT_II(Oa :Operation, Ob :Operation) :Operation
        {
            log(1, "ping");
            if ( P (Oa) < P (Ob) ) Oa
            else Operation( OperationType.Insert, P(Oa) + L(Ob), S(Oa))
        }

        IT_ID(Oa :Operation, Ob :Operation) :Operation        
        {
            mutable Ooa = null :Operation;
            
            if (P(Oa) <= P(Ob)) {
                Ooa = Oa }
            else if ( P(Oa) > (P(Ob) + L(Ob)) ) {
                Ooa = Operation( OperationType.Insert, P(Oa) - L(Ob), S(Oa) ) }
            else {
                Ooa = Operation( OperationType.Insert, P(Ob), S(Oa) );
                Save_LI(Ooa, Oa, Ob );
            }
        
            Ooa;
        }

        IT_DI(Oa :Operation, Ob :Operation) :Operation        
        {
            if ( P(Ob) >= (P(Oa) + L(Oa)) )
                 Oa;
            else if ( P(Oa) >= P(Ob) )
                 Operation( OperationType.Delete, P(Oa) + L(Ob), L(Oa) );
            else Splitted( Operation( OperationType.Delete, 
                                      P(Oa), P(Ob) - P(Oa) ),
                           Operation( OperationType.Delete,
                                      P(Ob) + L(Ob), L(Oa) - (P(Ob) - P(Oa))) );          
        }

        IT_DD(Oa :Operation, Ob :Operation) :Operation        
        {
            mutable Ooa = null :Operation;
            
            if (P (Ob) >= (P(Oa) + L(Oa))) {
                Ooa = Oa; }
            else if (P(Oa) >= (P(Ob) + L(Ob))) {
                Ooa = Operation( OperationType.Delete, P(Oa) - L(Ob), L(Oa)); }
            else {
                if ( (P(Ob) >= P(Oa)) && ((P(Oa) + L(Oa)) <= (P(Ob) + L(Ob))) ) {
                    Ooa = Operation( OperationType.Delete, P(Oa), 0 )
                }
                else if ( (P(Ob) <= P(Oa)) && ((P(Oa) + L(Oa)) > (P(Ob) + L(Ob))) ) {
                    Ooa = Operation( OperationType.Delete,
                                     P(Ob), P(Oa) + L(Oa) - (P(Ob)+ L(Ob)) )
                }
                else if ( (P(Ob) > P(Oa)) && ((P(Ob) + L(Ob)) >= (P(Oa) + L(Oa))) ) {
                    Ooa = Operation( OperationType.Delete, P(Oa), P(Ob) - P (Oa) )
                }
                else {
                    Ooa = Op( OperationType.Delete, P(Oa), L(Oa) - L(Ob) )
                }
            
                Save_LI(Ooa, Oa, Ob); // this is in the first 'else' //<<< this is a guess
            }

            Ooa;
        }

        ET(Oa :Operation, Ob :Operation) :Operation
        { // Exclusion Transform.
          // Transform Oa against its causally preceding operation Ob to
          // produce Ooa in such a way that Ob's impact on Oa is excluded.
          // Also define the timestamp of the virtual operation.

            def Ooa =
            if (Check_RA(Oa)) Oa 
            else
            match((T(Oa), T(Ob))) {
              | (OperationType.Insert, OperationType.Insert) => ET_II(Oa, Ob)
              | (OperationType.Insert, OperationType.Delete) => ET_ID(Oa, Ob)
              | (OperationType.Delete, OperationType.Insert) => ET_DI(Oa, Ob)
              | (OperationType.Delete, OperationType.Delete) => ET_DD(Oa, Ob)
              | _ => IT_DD(Oa, Ob)                  
            }; // end of 'def Ooa = ... ;'
            
            
            Ooa.SourceSite = Oa.SourceSite;
            Ooa.TimeStamp  = Oa.TimeStamp.Clone(); //copy
    
   	    log(2, $"ET(\n\t$(Oa), \n\t$(Ob)\n)\t\t=> $(Ooa);"); // just for debugging
        
            Ooa;
        }

        ET_II(Oa :Operation, Ob :Operation) :Operation
        {
            if ( P(Oa) <= P(Ob) ) {
                Oa;
            }
            else if ( P(Oa) >= (P(Ob) + L(Ob)) ) {
                Operation( OperationType.Insert, P(Oa) - L(Ob),  S(Oa));
            }
            else {
                def Ooa = Operation( OperationType.Insert, P(Oa) - P(Ob), S(Oa) );
                Save_RA(Ooa, Ob);
                Ooa;
            }
        }

        ET_ID(Oa :Operation, Ob :Operation) :Operation        
        {
            if (Check_LI(Oa, Ob)) Recover_LI(Oa)
            else if (P(Oa) <= P(Ob)) Oa
            else Operation( OperationType.Insert, P(Oa) + L(Ob), S(Oa) )
        }

        ET_DI(Oa :Operation, Ob :Operation) :Operation 
        {
            mutable Ooa = null :Operation;
            
            if ((P(Oa) + L(Oa)) <= P(Ob)) {
                Ooa = Oa;
            }
            else if (P(Oa) >= (P(Ob) + L(Ob))) {
                Ooa = Operation( OperationType.Delete, P(Oa) - L(Ob), L(Oa))
            }
            else {
                if ((P(Ob) <= P(Oa)) && ((P(Oa) + L(Oa))  <= (P(Ob) + L(Ob)))) {
                    Ooa = Operation( OperationType.Delete, P(Oa) - P(Ob), L(Oa))
                }
                else if ((P(Ob) <= P(Oa)) && (((P(Oa) + L(Oa)) > (P(Ob) + L(Ob))))) {
                    Ooa =
                    Splitted ( Operation( OperationType.Delete,
                                          (P(Oa) - P(Ob)), P(Ob) + L(Ob) - P(Oa) ),
                              Operation( OperationType.Delete,
                                         P(Ob), (P(Oa) + L(Oa))-(P(Ob) + L(Ob)) ) )
                }
                else if ((P(Oa) < P(Ob) && (((P(Ob) + L(Ob)) <= (P(Oa) + L(Oa))))) ) {
                    Ooa =
                    Splitted( Operation( OperationType.Delete, 0,     L(Ob)         ), 
                              Operation( OperationType.Delete, P(Oa), L(Oa) - L(Ob) ) )
                }
                else {
                    Ooa =
                    Splitted( Operation( OperationType.Delete, 0, P(Oa) + L(Oa) - P(Ob) ), 
                              Operation( OperationType.Delete, P(Oa), P(Ob) - P(Oa)     ) )
                }
                
                Save_RA(Ooa, Ob); // this is in the first 'else' //<<< this is a guess
            }
            Ooa;
        }
        
        ET_DD(Oa :Operation, Ob :Operation) :Operation        
        {
            if (Check_LI(Oa, Ob)) Recover_LI(Oa)
            else if (P(Ob) >= (P(Oa) + L(Oa))) Oa
            else if (P(Oa) >= P(Ob)) Operation( OperationType.Delete, P(Oa) + L(Ob), L(Oa))
            else Splitted( Operation( OperationType.Delete,
                                      P(Oa), P(Ob) - P(Oa)                  ),
                           Operation( OperationType.Delete,
                                      P(Ob) + L(Ob), L(Oa) -(P(Ob) - P(Oa)) ) )
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
        
        #region Helper method to keep a clear syntax

        // Syntax shortcuts
        T(o :Operation) :OperationType
        { // Return the type of operation ("Insert" or "Delete")
           o.Type;
        }

        P(o :Operation) :int        
        {// Return the position where the operation is executed.
            o.Pos;
        }

        L(o :Operation) :int
        { // Return length of the deletion operation.
          // For safness if the operation is no a deletion it return the length of the inserted text. (stricly it should raise an error...)

            match(o.Type)
            {
              | OperationType.Delete => o.Length;
              | OperationType.Insert => o.Text.Length;
              | _ => throw Exception("L(o) invalid for $(o.ToString())");
            }
        }

        S(o :Operation) :string
        { // Return the string that the insert operation is trying to insert.
            assert(o.Type == OperationType.Insert,
                   "S(o) is only valid for Insertion operation.");
            o.Text;
        }

        
        reversed( in_list :Chalks.ArrayList[Operation]) :Chalks.ArrayList[Operation]
        { //Helper function used to have a compact notation

            def out_list = in_list.Clone(); //create a copy
            out_list.Reverse(); //in place operator
            out_list;
        }

        
        Splitted(o1 :Operation, o2 :Operation) :Operation
        { // Return an operation that is splitted.
          // (this should used in function 'execute' and 'undo')

            assert (T(o1) == T(o2),
                    "Splitted operations are of different types, this is not sane.");
            
            assert( ! (o1.is_splitted || o2.is_splitted),
                   "Recursive splitted operation not yet supported" );
            
            assert(T(o1) == OperationType.Delete,
                   "Splitted(o1,o2) is not implemented for operations of type $(T(o1).ToString())");
            mutable oo_pos = 0;
            mutable oo_length = 0;
            
            match(())
            {
              | _ when P(o1) < P(o2) =>
                  oo_pos =  P(o1);
                  oo_length =  ( P(o2) + L(o2) ) - P(o1);

              | _ when P(o1) > P(o2) =>
                  oo_pos = P(o2);
                  oo_length = ( P(o1) + L(o1) ) - P(o2);
                  
              | _ =>
                  throw
                  Exception("Weird split P(O1) == P(O2) ($(o1.ToString()), $(o2.ToString())");                }

            def oo = Operation(T(o1), oo_pos, oo_length);
            oo.is_splitted = true;
            oo.splitted_head = o1;
            oo.splitted_tail = o2;

            oo;
        }

        // Lost information
        Check_LI(Oa :Operation, Ob :Operation) :bool
        { // Ob was involved in a information lossing operation that afected Oa ?

            //Oa.LI_base_op == Ob;
            Oa.LI_base_op.Equals( Ob );
        }

        Save_LI(Oaa :Operation, Oa :Operation, Ob :Operation) :void        
        { // Store in Oaa the information related to
          // the paremeters of Oa and the reference to Ob.
          // One operation can only store one and only one information lose.
            
            def copy_Oa = match(Oa.Type){

              | OperationType.Insert =>
                  Operation(Oa.Type, Oa.Pos, Oa.Text )

              | OperationType.Delete =>
                  Operation(Oa.Type, Oa.Pos, Oa.Length )
                  
              | _ =>
                  throw Exception("Unmanaged operation type at Save_LI")
            };
    
            Oaa.lost_information = copy_Oa;
            Oaa.LI_base_op       = Ob;            
            ;
        }

        Recover_LI(Oa :Operation) :Operation
        { // >>>>>>DID NOT FOUND SPECIFICATION (this could cause horrible errors)<<<<<<
            
            Oa.lost_information;
        }

        // Relative adresses
        Check_RA(oa :Operation) :bool    
        { // Is Oa relatively addressed ?
                
            oa.relatively_addressed == true;
        }

        Save_RA(oa :Operation, ob :Operation) :void
        { // Stores the information to mark Oa as having a relative address to over Ob.
            
            log(2, $"called Save_RA($oa, $ob)"); // just for debugging
            
            oa.relatively_addressed = true;
            oa.base_operation = ob;
            oa.delta_pos = P(oa) - P(ob); // Abis = P(Obbis) + A.delta_pos
            ;
        }

        
        Check_BO(oa :Operation, ob :Operation) :bool        
        { // Ob is the base operation of Oa ? (in the relative address context)

            //log(4, $"Check_BO: ($(ob)).Equals( $(oa.base_operation) ) == $(ob.Equals( oa.base_operation ))"); // just for debugging
            // look at the definition of Equals in the Operation class
            ob.Equals( oa.base_operation );
        }

        Convert_AA(oa :Operation, ob :Operation) :Operation
        { // Obtain Oaa, which is an absolute address operation based on Oa,
          // over the relative position of Ob.
            
            assert( Check_BO(oa,ob), "Convert_AA: Ob is not the base_operation of Oa" );
            log(4, $"called Convert_AA($oa, $ob)"); // just for debugging
            
            match(T(oa)) {
                | OperationType.Insert =>
                  Operation( oa.Type,	oa.delta_pos + ob.Pos, oa.Text );

                | OperationType.Delete =>
                  Operation( oa.Type,	oa.delta_pos + ob.Pos, oa.Length );
                  
                | _ => throw Exception( $"Convert_AA, unmanaged operation type $(oa.Type)");
            }
        }

        #endregion

        // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
          
    } // end of class ConcurrentEditable

      
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
      
    #region Definition of the Operation class
    
    public enum OperationType { |Insert |Delete |SetText };

    type Op = Operation;
    type op = Operation;
    
    [Serializable]
    public class Operation
    {

        // Definitions of members
        public Type :OperationType;
        public mutable Pos  :int;
        public mutable Text :string;
        public mutable Length :int;
        public mutable SourceSite :Guid;
        public mutable TimeStamp :Hashtable[Guid, int];

        // non trivial cases members
        public mutable deleted_text :string; // deletions
  
        public mutable is_splitted :bool; // splits
        public mutable splitted_head :Operation;
        public mutable splitted_tail :Operation;

        public mutable relatively_addressed :bool; // relative addresses
        public mutable base_operation :Operation;
        public mutable delta_pos :int;

        public mutable lost_information :Operation; // lost information
        public mutable LI_base_op :Operation;

        // gui logic variable
        public mutable executed_before_creation :bool = false;
        
        
        // Constructors
        public this(optype :OperationType, pos :int, text :string)
        {
            this( optype, pos, text, Guid.Empty, Hashtable() );
        }
        
        public this(optype :OperationType, pos :int, text :string,
                    source_site :Guid, time_stamp :Hashtable[Guid, int])
        {
            assert(optype == OperationType.Insert);
            Type = optype;
            Pos = pos;
            Text = text;
            Length = 0;

            SourceSite = source_site;
            TimeStamp = time_stamp.Clone();
            ;
        }

        
        public this(optype :OperationType, pos :int, length :int)
        {
            this( optype, pos, length, Guid.Empty, Hashtable() );
        }
        
        public this(optype :OperationType, pos :int, length :int,
                    source_site :Guid, time_stamp :Hashtable[Guid, int])
        {
            assert(optype == OperationType.Delete);
            Type = optype;
            Pos = pos;
            Length = length;
            Text = "";

            SourceSite = source_site;
            TimeStamp = time_stamp.Clone();
            ;
        }


        public this(optype :OperationType, text :string)
        {
            this(optype, text, Guid.Empty, Hashtable() );
        }

        public this(optype :OperationType, text :string,
                    source_site :Guid, time_stamp :Hashtable[Guid, int])
        {
            assert(optype == OperationType.SetText);
            Type = optype;
            Pos = 0;
            Length = 0;
            Text = text;

            SourceSite = source_site;
            TimeStamp = time_stamp.Clone();
            ;
        }

        // Methods
        public Equals( Oa :Operation, Ob :Operation) :bool
        { // The papers do not explain how to manage the TimeStamp of the operations
          // during transforms and do not explain which operations are considered
          // to be equivalents.
          // Studying in detail the sequence of transformations that the example generate:
          // LIT(ET(O4, ET(EO2, EO1)), [EO1, EO2])
          //  I deduce that the first approach of using Operations class instances is wrong.
          // Doing that Transformation mutate the operators passed is wrong too.
          // If during transform the timestamp are preserved then timestamp and source_site are
          // the unique identifiers of a operation.
          // Then IT(EO, EOx) == ET(EO, EOx) == EO; this is not intuitive but it works.
          //  ----
          //  x==y calls x.__eq__(y)
        
            //assert isinstance(other, Operation), "Only operations instances can be compared (was comparing %s with %s)"%(self, other)

            (Oa.SourceSite.Equals(Ob.SourceSite)) && AreEquals(Oa.TimeStamp, Ob.TimeStamp);
        }

        public Equals(op :Operation) :bool
        {
            // same place, same moment
            //log(0, $"op.Equals: $(SourceSite).Equals($(op.SourceSite)) ==  $(SourceSite.Equals(op.SourceSite))");
            //log(0, $"op.Equals: $(TimeStamp).Equals($(op.TimeStamp)) ==  $(TimeStamp.Equals(op.TimeStamp))");
            
            (SourceSite.Equals(op.SourceSite)) && AreEquals(TimeStamp, op.TimeStamp); 
        }

        override public ToString() :string
        {

            def additional_information =
            if (relatively_addressed) {
                $" is_RA delta_pos $delta_pos based_op $base_operation" }
            else if (lost_information != null) {
                $" contain LI lost_information $lost_information LI_base_op $LI_base_op" }
            else { "" };
                      
            match(Type) {
              | OperationType.Insert =>
                  $"$(Type)@$(Pos):'$(Text)' from $(SourceSite.ToString().Substring(0,8)) "
                   + HashToString(TimeStamp) + additional_information;
              | OperationType.Delete =>
                  $"$(Type)@$(Pos):$Length from $(SourceSite.ToString().Substring(0,8)) "
                   + HashToString(TimeStamp) + additional_information;
              | OperationType.SetText =>
                  $"$Type $Text from $SourceSite "
                   + HashToString(TimeStamp) + additional_information;
              /*| _ =>
                  $"$Type@$(Pos):$(Length):'$(Text)' from $(SourceSite.ToString().Substring(0,8)) "
                   + HashToString(TimeStamp);*/
            }
        }

    } // end of class Operation

    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    #region Concurrent Editable node Status

    [Serializable]
    public class ConcurrentEditableNodeStatus
    { // this class is a container to initialize a new node into a running session
      // all the value are set extenarlly, as this object was a structure
        
        public mutable Text :string;
        public mutable SV :Hashtable[Guid, int];
        public mutable MSV :Hashtable[Guid, int]; 
        public mutable HB :Chalks.ArrayList[Operation];
        public mutable delayed_operations :Chalks.ArrayList[Operation];
        
        // no need to implement a constructor
    }
    
    
    #endregion
    
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    public interface ITextBuffer
    { // This interface define a recipient where the ConcurrentEdition system store the up to date version of the text.
        
        insert_text(site_id :Guid, offset:int, text:string):void;
        // Due of UTF-8 encoding character counts are referred to as "offsets", 
        // this is consistent with the GTK code
        
        delete_text(offset:int, length:int): string;
        // returns the deleted text
        
        get_text():string;
        // return all the text in the buffer
        
        set_text(text:string):void;
        // overwrite the buffer text content
    }
    

    public interface INetworkForCe
    { // this are the methods that the ConcurrentEdition layer use of the NetworkNode object
        log(_ :int, _:string) :void;
        get_site_id() :Guid;
        send_operation(comes_from :Guid, op:Operation) :void;
    }


    
} // end the namespace Chalks.ConcurrentEditable



