<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2937" clone_windows="0"/>
<globals body_outline_ratio="0.50572519084">
	<global_window_position top="10" left="10" height="986" width="1280"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="rodrigob.20040121154249" a="E"><vh>Chalks</vh>
<v t="rodrigob.20040824110326"><vh>Introduction (for Chalks newbies)</vh>
<v t="rodrigob.20040826154614"><vh>&lt;&lt;what is Chalks ?&gt;&gt;</vh></v>
<v t="rodrigob.20040826154614.1"><vh>&lt;&lt;features&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.1"><vh>&lt;&lt;release status&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.2"><vh>&lt;&lt;installation instructions&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.3"><vh>&lt;&lt;usage&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1"><vh>Old LeoN (to purge) Introduction (for LeoN newbies)</vh>
<v t="rodrigob.121403173614.57" a="E"><vh>General view of the system</vh>
<v t="rodrigob.010104211709"><vh>see image misc/leon_scheme.png</vh></v>
</v>
</v>
</v>
<v t="rodrigob.20040824110326.1"><vh>Docs</vh>
<v t="rodrigob.20040826155317" a="EM"><vh>&lt;&lt;credits&gt;&gt;</vh></v>
<v t="rodrigob.20040908003956"><vh>Latex</vh>
<v t="rodrigob.20040908003956.1" a="E"
marks="rodrigob.20040913233519,"
expanded="rodrigob.20040908172407,rodrigob.20040908010357.1,rodrigob.20040913234027,"><vh>@thin doc/design.tex</vh></v>
<v t="rodrigob.20040908004300"><vh>@read-only doc/Makefile</vh></v>
</v>
<v t="rodrigob.20040831002540"><vh>Distribution files</vh>
<v t="rodrigob.20040826154516" tnodeList="rodrigob.20040826154516,rodrigob.20040826154830,rodrigob.20040826154614,rodrigob.20040826154614.1,rodrigob.20040826154830.1,rodrigob.20040826154830.2,rodrigob.20040826154830.3,rodrigob.20040826155317"><vh>@nosentinelsfile README</vh>
<v t="rodrigob.20040826154830"><vh>&lt;&lt;legal declaration&gt;&gt;</vh></v>
<v t="rodrigob.20040826154614"><vh>&lt;&lt;what is Chalks ?&gt;&gt;</vh></v>
<v t="rodrigob.20040826154614.1"><vh>&lt;&lt;features&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.1"><vh>&lt;&lt;release status&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.2"><vh>&lt;&lt;installation instructions&gt;&gt;</vh></v>
<v t="rodrigob.20040826154830.3"><vh>&lt;&lt;usage&gt;&gt;</vh></v>
<v t="rodrigob.20040826155317" a="M"><vh>&lt;&lt;credits&gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040831001818" tnodeList="rodrigob.20040831001818,rodrigob.20040826155317"><vh>@nosentinelsfile AUTHORS</vh>
<v t="rodrigob.20040826155317" a="M"><vh>&lt;&lt;credits&gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040831002026" a="E" tnodeList="rodrigob.20040831002026"><vh>@nosentinelsfile COPYING</vh></v>
<v t="rodrigob.20040831004246"><vh>@thin ./src/setup.py</vh></v>
<v t="rodrigob.20040831002444"><vh>@thin ./src/setup.cfg</vh></v>
</v>
<v t="rodrigob.121403173614.10"><vh>logs</vh>
<v t="rodrigob.121403173614.11" a="E"><vh>LeoN release '0**0'</vh></v>
<v t="rodrigob.123103131341"><vh>LeoN release 0.1.0</vh></v>
<v t="rodrigob.20040918184418"><vh>Chalks initial logs</vh></v>
</v>
<v t="rodrigob.121403173614.9" a="E"><vh>Old LeoN (to purge) Docs</vh>
<v t="rodrigob.121403173614.4" a="E"><vh>&lt;&lt; release status &gt;&gt;</vh></v>
<v t="rodrigob.122403213028"><vh>&lt;&lt; legal declaration &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.57"><vh>General view of the system</vh>
<v t="rodrigob.010104211709"><vh>see image misc/leon_scheme.png</vh></v>
</v>
<v t="rodrigob.122403220526"><vh>users help</vh>
<v t="rodrigob.121403173614.3"><vh>&lt;&lt; what is LeoN ? &gt;&gt;</vh></v>
<v t="rodrigob.123103123958"><vh>&lt;&lt; features &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.5"><vh>&lt;&lt; installation instructions &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.6"><vh>&lt;&lt; usage &gt;&gt; (LeoN system usage)</vh>
<v t="rodrigob.123103162446"><vh>&lt;&lt; 1. how to install LeoN ?&gt;&gt;</vh></v>
<v t="rodrigob.123103162446.1"><vh>&lt;&lt; 2. how to run a server ? &gt;&gt;</vh></v>
<v t="rodrigob.123103162446.2"><vh>&lt;&lt; 3. how to connect to a server ? &gt;&gt;</vh></v>
<v t="rodrigob.123103162446.3"><vh>&lt;&lt; 4. panoramas &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.8"><vh>Chat bar usage</vh>
<v t="rodrigob.010104175231"><vh>see image misc/collaborating.png</vh></v>
</v>
<v t="rodrigob.121403173614.67"><vh>&lt;&lt; admingui help &gt;&gt; (for administrators)</vh>
<v t="rodrigob.123103123839"><vh>see image misc/admin_gui.png</vh></v>
</v>
</v>
<v t="rodrigob.122403220526.1" a="E"><vh>developers docs</vh>
<v t="niederberger.20040825214919" a="E"><vh>old (from LeoN)</vh>
<v t="niederberger.20040825221501"><vh>&lt;&lt; LeoNtest docs &gt;&gt; (about LeoN tests)</vh>
<v t="niederberger.20040825221501.1"><vh>&lt;&lt; usage &gt;&gt;</vh></v>
</v>
<v t="niederberger.20040825221453"><vh>About security and permissions</vh>
<v t="niederberger.20040825221453.1"><vh>&lt;&lt; admingui help &gt;&gt; (for administrators)</vh>
<v t="niederberger.20040825221453.2"><vh>see image misc/admin_gui.png</vh></v>
</v>
</v>
<v t="niederberger.20040825221442"><vh>Outline transfer format</vh></v>
<v t="niederberger.20040825221401" a="E"><vh>About the LeoChecker, LeoAvatar, and where is the Realm hidden</vh>
<v t="niederberger.20040825221401.1" a="E"><vh>Server login (server side login classes)</vh>
<v t="niederberger.20040825221401.2"><vh>class LeoChecker</vh></v>
<v t="niederberger.20040825221401.3"><vh>class LeoAvatar</vh></v>
<v t="niederberger.20040825221401.4"><vh>requestAvatar (CollaborativeOutline.requestAvatar)</vh></v>
<v t="niederberger.20040825221401.5" a="E"><vh>Perspectives</vh>
<v t="niederberger.20040825221401.6" a="E"><vh>class OutlinePerspective</vh>
<v t="niederberger.20040825221401.7"><vh>Own account editing</vh></v>
<v t="niederberger.20040825221401.8"><vh>Messages and presence methods</vh></v>
<v t="niederberger.20040825221401.9" a="E"><vh>Outline editing methods</vh>
<v t="niederberger.20040825221401.10"><vh>helpers functions (data&lt;-&gt;outline)</vh>
<v t="niederberger.20040825221401.11"><vh>outline_to_data</vh></v>
<v t="niederberger.20040825221401.12"><vh>data_to_outline</vh></v>
</v>
<v t="niederberger.20040825221401.13"><vh>get outline</vh></v>
<v t="niederberger.20040825221401.14"><vh>select node</vh></v>
<v t="niederberger.20040825221401.15"><vh>Edit tree (class OutlinePerspective)</vh>
<v t="niederberger.20040825221401.16"><vh>base operations</vh>
<v t="niederberger.20040825221401.17"><vh>create_node</vh></v>
<v t="niederberger.20040825221401.18"><vh>create_clone</vh></v>
<v t="niederberger.20040825221401.19"><vh>delete_node</vh></v>
<v t="niederberger.20040825221401.20"><vh>move_node</vh>
<v t="niederberger.20040825221401.21"><vh>&lt;&lt; check permissions &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.22"><vh>&lt;&lt; check locks &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.23"><vh>&lt;&lt; apply &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.24"><vh>&lt;&lt; propagate &gt;&gt;</vh></v>
</v>
</v>
<v t="niederberger.20040825221401.25"><vh>upload outline</vh></v>
<v t="niederberger.20040825221401.26"><vh>download outline</vh></v>
</v>
<v t="niederberger.20040825221401.27" a="E"><vh>Edit nodes</vh>
<v t="niederberger.20040825221401.28"><vh>lock/unlock</vh></v>
<v t="niederberger.20040825221401.29"><vh>update node</vh></v>
<v t="niederberger.20040825221401.30"><vh>collaborate in/out</vh></v>
<v t="niederberger.20040825221401.31"><vh>receive_op</vh>
<v t="niederberger.20040825221401.32"><vh>insert/delete text</vh></v>
</v>
</v>
</v>
</v>
<v t="niederberger.20040825221401.33"><vh>class AdminOutlinePerspective</vh>
<v t="niederberger.20040825221401.34"><vh>accounts</vh></v>
<v t="niederberger.20040825221401.35"><vh>permissions</vh></v>
</v>
</v>
</v>
</v>
<v t="niederberger.20040825215445" a="E"><vh>About client and server objects</vh></v>
<v t="rodrigob.121403173614.57" a="E"><vh>General view of the system</vh>
<v t="rodrigob.010104211709"><vh>see image misc/leon_scheme.png</vh></v>
</v>
</v>
<v t="niederberger.20040825221442.1"><vh>text difference transfer format</vh></v>
<v t="rodrigob.010104212717"><vh>networking requirements</vh>
<v t="rodrigob.121403173614.21"><vh>Leo over network requirements (original post)</vh>
<v t="rodrigob.121403173614.22" a="E"><vh>&lt;&lt; Step one, Merging &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.23" a="E"><vh>&lt;&lt; Step two, Publishing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.24" a="E"><vh>&lt;&lt; Step three, Interacting by turns &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.25" a="E"><vh>&lt;&lt; Step four, Realtime interaction &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.58"><vh>Code explanation</vh>
<v t="rodrigob.010104213529"><vh>&lt;&lt; notation &gt;&gt;</vh></v>
</v>
<v t="niederberger.20040906222819"><vh>General view of the system</vh></v>
<v t="rodrigob.121403173614.66" a="E"><vh>About client and server objects</vh></v>
<v t="rodrigob.121403173614.1506"><vh>ConcurrentEditable algorithm explanation</vh></v>
<v t="rodrigob.121403173614.60"><vh>About ConcurrentEditableClient and ConcurrentEditableServer</vh></v>
<v t="rodrigob.121403173614.37"><vh>Release file tree</vh></v>
</v>
<v t="rodrigob.121403173614.20" a="E"><vh>forum/mail_list posts</vh>
<v t="rodrigob.121403173614.21"><vh>Leo over network requirements (original post)</vh>
<v t="rodrigob.121403173614.22" a="E"><vh>&lt;&lt; Step one, Merging &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.23" a="E"><vh>&lt;&lt; Step two, Publishing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.24" a="E"><vh>&lt;&lt; Step three, Interacting by turns &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.25" a="E"><vh>&lt;&lt; Step four, Realtime interaction &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.26" a="E"><vh>LeoN development status</vh>
<v t="rodrigob.121403173614.27"><vh>LeoN development status</vh></v>
<v t="rodrigob.121403173614.28"><vh>LeoN development status II</vh></v>
<v t="rodrigob.121403173614.29"><vh>LeoN development status III</vh></v>
<v t="rodrigob.121403173614.30"><vh>LeoN development status IV</vh></v>
<v t="rodrigob.121403173614.31"><vh>LeoN development status V</vh></v>
<v t="rodrigob.121403173614.32"><vh>LeoN release '0**0' (zero power zero)</vh></v>
<v t="rodrigob.121403173614.1320" a="E"><vh>LeoN development status VIII</vh></v>
</v>
<v t="rodrigob.121403173614.33"><vh>LeoN hooks requirements</vh>
<v t="rodrigob.121403173614.34"><vh>leo 3.12 Start problem</vh></v>
</v>
<v t="rodrigob.122403125851"><vh>leo bugs reports</vh>
<v t="rodrigob.121403173614.13"><vh>crash_report.txt</vh></v>
<v t="rodrigob.122203065507"><vh>post file cloning double messages</vh></v>
<v t="rodrigob.122403141856"><vh>post why copy of big headline freeze ?</vh></v>
<v t="rodrigob.122403141113"><vh>post change find headline rc1 error</vh></v>
<v t="rodrigob.122403095223"><vh>post @url file:./ relative path and @path discordance</vh></v>
<v t="rodrigob.122803215625"><vh>post about strange behaviour when renaming a node with visible clone</vh></v>
<v t="rodrigob.010104213829"><vh>post distro .leo files MaJusCuLe inconsistence</vh></v>
<v t="rodrigob.123103172351"><vh>post copy do not paste in Leo Find/Change panel</vh></v>
</v>
<v t="rodrigob.122703165736"><vh>leo features request</vh>
<v t="rodrigob.122503213200"><vh>post empty toolbar</vh></v>
</v>
<v t="rodrigob.123103130342"><vh>twisted</vh>
<v t="rodrigob.123003164537"><vh>post twisted unicode failure bug</vh></v>
</v>
<v t="rodrigob.123103132025"><vh>readme versions (not a post, but)</vh>
<v t="rodrigob.121403173614.15" a="E"><vh>README-LeoN 0power0</vh>
<v t="rodrigob.121403173614.16"><vh>&lt;&lt; What is LeoN? &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.17"><vh>&lt;&lt; Status &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.18"><vh>&lt;&lt; Instalation &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.19"><vh>&lt;&lt; Usage &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.14" a="E"><vh>Design notes</vh>
<v t="rodrigob.121403173614.20" a="E"><vh>forum/mail_list posts</vh>
<v t="rodrigob.121403173614.21"><vh>Leo over network requirements (original post)</vh>
<v t="rodrigob.121403173614.22" a="E"><vh>&lt;&lt; Step one, Merging &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.23" a="E"><vh>&lt;&lt; Step two, Publishing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.24" a="E"><vh>&lt;&lt; Step three, Interacting by turns &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.25" a="E"><vh>&lt;&lt; Step four, Realtime interaction &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.26" a="E"><vh>LeoN development status</vh>
<v t="rodrigob.121403173614.27"><vh>LeoN development status</vh></v>
<v t="rodrigob.121403173614.28"><vh>LeoN development status II</vh></v>
<v t="rodrigob.121403173614.29"><vh>LeoN development status III</vh></v>
<v t="rodrigob.121403173614.30"><vh>LeoN development status IV</vh></v>
<v t="rodrigob.121403173614.31"><vh>LeoN development status V</vh></v>
<v t="rodrigob.121403173614.32"><vh>LeoN release '0**0' (zero power zero)</vh></v>
<v t="rodrigob.121403173614.1320" a="E"><vh>LeoN development status VIII</vh></v>
</v>
<v t="rodrigob.121403173614.33"><vh>LeoN hooks requirements</vh>
<v t="rodrigob.121403173614.34"><vh>leo 3.12 Start problem</vh></v>
</v>
<v t="rodrigob.122403125851"><vh>leo bugs reports</vh>
<v t="rodrigob.121403173614.13"><vh>crash_report.txt</vh></v>
<v t="rodrigob.122203065507"><vh>post file cloning double messages</vh></v>
<v t="rodrigob.122403141856"><vh>post why copy of big headline freeze ?</vh></v>
<v t="rodrigob.122403141113"><vh>post change find headline rc1 error</vh></v>
<v t="rodrigob.122403095223"><vh>post @url file:./ relative path and @path discordance</vh></v>
<v t="rodrigob.122803215625"><vh>post about strange behaviour when renaming a node with visible clone</vh></v>
<v t="rodrigob.010104213829"><vh>post distro .leo files MaJusCuLe inconsistence</vh></v>
<v t="rodrigob.123103172351"><vh>post copy do not paste in Leo Find/Change panel</vh></v>
</v>
<v t="rodrigob.122703165736"><vh>leo features request</vh>
<v t="rodrigob.122503213200"><vh>post empty toolbar</vh></v>
</v>
<v t="rodrigob.123103130342"><vh>twisted</vh>
<v t="rodrigob.123003164537"><vh>post twisted unicode failure bug</vh></v>
</v>
<v t="rodrigob.123103132025"><vh>readme versions (not a post, but)</vh>
<v t="rodrigob.121403173614.15" a="E"><vh>README-LeoN 0power0</vh>
<v t="rodrigob.121403173614.16"><vh>&lt;&lt; What is LeoN? &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.17"><vh>&lt;&lt; Status &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.18"><vh>&lt;&lt; Instalation &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.19"><vh>&lt;&lt; Usage &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.35"><vh>Future dangers</vh></v>
<v t="rodrigob.121403173614.38" a="M"><vh>About Concurrent Outline edition</vh></v>
<v t="rodrigob.123103132025.1" a="E"><vh>steps 1,2,3,4</vh>
<v t="rodrigob.121403173614.39"><vh>step one,   merging</vh>
<v t="rodrigob.121403173614.40"><vh>Links</vh></v>
</v>
<v t="rodrigob.121403173614.41"><vh>step two,   publishing</vh></v>
<v t="rodrigob.121403173614.42" a="E"><vh>step three, interacting by turns</vh>
<v t="rodrigob.121403173614.43"><vh>Twisted Evaluation</vh></v>
<v t="rodrigob.121403173614.44"><vh>Twisted LeoClient, LeoServer design</vh></v>
<v t="rodrigob.121403173614.45"><vh>About pb.Cacheable</vh></v>
<v t="rodrigob.121403173614.46"><vh>Gui integration</vh></v>
<v t="rodrigob.121403173614.47"><vh>Design description</vh></v>
<v t="rodrigob.121403173614.48"><vh>Twisted patch</vh></v>
<v t="rodrigob.121403173614.49"><vh>Leon Hooks eureka</vh></v>
<v t="rodrigob.121403173614.50"><vh>Logics distribution</vh></v>
<v t="rodrigob.121403173614.51" a="E"><vh>Popup patch</vh></v>
<v t="rodrigob.121403173614.52"><vh>endheadedit hook</vh></v>
</v>
<v t="rodrigob.121403173614.53"><vh>step four,  realtime interaction</vh>
<v t="rodrigob.121403173614.54"><vh>future features</vh></v>
<v t="rodrigob.121403173614.55"><vh>about leo editor decoupling</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.56"><vh>Cocodoc</vh></v>
</v>
<v t="rodrigob.122403220526.2"><vh>work notes</vh>
<v t="rodrigob.122903205815"><vh>LeoError</vh></v>
<v t="rodrigob.121403173614.69"><vh>Leo one char variables convention</vh></v>
<v t="rodrigob.121403173614.70"><vh>tags_ranges insertion tracing</vh></v>
<v t="rodrigob.121403173614.74"><vh>intercepting the node renaming</vh></v>
<v t="rodrigob.121403173614.72" a="M"><vh>intercepting save_outline</vh></v>
</v>
<v t="rodrigob.123103165427"><vh>GNU GPL</vh></v>
</v>
</v>
<v t="rodrigob.20040824110326.2"><vh>Reference code</vh>
<v t="niederberger.20040911012711"><vh>Web</vh>
<v t="niederberger.20040911012711.1"><vh>Pages classes</vh></v>
<v t="niederberger.20040911012711.2"><vh>Chalks model adaptator</vh></v>
</v>
<v t="rodrigob.20040119132949"><vh>class FileStack</vh>
<v t="rodrigob.20040122143140"><vh>test_FileStack</vh></v>
</v>
<v t="rodrigob.121403173614.220" a="E"><vh>Old LeoN (to purge) Reference code</vh>
<v t="rodrigob.121403173614.221" a="E"><vh>Deprecated code</vh>
<v t="rodrigob.121403173614.222" a="E"><vh>file /usr/local/leo/leo_cvs/leo/leon.py</vh>
<v t="rodrigob.121403173614.223"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.224"><vh>go</vh></v>
<v t="rodrigob.121403173614.225" a="E"><vh>leo.leoOpen</vh>
<v t="rodrigob.121403173614.226"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.227" a="E"><vh>leo.run</vh>
<v t="rodrigob.121403173614.228"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.229"><vh>profile</vh></v>
</v>
<v t="rodrigob.121403173614.230" a="E"><vh>old ConcurrentEditable.py</vh>
<v t="rodrigob.121403173614.231" a="E"><vh>&lt;&lt;docs&gt;&gt;</vh>
<v t="rodrigob.121403173614.232"><vh>About</vh></v>
<v t="rodrigob.121403173614.233"><vh>Release status</vh></v>
<v t="rodrigob.121403173614.234"><vh>Big picture</vh></v>
<v t="rodrigob.121403173614.235"><vh>Context (so what?)</vh></v>
<v t="rodrigob.121403173614.236"><vh>About Client and Server</vh></v>
</v>
<v t="rodrigob.121403173614.237" a="E"><vh>base implementation</vh>
<v t="rodrigob.121403173614.238" a="E"><vh>ConcurrentEditable</vh>
<v t="rodrigob.121403173614.239"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.240"><vh>apply</vh></v>
<v t="rodrigob.121403173614.241"><vh>execute</vh></v>
<v t="rodrigob.121403173614.242"><vh>undo</vh></v>
<v t="rodrigob.121403173614.243"><vh>collect_garbage</vh></v>
<v t="rodrigob.121403173614.244"><vh>generate operations</vh></v>
</v>
<v t="rodrigob.121403173614.245" a="E"><vh>operations relations</vh>
<v t="rodrigob.121403173614.246"><vh>causally-ready</vh></v>
<v t="rodrigob.121403173614.247"><vh>total ordering relation</vh></v>
<v t="rodrigob.121403173614.248"><vh>dependent or independent</vh></v>
</v>
<v t="rodrigob.121403173614.249"><vh>GOT</vh></v>
<v t="rodrigob.121403173614.250"><vh>Transformations</vh>
<v t="rodrigob.121403173614.251"><vh>IT</vh></v>
<v t="rodrigob.121403173614.252"><vh>ET</vh></v>
</v>
<v t="rodrigob.121403173614.253"><vh>Operations</vh>
<v t="rodrigob.121403173614.254"><vh>Splitted</vh></v>
<v t="rodrigob.121403173614.255"><vh>Lost Information</vh></v>
<v t="rodrigob.121403173614.256"><vh>Relative Address</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.257" a="E"><vh>centralized network</vh>
<v t="rodrigob.121403173614.258" a="E"><vh>ConcurrentEditableServer</vh>
<v t="rodrigob.121403173614.259" a="E"><vh>add/del clients</vh></v>
<v t="rodrigob.121403173614.260"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.261"><vh>apply</vh></v>
<v t="rodrigob.121403173614.262" a="M"><vh>convert timestamp</vh></v>
<v t="rodrigob.121403173614.263"><vh>send operation</vh></v>
<v t="rodrigob.121403173614.264"><vh>send text</vh></v>
</v>
<v t="rodrigob.121403173614.265" a="E"><vh>ConcurrentEditableClient</vh>
<v t="rodrigob.121403173614.266"><vh>generate operations</vh></v>
<v t="rodrigob.121403173614.267"><vh>set text</vh></v>
<v t="rodrigob.121403173614.268"><vh>collect_garbage</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.269" a="E"><vh>Tests</vh>
<v t="rodrigob.121403173614.270"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.121403173614.271"><vh>TestConcurrentEditable2</vh></v>
<v t="rodrigob.121403173614.272"><vh>TestConcurrentEditableServer</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.273"><vh>old2 ConcurrentEditable.py</vh>
<v t="rodrigob.121403173614.274" a="E"><vh>&lt;&lt;docs&gt;&gt;</vh>
<v t="rodrigob.121403173614.275"><vh>About</vh></v>
<v t="rodrigob.121403173614.276"><vh>Release status</vh></v>
<v t="rodrigob.121403173614.277"><vh>Big picture</vh></v>
<v t="rodrigob.121403173614.278"><vh>Context (so what?)</vh></v>
<v t="rodrigob.121403173614.279"><vh>About Client and Server</vh></v>
</v>
<v t="rodrigob.121403173614.280"><vh>base implementation</vh>
<v t="rodrigob.121403173614.281" a="E"><vh>ConcurrentEditable</vh>
<v t="rodrigob.121403173614.282"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.283"><vh>apply</vh></v>
<v t="rodrigob.121403173614.284"><vh>execute</vh></v>
<v t="rodrigob.121403173614.285"><vh>undo</vh></v>
<v t="rodrigob.121403173614.286"><vh>collect_garbage</vh></v>
<v t="rodrigob.121403173614.287"><vh>generate operations</vh></v>
</v>
<v t="rodrigob.121403173614.288" a="E"><vh>operations relations</vh>
<v t="rodrigob.121403173614.289"><vh>causally-ready</vh></v>
<v t="rodrigob.121403173614.290"><vh>total ordering relation</vh></v>
<v t="rodrigob.121403173614.291"><vh>dependent or independent</vh></v>
</v>
<v t="rodrigob.121403173614.292"><vh>GOT</vh></v>
<v t="rodrigob.121403173614.293"><vh>Transformations</vh>
<v t="rodrigob.121403173614.294"><vh>IT</vh></v>
<v t="rodrigob.121403173614.295"><vh>ET</vh></v>
</v>
<v t="rodrigob.121403173614.296"><vh>Operations</vh>
<v t="rodrigob.121403173614.297"><vh>Splitted</vh></v>
<v t="rodrigob.121403173614.298"><vh>Lost Information</vh></v>
<v t="rodrigob.121403173614.299"><vh>Relative Address</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.300" a="EM"><vh>centralized network</vh>
<v t="rodrigob.121403173614.301" a="E"><vh>ConcurrentEditableServer</vh>
<v t="rodrigob.121403173614.302" a="E"><vh>add/del clients</vh></v>
<v t="rodrigob.121403173614.303"><vh>generate operation</vh></v>
<v t="rodrigob.121403173614.304"><vh>apply</vh></v>
<v t="rodrigob.121403173614.305"><vh>base text</vh></v>
<v t="rodrigob.121403173614.306" a="E"><vh>network methods</vh>
<v t="rodrigob.121403173614.307"><vh>send operation</vh></v>
<v t="rodrigob.121403173614.308"><vh>send text</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.309" a="E"><vh>ConcurrentEditableClient</vh>
<v t="rodrigob.121403173614.310"><vh>connect to server</vh></v>
<v t="rodrigob.121403173614.311" a="E"><vh>add/del clients</vh></v>
<v t="rodrigob.121403173614.312"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.313"><vh>generate operations</vh></v>
<v t="rodrigob.121403173614.314"><vh>set text</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.315" a="E"><vh>Tests</vh>
<v t="rodrigob.121403173614.316"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.121403173614.317"><vh>TestConcurrentEditable2</vh></v>
<v t="rodrigob.121403173614.318"><vh>TestConcurrentEditableServer</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.319"><vh>oldfile ConcurrentEditable.py</vh>
<v t="rodrigob.121403173614.320" a="E"><vh>&lt;&lt;docs&gt;&gt;</vh>
<v t="rodrigob.121403173614.321"><vh>About</vh></v>
<v t="rodrigob.121403173614.322"><vh>Release status</vh></v>
<v t="rodrigob.121403173614.323"><vh>Big picture</vh></v>
<v t="rodrigob.121403173614.324"><vh>Context (so what?)</vh></v>
<v t="rodrigob.121403173614.325"><vh>About Client and Server</vh></v>
</v>
<v t="rodrigob.121403173614.326"><vh>base implementation</vh>
<v t="rodrigob.121403173614.327" a="E"><vh>ConcurrentEditable</vh>
<v t="rodrigob.121403173614.328"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.329"><vh>apply</vh></v>
<v t="rodrigob.121403173614.330"><vh>execute</vh></v>
<v t="rodrigob.121403173614.331"><vh>undo</vh></v>
<v t="rodrigob.121403173614.332"><vh>collect_garbage</vh></v>
<v t="rodrigob.121403173614.333"><vh>generate operations</vh></v>
</v>
<v t="rodrigob.121403173614.334" a="E"><vh>operations relations</vh>
<v t="rodrigob.121403173614.335"><vh>causally-ready</vh></v>
<v t="rodrigob.121403173614.336"><vh>total ordering relation</vh></v>
<v t="rodrigob.121403173614.337"><vh>dependent or independent</vh></v>
</v>
<v t="rodrigob.121403173614.338"><vh>GOT</vh></v>
<v t="rodrigob.121403173614.339"><vh>Transformations</vh>
<v t="rodrigob.121403173614.340"><vh>IT</vh></v>
<v t="rodrigob.121403173614.341"><vh>ET</vh></v>
</v>
<v t="rodrigob.121403173614.342"><vh>Operations</vh>
<v t="rodrigob.121403173614.343"><vh>Splitted</vh></v>
<v t="rodrigob.121403173614.344"><vh>Lost Information</vh></v>
<v t="rodrigob.121403173614.345"><vh>Relative Address</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.346"><vh>centralized network</vh>
<v t="rodrigob.121403173614.347"><vh>ConcurrentEditableServer</vh>
<v t="rodrigob.121403173614.348" a="E"><vh>add/del clients</vh></v>
<v t="rodrigob.121403173614.349"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.350"><vh>apply</vh></v>
<v t="rodrigob.121403173614.351"><vh>base text</vh></v>
<v t="rodrigob.121403173614.352" a="E"><vh>network methods</vh>
<v t="rodrigob.121403173614.353"><vh>send operation</vh></v>
<v t="rodrigob.121403173614.354"><vh>send text</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.355"><vh>ConcurrentEditableClient</vh>
<v t="rodrigob.121403173614.356"><vh>connect to server</vh></v>
<v t="rodrigob.121403173614.357" a="E"><vh>add/del clients</vh></v>
<v t="rodrigob.121403173614.358"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.359"><vh>generate operations</vh></v>
<v t="rodrigob.121403173614.360"><vh>set text</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.361"><vh>Tests</vh>
<v t="rodrigob.121403173614.362"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.121403173614.363"><vh>TestConcurrentEditable2</vh></v>
<v t="rodrigob.121403173614.364"><vh>TestConcurrentEditableServer</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.365" a="E"><vh>OLD NON FUNCTIONAL onBodykey2</vh></v>
<v t="rodrigob.121403173614.366" a="E"><vh>class ClientNode BEFORE INDEXING CHANGES</vh>
<v t="rodrigob.121403173614.367"><vh>connect to/disconnect from server</vh></v>
<v t="rodrigob.121403173614.368" a="EM"><vh>edit nodes</vh>
<v t="rodrigob.121403173614.369"><vh>insert_text</vh></v>
<v t="rodrigob.121403173614.370" a="M"><vh>delete_text</vh></v>
<v t="rodrigob.121403173614.371" a="E"><vh>fill_body</vh>
<v t="rodrigob.121403173614.372"><vh>&lt;&lt;def index_to_list and in_range&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.373"><vh>&lt;&lt; text was overwritten &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.374" a="M"><vh>&lt;&lt; suppression or deletion &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.375"><vh>&lt;&lt; "normal" keys &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.376"><vh>flush_body</vh></v>
<v t="rodrigob.121403173614.377"><vh>send_operation</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.378"><vh>file test_fill_body_textoverwritten.py</vh></v>
<v t="rodrigob.121403173614.379"><vh>old_cred LeoN classes</vh>
<v t="rodrigob.121403173614.380"><vh>class LeoIdentity</vh></v>
<v t="rodrigob.121403173614.381"><vh>class LeoAuthorizer</vh></v>
<v t="rodrigob.121403173614.382"><vh>class LeoService</vh></v>
</v>
<v t="rodrigob.122403134052"><vh>file delete_this_test.py (body concurrent edition)</vh>
<v t="rodrigob.122403134052.1"><vh>test</vh></v>
</v>
<v t="rodrigob.121403173614.1412"><vh>file templates/test.html</vh></v>
</v>
<v t="rodrigob.121403173614.383" a="E"><vh>old steps</vh>
<v t="rodrigob.121403173614.384" a="E"><vh>step one,   merging</vh>
<v t="rodrigob.121403173614.385" a="E"><vh>file LeoMerge.py</vh></v>
<v t="rodrigob.121403173614.386"><vh>Pyxi</vh></v>
<v t="rodrigob.121403173614.387"><vh>leoCompare.py</vh>
<v t="rodrigob.121403173614.388"><vh>choose</vh></v>
<v t="rodrigob.121403173614.389"><vh>go</vh></v>
<v t="rodrigob.121403173614.390"><vh>class leoCompare</vh>
<v t="rodrigob.121403173614.391"><vh>compare.__init__</vh></v>
<v t="rodrigob.121403173614.392"><vh>compare_directories (entry)</vh></v>
<v t="rodrigob.121403173614.393"><vh>compare_files (entry)</vh></v>
<v t="rodrigob.121403173614.394"><vh>compare_lines</vh></v>
<v t="rodrigob.121403173614.395"><vh>compare_open_files</vh>
<v t="rodrigob.121403173614.396"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.397"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.398"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.399"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.400"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.401"><vh>filecmp</vh></v>
<v t="rodrigob.121403173614.402"><vh>utils...</vh>
<v t="rodrigob.121403173614.403"><vh>doOpen</vh></v>
<v t="rodrigob.121403173614.404"><vh>dump</vh></v>
<v t="rodrigob.121403173614.405"><vh>dumpToEndOfFile</vh></v>
<v t="rodrigob.121403173614.406"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="rodrigob.121403173614.407"><vh>openOutputFile (compare)</vh></v>
<v t="rodrigob.121403173614.408"><vh>show</vh></v>
<v t="rodrigob.121403173614.409"><vh>showIvars</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.410" a="E"><vh>class leoComparePanel</vh>
<v t="rodrigob.121403173614.411"><vh>browser</vh></v>
<v t="rodrigob.121403173614.412"><vh>comparePanel.__init__</vh></v>
<v t="rodrigob.121403173614.413"><vh>finishCreate</vh></v>
<v t="rodrigob.121403173614.414" a="E"><vh>run</vh>
<v t="rodrigob.121403173614.415"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.416"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.417"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.418"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.419"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.420"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.421"><vh>show</vh></v>
<v t="rodrigob.121403173614.422"><vh>setIvarsFromWidgets</vh></v>
<v t="rodrigob.121403173614.423" a="E"><vh>Event handlers...</vh>
<v t="rodrigob.121403173614.424"><vh>onBrowse...</vh></v>
<v t="rodrigob.121403173614.425"><vh>onClose</vh></v>
<v t="rodrigob.121403173614.426"><vh>onCompare...</vh></v>
<v t="rodrigob.121403173614.427"><vh>onPrintMatchedLines</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.428" a="E"><vh>xmldiff</vh>
<v t="rodrigob.121403173614.429"><vh>xmldiff.py</vh></v>
<v t="rodrigob.121403173614.430"><vh>format.py</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.431"><vh>step two,   publishing</vh>
<v t="rodrigob.121403173614.432"><vh>Look at Woven</vh></v>
<v t="rodrigob.121403173614.433"><vh>Look at Woven, Models in depth</vh></v>
<v t="rodrigob.121403173614.434"><vh>picturepile4.py</vh>
<v t="rodrigob.121403173614.435" a="E"><vh>class IPreferences</vh></v>
<v t="rodrigob.121403173614.436" a="E"><vh>class Preferences</vh></v>
<v t="rodrigob.121403173614.437" a="E"><vh>class DirectoryListing</vh>
<v t="rodrigob.121403173614.438"><vh>initialize</vh></v>
<v t="rodrigob.121403173614.439"><vh>wmfactory_title</vh></v>
<v t="rodrigob.121403173614.440"><vh>wmfactory_directory</vh></v>
<v t="rodrigob.121403173614.441"><vh>getDynamicChild</vh></v>
<v t="rodrigob.121403173614.442"><vh>wvupdate_thumbnail</vh></v>
<v t="rodrigob.121403173614.443"><vh>wvupdate_adjuster</vh></v>
<v t="rodrigob.121403173614.444"><vh>wcfactory_adjuster</vh></v>
</v>
<v t="rodrigob.121403173614.445" a="E"><vh>class ImageSizer</vh>
<v t="rodrigob.121403173614.446"><vh>handleValid</vh></v>
</v>
<v t="rodrigob.121403173614.447" a="E"><vh>class ImageDisplay</vh>
<v t="rodrigob.121403173614.448"><vh>initialize</vh></v>
<v t="rodrigob.121403173614.449"><vh>wmfactory_image</vh></v>
<v t="rodrigob.121403173614.450"><vh>wchild_preview</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.451"><vh>step three, interacting by turns</vh>
<v t="rodrigob.121403173614.452"><vh>Cacheable examples</vh>
<v t="rodrigob.121403173614.453"><vh>cache_classes.py</vh></v>
<v t="rodrigob.121403173614.454"><vh>cache_receiver.py</vh></v>
<v t="rodrigob.121403173614.455"><vh>cache_sender.py</vh></v>
</v>
<v t="rodrigob.121403173614.456"><vh>Pb</vh>
<v t="rodrigob.121403173614.457"><vh>MultipleClientPerspective</vh></v>
<v t="rodrigob.121403173614.458"><vh>SingleClientPerspective</vh></v>
<v t="rodrigob.121403173614.459"><vh>Send referencables</vh>
<v t="rodrigob.121403173614.460"><vh>pb1client.py</vh></v>
<v t="rodrigob.121403173614.461"><vh>pb1server.py</vh></v>
</v>
<v t="rodrigob.121403173614.462"><vh>Exchange referencables</vh>
<v t="rodrigob.121403173614.463"><vh>pb3client.py</vh></v>
<v t="rodrigob.121403173614.464"><vh>pb3server.py</vh></v>
</v>
<v t="rodrigob.121403173614.465"><vh>Exceptions</vh>
<v t="rodrigob.121403173614.466"><vh>exc_client.py</vh></v>
<v t="rodrigob.121403173614.467"><vh>exc_server.py</vh></v>
</v>
<v t="rodrigob.121403173614.468"><vh>Ataching multiple clients to a perspective</vh>
<v t="rodrigob.121403173614.469"><vh>pb6client1.py</vh></v>
<v t="rodrigob.121403173614.470"><vh>pb6client2.py</vh></v>
<v t="rodrigob.121403173614.471"><vh>pb6server.py</vh></v>
</v>
<v t="rodrigob.121403173614.472"><vh>Multiple services and Authorizations</vh>
<v t="rodrigob.121403173614.473"><vh>pb7client.py</vh></v>
<v t="rodrigob.121403173614.474"><vh>pb7server.py</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.475"><vh>Go game</vh>
<v t="rodrigob.121403173614.476"><vh>go_player.py</vh></v>
<v t="rodrigob.121403173614.477"><vh>go_server.py</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.478"><vh>step four,  realtime interaction</vh>
<v t="rodrigob.121403173614.479" a="E"><vh>New Cred</vh>
<v t="rodrigob.121403173614.480"><vh>Twisted 1.0.6: New Cred</vh></v>
<v t="rodrigob.121403173614.481" a="E"><vh>webhappyrealm.py</vh>
<v t="rodrigob.121403173614.482"><vh>&lt;&lt; webhappyrealm declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.483" a="E"><vh>class MyRealm</vh>
<v t="rodrigob.121403173614.484"><vh>&lt;&lt; class MyRealm declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.485"><vh>requestAvatar</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.486"><vh>new cred</vh>
<v t="rodrigob.121403173614.487" a="E"><vh>go</vh>
<v t="rodrigob.121403173614.488" a="E"><vh>file pb-go-client.py</vh>
<v t="rodrigob.121403173614.489"><vh>&lt;&lt; pb-go-client declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.490" a="E"><vh>class RandomPlayer</vh>
<v t="rodrigob.121403173614.491"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.492"><vh>login</vh></v>
<v t="rodrigob.121403173614.493"><vh>loggedIn</vh></v>
<v t="rodrigob.121403173614.494"><vh>gotSize</vh></v>
<v t="rodrigob.121403173614.495"><vh>madeMove</vh></v>
<v t="rodrigob.121403173614.496"><vh>displayBoard</vh></v>
<v t="rodrigob.121403173614.497"><vh>quit</vh></v>
</v>
<v t="rodrigob.121403173614.498"><vh>disaster</vh></v>
<v t="rodrigob.121403173614.499"><vh>main</vh></v>
</v>
<v t="rodrigob.121403173614.500" a="E"><vh>file pb-go.py</vh>
<v t="rodrigob.121403173614.501"><vh>&lt;&lt; pb-go declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.502"><vh>class GoException</vh>
<v t="rodrigob.121403173614.503"><vh>&lt;&lt; class GoException declarations &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.504" a="E"><vh>class Board</vh>
<v t="rodrigob.121403173614.505"><vh>&lt;&lt; class Board declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.506"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.507"><vh>addPlayer</vh></v>
<v t="rodrigob.121403173614.508"><vh>getPlayer</vh></v>
<v t="rodrigob.121403173614.509"><vh>playStone</vh></v>
</v>
<v t="rodrigob.121403173614.510" a="E"><vh>class Player</vh>
<v t="rodrigob.121403173614.511"><vh>&lt;&lt; class Player declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.512"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.513"><vh>__repr__</vh></v>
<v t="rodrigob.121403173614.514"><vh>logout</vh></v>
<v t="rodrigob.121403173614.515"><vh>perspective_move</vh></v>
<v t="rodrigob.121403173614.516"><vh>perspective_getBoard</vh></v>
<v t="rodrigob.121403173614.517"><vh>perspective_getBoardSize</vh></v>
</v>
<v t="rodrigob.121403173614.518" a="E"><vh>class MyRealm</vh>
<v t="rodrigob.121403173614.519"><vh>&lt;&lt; class MyRealm declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.520"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.521"><vh>requestAvatar</vh></v>
</v>
<v t="rodrigob.121403173614.522"><vh>main</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.523"><vh>pb6</vh>
<v t="rodrigob.121403173614.524" a="E"><vh>file pb6server.py</vh>
<v t="rodrigob.121403173614.525"><vh>&lt;&lt; pb6server declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.526" a="E"><vh>class MyPerspective</vh>
<v t="rodrigob.121403173614.527"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.528"><vh>perspective_foo</vh></v>
</v>
<v t="rodrigob.121403173614.529"><vh>class MyRealm</vh>
<v t="rodrigob.121403173614.530"><vh>&lt;&lt; class MyRealm declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.531"><vh>requestAvatar</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.532" a="E"><vh>file pb6client1.py</vh>
<v t="rodrigob.121403173614.533"><vh>&lt;&lt; pb6client1 declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.534"><vh>main</vh></v>
<v t="rodrigob.121403173614.535"><vh>connected</vh></v>
</v>
<v t="rodrigob.121403173614.536" a="E"><vh>file pb6client2.py</vh>
<v t="rodrigob.121403173614.537"><vh>&lt;&lt; pb6client2 declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.538"><vh>main</vh></v>
<v t="rodrigob.121403173614.539"><vh>connected</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.540"><vh>tkDialogs</vh>
<v t="rodrigob.121403173614.541"><vh>file Tetris0_4.py</vh>
<v t="rodrigob.121403173614.542"><vh>&lt;&lt; Tetris0_4 declarations &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.543"><vh>class Jeu</vh>
<v t="rodrigob.121403173614.544"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.545"><vh>pos</vh></v>
<v t="rodrigob.121403173614.546"><vh>changer</vh></v>
<v t="rodrigob.121403173614.547"><vh>updater</vh></v>
<v t="rodrigob.121403173614.548"><vh>verif</vh></v>
</v>
<v t="rodrigob.121403173614.549"><vh>class Bloc</vh>
<v t="rodrigob.121403173614.550"><vh>verif</vh></v>
<v t="rodrigob.121403173614.551"><vh>tourner_g</vh></v>
<v t="rodrigob.121403173614.552"><vh>tourner_d</vh></v>
<v t="rodrigob.121403173614.553"><vh>updater</vh></v>
<v t="rodrigob.121403173614.554"><vh>gauche</vh></v>
<v t="rodrigob.121403173614.555"><vh>droite</vh></v>
<v t="rodrigob.121403173614.556"><vh>bas</vh></v>
</v>
<v t="rodrigob.121403173614.557"><vh>carre</vh></v>
<v t="rodrigob.121403173614.558"><vh>nouveau_bloc</vh></v>
<v t="rodrigob.121403173614.559"><vh>descendre_auto</vh></v>
<v t="rodrigob.121403173614.560"><vh>vite</vh></v>
<v t="rodrigob.121403173614.561"><vh>pauser</vh></v>
</v>
<v t="rodrigob.121403173614.562"><vh>MyDialog.py</vh></v>
<v t="rodrigob.121403173614.563"><vh>tkSimpleDialog.py</vh></v>
<v t="rodrigob.121403173614.564"><vh>class Dialog</vh></v>
</v>
<v t="rodrigob.121403173614.565"><vh>LeoPy (3.12) (very old, deprecated)</vh>
<v t="rodrigob.121403173614.566"><vh>Plugins</vh>
<v t="rodrigob.121403173614.567" a="E"><vh>Documentation and security warnings</vh>
<v t="rodrigob.121403173614.568"><vh>Intro to scripts</vh></v>
<v t="rodrigob.121403173614.569"><vh>About hooks</vh></v>
<v t="rodrigob.121403173614.570"><vh>Hooks should never blindly Python scripts</vh></v>
<v t="rodrigob.121403173614.571"><vh>NEVER use this kind of code in a hook!!</vh></v>
</v>
<v t="rodrigob.121403173614.572" a="E"><vh>Plugins</vh>
<v t="rodrigob.121403173614.573"><vh>Commands</vh>
<v t="rodrigob.121403173614.574"><vh> Importing Cisco configuration files</vh>
<v t="rodrigob.121403173614.575"><vh>@file import_cisco_config.py</vh>
<v t="rodrigob.121403173614.576"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.577"><vh>create_import_cisco_menu</vh></v>
<v t="rodrigob.121403173614.578"><vh>importCiscoConfig</vh>
<v t="rodrigob.121403173614.579"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.580"><vh>&lt;&lt; process custom line &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.581"><vh>&lt;&lt; process indented block &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.582"><vh>&lt;&lt; complete outline &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.583"><vh> Example of an imported config</vh>
<v t="rodrigob.121403173614.584"><vh>plain configuration</vh></v>
<v t="rodrigob.121403173614.585"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="rodrigob.121403173614.586"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.587"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.588"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="rodrigob.121403173614.589"><vh>controller E1 5/0/0</vh></v>
<v t="rodrigob.121403173614.590"><vh>controller E1 5/0/1</vh></v>
<v t="rodrigob.121403173614.591"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="rodrigob.121403173614.592"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="rodrigob.121403173614.593"><vh>interface Async1</vh></v>
<v t="rodrigob.121403173614.594"><vh>interface Dialer0</vh></v>
<v t="rodrigob.121403173614.595"><vh>interface FastEthernet0/0/0</vh></v>
<v t="rodrigob.121403173614.596"><vh>interface FastEthernet0/0/1</vh></v>
<v t="rodrigob.121403173614.597"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="rodrigob.121403173614.598"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="rodrigob.121403173614.599"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="rodrigob.121403173614.600"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="rodrigob.121403173614.601"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="rodrigob.121403173614.602"><vh>interface Loopback0</vh></v>
<v t="rodrigob.121403173614.603"><vh>interface POS4/1/0</vh></v>
<v t="rodrigob.121403173614.604"><vh>interface Serial5/0/0:1</vh></v>
<v t="rodrigob.121403173614.605"><vh>interface Serial5/0/0:2</vh></v>
<v t="rodrigob.121403173614.606"><vh>interface Serial5/0/1:0</vh></v>
<v t="rodrigob.121403173614.607"><vh>interface Serial5/1/0</vh></v>
<v t="rodrigob.121403173614.608"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="rodrigob.121403173614.609"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.610"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.611"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="rodrigob.121403173614.612"><vh>line aux 0</vh></v>
<v t="rodrigob.121403173614.613"><vh>line vty 0 4</vh></v>
</v>
<v t="rodrigob.121403173614.614"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.615"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="rodrigob.121403173614.616"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="rodrigob.121403173614.617"><vh>route-map only permit 2</vh></v>
<v t="rodrigob.121403173614.618"><vh>route-map only1 permit 10</vh></v>
<v t="rodrigob.121403173614.619"><vh>route-map only3 permit 10</vh></v>
<v t="rodrigob.121403173614.620"><vh>route-map tag_com permit 10</vh></v>
<v t="rodrigob.121403173614.621"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="rodrigob.121403173614.622"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="rodrigob.121403173614.623"><vh>router bgp 65001</vh></v>
<v t="rodrigob.121403173614.624"><vh>router ospf 1</vh></v>
</v>
<v t="rodrigob.121403173614.625"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.626"><vh>@file outline_export.py</vh>
<v t="rodrigob.121403173614.627"><vh>newMoreHead</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.628"><vh>Debugging</vh>
<v t="rodrigob.121403173614.629"><vh>@file dump_globals.py</vh>
<v t="rodrigob.121403173614.630"><vh>onStart</vh></v>
</v>
<v t="rodrigob.121403173614.631"><vh>@file enable_gc.py</vh>
<v t="rodrigob.121403173614.632"><vh>onStart</vh></v>
</v>
<v t="rodrigob.121403173614.633"><vh>@file trace_gc.py</vh></v>
<v t="rodrigob.121403173614.634"><vh>@file trace_keys.py</vh>
<v t="rodrigob.121403173614.635"><vh>onKey</vh></v>
</v>
<v t="rodrigob.121403173614.636"><vh>@file trace_tags.py</vh>
<v t="rodrigob.121403173614.637"><vh>trace_tags</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.638"><vh>Directives</vh>
<v t="rodrigob.121403173614.639"><vh>@file add_directives.py</vh>
<v t="rodrigob.121403173614.640"><vh>addPluginDirectives</vh></v>
<v t="rodrigob.121403173614.641"><vh>scanPluginDirectives</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.642"><vh>Drawing, graphics &amp; styled text</vh>
<v t="rodrigob.121403173614.643"><vh>@file color_markup.py</vh>
<v t="rodrigob.121403173614.644"><vh>initAnyMarkup</vh></v>
<v t="rodrigob.121403173614.645"><vh>colorWikiMarkup</vh></v>
<v t="rodrigob.121403173614.646"><vh>doWikiText</vh>
<v t="rodrigob.121403173614.647"><vh>&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.648"><vh>&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;</vh>
<v t="rodrigob.121403173614.649"><vh>&lt;&lt; parse and handle color field &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.650"><vh>insertWikiPicture</vh></v>
</v>
<v t="rodrigob.121403173614.651"><vh>@file image.py</vh>
<v t="rodrigob.121403173614.652"><vh>onSelect</vh>
<v t="rodrigob.121403173614.653"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.654"><vh>onUnselect</vh>
<v t="rodrigob.121403173614.655"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.656"><vh>@file nav_buttons.py</vh>
<v t="rodrigob.121403173614.657" a="E"><vh>class commanderInfoClass</vh>
<v t="rodrigob.121403173614.658"><vh>__init__ (commanderInfoClass)</vh></v>
<v t="rodrigob.121403173614.659" a="E"><vh>addWidgets</vh>
<v t="rodrigob.121403173614.660"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.661"><vh>createImage</vh></v>
<v t="rodrigob.121403173614.662"><vh>updateNavButtons (nav_buttons.py)</vh></v>
<v t="rodrigob.121403173614.663"><vh>Callbacks</vh>
<v t="rodrigob.121403173614.664"><vh>marksButtonCallback</vh></v>
<v t="rodrigob.121403173614.665"><vh>recentButtonCallback</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.666"><vh>class globalInfoClass</vh>
<v t="rodrigob.121403173614.667"><vh>__init__ ( globalInfoClass)</vh></v>
<v t="rodrigob.121403173614.668"><vh>addNavWidgets</vh></v>
<v t="rodrigob.121403173614.669"><vh>destroyFrame, destroyAllFrames, destroyOneFrame</vh></v>
<v t="rodrigob.121403173614.670"><vh>updateRecentSections</vh></v>
<v t="rodrigob.121403173614.671"><vh>updateMarks &amp; updateMarksAfterCommand</vh></v>
<v t="rodrigob.121403173614.672"><vh>updateNavButtons</vh></v>
</v>
<v t="rodrigob.121403173614.673"><vh>class marksDialog (listBoxDialog)</vh>
<v t="rodrigob.121403173614.674"><vh>marksDialog.__init__</vh></v>
<v t="rodrigob.121403173614.675"><vh>createFrame</vh></v>
<v t="rodrigob.121403173614.676"><vh>addbuttons</vh></v>
<v t="rodrigob.121403173614.677"><vh>fillbox</vh></v>
</v>
<v t="rodrigob.121403173614.678"><vh>class recentSectionsDialog (listBoxDialog)</vh>
<v t="rodrigob.121403173614.679"><vh>__init__  recentSectionsDialog</vh></v>
<v t="rodrigob.121403173614.680"><vh>addButtons</vh></v>
<v t="rodrigob.121403173614.681"><vh>clearAll</vh></v>
<v t="rodrigob.121403173614.682"><vh>createFrame</vh></v>
<v t="rodrigob.121403173614.683"><vh>deleteEntry</vh></v>
<v t="rodrigob.121403173614.684"><vh>destroy</vh></v>
<v t="rodrigob.121403173614.685"><vh>fillbox (recent sections)</vh>
<v t="rodrigob.121403173614.686"><vh>&lt;&lt; reconstruct the contents of self.box &gt;&gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.687"><vh>synchNavButtons</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.688"><vh>External editors &amp; Open With</vh>
<v t="rodrigob.121403173614.689"><vh>@file open_with.py</vh>
<v t="rodrigob.121403173614.690"><vh>on_idle</vh>
<v t="rodrigob.121403173614.691"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="rodrigob.121403173614.692"><vh>&lt;&lt; set s to the file text &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.693"><vh>create_open_with_menu</vh>
<v t="rodrigob.121403173614.694"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.695"><vh>@file vim.py</vh>
<v t="rodrigob.121403173614.696"><vh>open_in_vim</vh></v>
</v>
<v t="rodrigob.121403173614.697"><vh>@file xemacs.py</vh></v>
</v>
<v t="rodrigob.121403173614.698"><vh>Files</vh>
<v t="rodrigob.121403173614.699"><vh>@file empty_leo_file.py</vh>
<v t="rodrigob.121403173614.700"><vh>&lt;&lt; define minimal .leo file &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.701"><vh>onOpen</vh></v>
</v>
<v t="rodrigob.121403173614.702"><vh>@file open_shell.py</vh>
<v t="rodrigob.121403173614.703"><vh>&lt;&lt; about the open shell plugin &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.704"><vh>load_menu</vh></v>
<v t="rodrigob.121403173614.705"><vh>_getpath</vh></v>
<v t="rodrigob.121403173614.706"><vh>_getcurrentnodepath</vh></v>
<v t="rodrigob.121403173614.707"><vh>launchCmd</vh></v>
<v t="rodrigob.121403173614.708"><vh>launchExplorer</vh></v>
<v t="rodrigob.121403173614.709"><vh>launchxTerm</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.710"><vh>Foreign languages</vh>
<v t="rodrigob.121403173614.711"><vh>@file french.py</vh>
<v t="rodrigob.121403173614.712"><vh>onMenu</vh></v>
</v>
<v t="rodrigob.121403173614.713"><vh>@file french_fm.py</vh>
<v t="rodrigob.121403173614.714"><vh>onMenu</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.715"><vh>Key bindings</vh>
<v t="rodrigob.121403173614.716"><vh>@file arrows.py</vh>
<v t="rodrigob.121403173614.717"><vh>onOpen</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.718"><vh>Menus</vh>
<v t="rodrigob.121403173614.719"><vh> Plugins menu</vh>
<v t="rodrigob.121403173614.720"><vh>@file plugins_menu.py</vh>
<v t="rodrigob.121403173614.721"><vh>class Plugin</vh>
<v t="rodrigob.121403173614.722"><vh>__init__</vh>
<v t="rodrigob.121403173614.723"><vh>&lt;&lt; Check if this can be configured &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.724"><vh>&lt;&lt; Check if this has an apply &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.725"><vh>&lt;&lt; Look for additional commands &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.726"><vh>about</vh></v>
<v t="rodrigob.121403173614.727"><vh>properties</vh></v>
</v>
<v t="rodrigob.121403173614.728"><vh>class PropertiesWindow</vh>
<v t="rodrigob.121403173614.729"><vh>__init__</vh>
<v t="rodrigob.121403173614.730"><vh>&lt;&lt; initialize all ivars &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.731"><vh>&lt;&lt; create the frame from the configuration data &gt;&gt;</vh>
<v t="rodrigob.121403173614.732"><vh>&lt;&lt; Create the top level and the main frame &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.733"><vh>&lt;&lt; Create widgets for each section and option &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.734"><vh>&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.735"><vh>Event Handlers</vh></v>
<v t="rodrigob.121403173614.736"><vh>writeConfiguration</vh></v>
</v>
<v t="rodrigob.121403173614.737"><vh>class PluginAbout</vh>
<v t="rodrigob.121403173614.738"><vh>__init__</vh>
<v t="rodrigob.121403173614.739"><vh>&lt;&lt; Create the contents of the about box &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.740"><vh>&lt;&lt; Create the close button &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.741"><vh>createPluginsMenu</vh>
<v t="rodrigob.121403173614.742"><vh>&lt;&lt; add items to the plugins menu &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.743"><vh>@file test.py</vh>
<v t="rodrigob.121403173614.744"><vh>applyConfiguration</vh></v>
<v t="rodrigob.121403173614.745"><vh>cmd_fn1/2/3</vh></v>
<v t="rodrigob.121403173614.746"><vh>onSelect</vh>
<v t="rodrigob.121403173614.747"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.748"><vh>onUnselect</vh>
<v t="rodrigob.121403173614.749"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.750"><vh>Notes re plugins menu</vh>
<v t="rodrigob.121403173614.751"><vh> Changes made by E.K.Ream</vh></v>
<v t="rodrigob.121403173614.752"><vh> Design</vh></v>
<v t="rodrigob.121403173614.753"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.754"><vh>@file scripts_menu.py</vh>
<v t="rodrigob.121403173614.755"><vh>createScriptsMenu</vh>
<v t="rodrigob.121403173614.756"><vh>&lt;&lt; Return if no scripts exist anywhere &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.757"><vh>&lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.758"><vh>&lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.759"><vh>New kinds of nodes</vh>
<v t="rodrigob.121403173614.760"><vh>@file at_folder.py</vh>
<v t="rodrigob.121403173614.761"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.762"><vh>sync_node_to_folder</vh></v>
</v>
<v t="rodrigob.121403173614.763"><vh>@file read_only_nodes.py</vh>
<v t="rodrigob.121403173614.764"><vh>documentation for @read-only nodes</vh>
<v t="rodrigob.121403173614.765"><vh>ftp/http access</vh></v>
</v>
<v t="rodrigob.121403173614.766"><vh>class FTPurl</vh>
<v t="rodrigob.121403173614.767"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.768"><vh>Getters</vh>
<v t="rodrigob.121403173614.769"><vh>read</vh></v>
<v t="rodrigob.121403173614.770"><vh>readline</vh></v>
</v>
<v t="rodrigob.121403173614.771"><vh>Setters</vh>
<v t="rodrigob.121403173614.772"><vh>write</vh></v>
</v>
<v t="rodrigob.121403173614.773"><vh>Utilities</vh>
<v t="rodrigob.121403173614.774"><vh>seek</vh></v>
<v t="rodrigob.121403173614.775"><vh>flush</vh></v>
<v t="rodrigob.121403173614.776"><vh>dir</vh></v>
<v t="rodrigob.121403173614.777"><vh>exists</vh></v>
<v t="rodrigob.121403173614.778"><vh>checkParams</vh></v>
</v>
<v t="rodrigob.121403173614.779"><vh>close</vh></v>
</v>
<v t="rodrigob.121403173614.780"><vh>enable/disable_body</vh></v>
<v t="rodrigob.121403173614.781"><vh>insert_read_only_node (FTP version)</vh>
<v t="rodrigob.121403173614.782"><vh>&lt;&lt; convert HTML to text &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.783"><vh>on_open2</vh></v>
<v t="rodrigob.121403173614.784"><vh>on_bodykey1</vh></v>
<v t="rodrigob.121403173614.785"><vh>on_headkey2</vh></v>
<v t="rodrigob.121403173614.786"><vh>on_select1</vh></v>
<v t="rodrigob.121403173614.787"><vh>on_select2</vh></v>
</v>
<v t="rodrigob.121403173614.788"><vh>@file rst.py</vh>
<v t="rodrigob.121403173614.789"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.790"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.791"><vh>onIconDoubleClick</vh>
<v t="rodrigob.121403173614.792"><vh>&lt;&lt; write rST as HTML &gt;&gt;</vh>
<v t="rodrigob.121403173614.793"><vh>&lt;&lt; convert rST to HTML &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.794"><vh>&lt;&lt; write rST file &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.795"><vh>writeTreeAsRst</vh></v>
<v t="rodrigob.121403173614.796"><vh>underline</vh></v>
</v>
<v t="rodrigob.121403173614.797"><vh>@file startfile.py</vh>
<v t="rodrigob.121403173614.798"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.799"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.800"><vh>onIconDoubleClick</vh>
<v t="rodrigob.121403173614.801"><vh>&lt;&lt; find path and start file &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.802"><vh>Overriding functions, methods &amp; classes</vh>
<v t="rodrigob.121403173614.803"><vh>@file __overrideClasses.py</vh>
<v t="rodrigob.121403173614.804"><vh>&lt;&lt; override the LeoFrame class &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.805"><vh>&lt;&lt; override methods of the LeoApp class &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.806"><vh>@file override_commands.py</vh>
<v t="rodrigob.121403173614.807"><vh>onCommand</vh></v>
</v>
<v t="rodrigob.121403173614.808"><vh>@file redefine_put.py</vh>
<v t="rodrigob.121403173614.809"><vh>onStart</vh></v>
<v t="rodrigob.121403173614.810"><vh>newPut and newPutNl</vh></v>
</v>
<v t="rodrigob.121403173614.811"><vh>@file redirect_to_log.py</vh></v>
<v t="rodrigob.121403173614.812"><vh>@file script_io_to_body.py</vh>
<v t="rodrigob.121403173614.813"><vh>onStart</vh></v>
<v t="rodrigob.121403173614.814"><vh>newExecuteScript</vh></v>
<v t="rodrigob.121403173614.815"><vh>newPut and newPutNl</vh></v>
<v t="rodrigob.121403173614.816"><vh>newEs, etc.</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.817"><vh>Spell Checking</vh>
<v t="rodrigob.121403173614.818"><vh>@silentfile mod_spelling.txt</vh></v>
<v t="rodrigob.121403173614.819"><vh>@file mod_spelling.ini</vh></v>
<v t="rodrigob.121403173614.820"><vh>@file mod_spelling.py</vh>
<v t="rodrigob.121403173614.821"><vh>Functions</vh>
<v t="rodrigob.121403173614.822"><vh>createSpellMenu</vh></v>
<v t="rodrigob.121403173614.823"><vh>onSelect</vh></v>
<v t="rodrigob.121403173614.824"><vh>onCommand</vh></v>
</v>
<v t="rodrigob.121403173614.825"><vh>class Aspell</vh>
<v t="rodrigob.121403173614.826"><vh>Birth &amp; death</vh>
<v t="rodrigob.121403173614.827"><vh>__init__</vh></v>
<v t="rodrigob.121403173614.828"><vh>getAspellDirectory</vh></v>
</v>
<v t="rodrigob.121403173614.829"><vh>openPipes</vh>
<v t="rodrigob.121403173614.830"><vh>&lt;&lt; Ensure local dictionary is present &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.831"><vh>closePipes</vh></v>
<v t="rodrigob.121403173614.832"><vh>listAlternates</vh></v>
<v t="rodrigob.121403173614.833"><vh>processWord</vh></v>
<v t="rodrigob.121403173614.834"><vh>updateDictionary</vh></v>
</v>
<v t="rodrigob.121403173614.835"><vh>class spellDialog</vh>
<v t="rodrigob.121403173614.836"><vh>Birth &amp; death</vh>
<v t="rodrigob.121403173614.837"><vh>spell.__init__</vh>
<v t="rodrigob.121403173614.838"><vh>&lt;&lt; set self.dictionary &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.839"><vh>getLocalDictionary</vh></v>
<v t="rodrigob.121403173614.840"><vh>getLocalLanguageCode</vh></v>
<v t="rodrigob.121403173614.841"><vh>readLocalDictionary</vh></v>
</v>
<v t="rodrigob.121403173614.842"><vh>createFrame</vh>
<v t="rodrigob.121403173614.843"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.844"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.845"><vh>Buttons</vh>
<v t="rodrigob.121403173614.846"><vh>onAddButton</vh></v>
<v t="rodrigob.121403173614.847"><vh>onIgnoreButton</vh></v>
<v t="rodrigob.121403173614.848"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="rodrigob.121403173614.849"><vh>onFindButton</vh></v>
<v t="rodrigob.121403173614.850"><vh>onHideButton</vh></v>
<v t="rodrigob.121403173614.851"><vh>onRedoButton &amp; onUndoButton</vh></v>
</v>
<v t="rodrigob.121403173614.852"><vh>Commands</vh>
<v t="rodrigob.121403173614.853"><vh>add</vh></v>
<v t="rodrigob.121403173614.854"><vh>change</vh></v>
<v t="rodrigob.121403173614.855"><vh>checkSpelling</vh></v>
<v t="rodrigob.121403173614.856"><vh>find</vh></v>
<v t="rodrigob.121403173614.857"><vh>ignore</vh></v>
</v>
<v t="rodrigob.121403173614.858"><vh>Helpers</vh>
<v t="rodrigob.121403173614.859"><vh>closePipes</vh></v>
<v t="rodrigob.121403173614.860"><vh>fillbox</vh></v>
<v t="rodrigob.121403173614.861"><vh>findNextMisspelledWord</vh>
<v t="rodrigob.121403173614.862"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.863"><vh>findNextWord</vh></v>
<v t="rodrigob.121403173614.864"><vh>getSuggestion</vh></v>
<v t="rodrigob.121403173614.865"><vh>onMap</vh></v>
<v t="rodrigob.121403173614.866"><vh>onSelectListBox</vh></v>
<v t="rodrigob.121403173614.867"><vh>update</vh></v>
<v t="rodrigob.121403173614.868"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.869"><vh>body key handlers (tree)</vh>
<v t="rodrigob.121403173614.870"><vh>idle_body_key</vh>
<v t="rodrigob.121403173614.871"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.872"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.873"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.874"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="rodrigob.121403173614.875"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.876"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.877"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.878"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.879"><vh>onBodyChanged</vh></v>
<v t="rodrigob.121403173614.880"><vh>OnBodyKey</vh></v>
<v t="rodrigob.121403173614.881"><vh>onBodyWillChange</vh></v>
</v>
<v t="rodrigob.121403173614.882"><vh>file leoCommands.py</vh>
<v t="rodrigob.121403173614.883"><vh>Birth &amp; death</vh>
<v t="rodrigob.121403173614.884"><vh>c.__init__ &amp; initIvars</vh>
<v t="rodrigob.121403173614.885"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.886"><vh>c.__repr__ &amp; __str__</vh></v>
</v>
<v t="rodrigob.121403173614.887"><vh>c.setIvarsFromFind</vh></v>
<v t="rodrigob.121403173614.888"><vh>c.setIvarsFromPrefs</vh></v>
<v t="rodrigob.121403173614.889"><vh>Cut &amp; Paste Outlines</vh>
<v t="rodrigob.121403173614.890"><vh>cutOutline</vh></v>
<v t="rodrigob.121403173614.891"><vh>copyOutline</vh></v>
<v t="rodrigob.121403173614.892"><vh>pasteOutline</vh></v>
</v>
<v t="rodrigob.121403173614.893"><vh>Drawing Utilities</vh>
<v t="rodrigob.121403173614.894"><vh>beginUpdate</vh></v>
<v t="rodrigob.121403173614.895"><vh>bringToFront</vh></v>
<v t="rodrigob.121403173614.896"><vh>endUpdate</vh></v>
<v t="rodrigob.121403173614.897"><vh>recolor</vh></v>
<v t="rodrigob.121403173614.898"><vh>redraw &amp; repaint</vh></v>
</v>
<v t="rodrigob.121403173614.899"><vh>Edit Body Text</vh>
<v t="rodrigob.121403173614.900"><vh>convertAllBlanks</vh></v>
<v t="rodrigob.121403173614.901"><vh>convertAllTabs</vh></v>
<v t="rodrigob.121403173614.902"><vh>convertBlanks</vh></v>
<v t="rodrigob.121403173614.903"><vh>convertTabs</vh></v>
<v t="rodrigob.121403173614.904"><vh>createLastChildNode</vh></v>
<v t="rodrigob.121403173614.905"><vh>dedentBody</vh></v>
<v t="rodrigob.121403173614.906" a="E"><vh>extract</vh>
<v t="rodrigob.121403173614.907"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.908"><vh>extractSection</vh>
<v t="rodrigob.121403173614.909"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.910"><vh>extractSectionNames</vh>
<v t="rodrigob.121403173614.911"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.912"><vh>getBodyLines</vh></v>
<v t="rodrigob.121403173614.913"><vh>getBodySelection</vh></v>
<v t="rodrigob.121403173614.914"><vh>indentBody</vh></v>
<v t="rodrigob.121403173614.915"><vh>reformatParagraph</vh>
<v t="rodrigob.121403173614.916"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.917"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="rodrigob.121403173614.918"><vh>Enabling Menu Items (Commands)</vh>
<v t="rodrigob.121403173614.919"><vh>canContractAllHeadlines</vh></v>
<v t="rodrigob.121403173614.920"><vh>canContractAllSubheads</vh></v>
<v t="rodrigob.121403173614.921"><vh>canContractParent</vh></v>
<v t="rodrigob.121403173614.922"><vh>canContractSubheads</vh></v>
<v t="rodrigob.121403173614.923"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="rodrigob.121403173614.924"><vh>canDemote</vh></v>
<v t="rodrigob.121403173614.925"><vh>canExpandAllHeadlines</vh></v>
<v t="rodrigob.121403173614.926"><vh>canExpandAllSubheads</vh></v>
<v t="rodrigob.121403173614.927"><vh>canExpandSubheads</vh></v>
<v t="rodrigob.121403173614.928"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="rodrigob.121403173614.929"><vh>canFindMatchingBracket</vh></v>
<v t="rodrigob.121403173614.930"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="rodrigob.121403173614.931"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="rodrigob.121403173614.932"><vh>canMarkChangedHeadline</vh></v>
<v t="rodrigob.121403173614.933"><vh>canMarkChangedRoots</vh></v>
<v t="rodrigob.121403173614.934"><vh>canMoveOutlineDown</vh></v>
<v t="rodrigob.121403173614.935"><vh>canMoveOutlineLeft</vh></v>
<v t="rodrigob.121403173614.936"><vh>canMoveOutlineRight</vh></v>
<v t="rodrigob.121403173614.937"><vh>canMoveOutlineUp</vh></v>
<v t="rodrigob.121403173614.938"><vh>canPasteOutline</vh></v>
<v t="rodrigob.121403173614.939"><vh>canPromote</vh></v>
<v t="rodrigob.121403173614.940"><vh>canRevert</vh></v>
<v t="rodrigob.121403173614.941"><vh>canSelect....</vh></v>
<v t="rodrigob.121403173614.942"><vh>canShiftBodyLeft/Right</vh></v>
<v t="rodrigob.121403173614.943"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="rodrigob.121403173614.944"><vh>canUndo &amp; canRedo</vh></v>
<v t="rodrigob.121403173614.945"><vh>canUnmarkAll</vh></v>
</v>
<v t="rodrigob.121403173614.946"><vh>Expand &amp; Contract</vh>
<v t="rodrigob.121403173614.947"><vh>Commands</vh>
<v t="rodrigob.121403173614.948"><vh>contractAllHeadlines</vh></v>
<v t="rodrigob.121403173614.949"><vh>contractNode</vh></v>
<v t="rodrigob.121403173614.950"><vh>contractParent</vh></v>
<v t="rodrigob.121403173614.951"><vh>expandAllHeadlines</vh></v>
<v t="rodrigob.121403173614.952"><vh>expandAllSubheads</vh></v>
<v t="rodrigob.121403173614.953"><vh>expandLevel1..9</vh></v>
<v t="rodrigob.121403173614.954"><vh>expandNextLevel</vh></v>
<v t="rodrigob.121403173614.955"><vh>expandNode</vh></v>
<v t="rodrigob.121403173614.956"><vh>expandPrevLevel</vh></v>
</v>
<v t="rodrigob.121403173614.957"><vh>Utilities</vh>
<v t="rodrigob.121403173614.958"><vh>contractSubtree</vh></v>
<v t="rodrigob.121403173614.959"><vh>expandSubtree</vh></v>
<v t="rodrigob.121403173614.960"><vh>expandToLevel</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.961"><vh>Getters &amp; Setters</vh>
<v t="rodrigob.121403173614.962"><vh>c.currentVnode</vh></v>
<v t="rodrigob.121403173614.963"><vh>clearAllMarked</vh></v>
<v t="rodrigob.121403173614.964"><vh>clearAllVisited</vh></v>
<v t="rodrigob.121403173614.965"><vh>fileName</vh></v>
<v t="rodrigob.121403173614.966"><vh>isChanged</vh></v>
<v t="rodrigob.121403173614.967"><vh>rootVnode</vh></v>
<v t="rodrigob.121403173614.968"><vh>setChanged</vh></v>
</v>
<v t="rodrigob.121403173614.969"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="rodrigob.121403173614.970"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="rodrigob.121403173614.971"><vh>c.deleteHeadline</vh></v>
<v t="rodrigob.121403173614.972"><vh>c.insertHeadline</vh></v>
<v t="rodrigob.121403173614.973"><vh>c.clone</vh></v>
<v t="rodrigob.121403173614.974"><vh>initAllCloneBits (changed in 4.0)</vh></v>
<v t="rodrigob.121403173614.975"><vh>c.initJoinedClonedBits (changed in 3.11.1)</vh></v>
<v t="rodrigob.121403173614.976"><vh>validateOutline</vh></v>
</v>
<v t="rodrigob.121403173614.977"><vh>Mark &amp; Unmark &amp; goto</vh>
<v t="rodrigob.121403173614.978"><vh>goToNextDirtyHeadline</vh></v>
<v t="rodrigob.121403173614.979"><vh>goToNextMarkedHeadline</vh></v>
<v t="rodrigob.121403173614.980"><vh>goToNextClone</vh></v>
<v t="rodrigob.121403173614.981"><vh>markChangedHeadlines</vh></v>
<v t="rodrigob.121403173614.982"><vh>markChangedRoots</vh></v>
<v t="rodrigob.121403173614.983"><vh>markAllAtFileNodesDirty</vh></v>
<v t="rodrigob.121403173614.984"><vh>markAtFileNodesDirty</vh></v>
<v t="rodrigob.121403173614.985"><vh>markClones</vh></v>
<v t="rodrigob.121403173614.986"><vh>markHeadline</vh></v>
<v t="rodrigob.121403173614.987"><vh>markSubheads</vh></v>
<v t="rodrigob.121403173614.988"><vh>unmarkAll</vh></v>
</v>
<v t="rodrigob.121403173614.989"><vh>Moving, Dragging, Promote, Demote, Sort (commands)</vh>
<v t="rodrigob.121403173614.990"><vh>c.dragAfter</vh></v>
<v t="rodrigob.121403173614.991"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="rodrigob.121403173614.992"><vh>c.dragToNthChildOf</vh></v>
<v t="rodrigob.121403173614.993"><vh>c.sortChildren, sortSiblings</vh>
<v t="rodrigob.121403173614.994"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.995"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.996"><vh>c.sortTopLevel</vh>
<v t="rodrigob.121403173614.997"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.998"><vh>demote</vh></v>
<v t="rodrigob.121403173614.999"><vh>moveOutlineDown</vh>
<v t="rodrigob.121403173614.1000"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1001"><vh>moveOutlineLeft</vh></v>
<v t="rodrigob.121403173614.1002"><vh>moveOutlineRight</vh></v>
<v t="rodrigob.121403173614.1003"><vh>moveOutlineUp</vh>
<v t="rodrigob.121403173614.1004"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1005"><vh>promote</vh></v>
<v t="rodrigob.121403173614.1006"><vh>c.dragCloneAfter (changed in 3.11.1)</vh></v>
</v>
<v t="rodrigob.121403173614.1007"><vh>Selecting &amp; Updating (commands)</vh>
<v t="rodrigob.121403173614.1008"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="rodrigob.121403173614.1009"><vh>endEditing (calls tree.endEditLabel)</vh></v>
<v t="rodrigob.121403173614.1010"><vh>selectThreadBack</vh></v>
<v t="rodrigob.121403173614.1011"><vh>selectThreadNext</vh></v>
<v t="rodrigob.121403173614.1012"><vh>selectVisBack</vh></v>
<v t="rodrigob.121403173614.1013"><vh>selectVisNext</vh></v>
<v t="rodrigob.121403173614.1014"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="rodrigob.121403173614.1015"><vh>selectVnodeWithEditing</vh></v>
</v>
<v t="rodrigob.121403173614.1016"><vh>Syntax coloring interface</vh>
<v t="rodrigob.121403173614.1017"><vh>updateSyntaxColorer</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1018"><vh>file leoTree.py</vh>
<v t="rodrigob.121403173614.1019"><vh>&lt;&lt; about the tree classes &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1020"><vh>&lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1021"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1022"><vh>Birth &amp; death</vh>
<v t="rodrigob.121403173614.1023"><vh>tree.__init__</vh></v>
<v t="rodrigob.121403173614.1024"><vh>tree.deleteBindings</vh></v>
<v t="rodrigob.121403173614.1025"><vh>tree.deleteWidgets</vh></v>
</v>
<v t="rodrigob.121403173614.1026"><vh>Drawing</vh>
<v t="rodrigob.121403173614.1027"><vh>About drawing and updating</vh></v>
<v t="rodrigob.121403173614.1028"><vh>beginUpdate</vh></v>
<v t="rodrigob.121403173614.1029"><vh>drawBox (tag_bind)</vh></v>
<v t="rodrigob.121403173614.1030"><vh>drawIcon (tag_bind)</vh></v>
<v t="rodrigob.121403173614.1031"><vh>Drawing routines (tree)...</vh>
<v t="rodrigob.121403173614.1032"><vh>redraw</vh></v>
<v t="rodrigob.121403173614.1033"><vh>force_redraw</vh></v>
<v t="rodrigob.121403173614.1034"><vh>redraw_now</vh></v>
<v t="rodrigob.121403173614.1035"><vh>idle_redraw</vh></v>
<v t="rodrigob.121403173614.1036"><vh>idle_second_redraw</vh></v>
</v>
<v t="rodrigob.121403173614.1037"><vh>drawNode &amp; force_draw_node</vh></v>
<v t="rodrigob.121403173614.1038"><vh>drawText (bind)</vh>
<v t="rodrigob.121403173614.1039"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1040"><vh>drawTree</vh>
<v t="rodrigob.121403173614.1041"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1042"><vh>endUpdate</vh></v>
<v t="rodrigob.121403173614.1043"><vh>headWidth</vh></v>
<v t="rodrigob.121403173614.1044"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="rodrigob.121403173614.1045"><vh>lastVisible</vh></v>
<v t="rodrigob.121403173614.1046"><vh>setLineHeight</vh></v>
<v t="rodrigob.121403173614.1047"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="rodrigob.121403173614.1048"><vh>tree.getIconImage</vh></v>
<v t="rodrigob.121403173614.1049"><vh>tree.idle_scrollTo</vh></v>
<v t="rodrigob.121403173614.1050"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="rodrigob.121403173614.1051"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="rodrigob.121403173614.1052"><vh>tree.yoffset</vh></v>
</v>
<v t="rodrigob.121403173614.1053" a="E"><vh>Event handers (tree)</vh>
<v t="rodrigob.121403173614.1054"><vh>OnActivate</vh>
<v t="rodrigob.121403173614.1055"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1056"><vh>OnBoxClick</vh></v>
<v t="rodrigob.121403173614.1057"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="rodrigob.121403173614.1058"><vh>tree.findVnodeWithIconId</vh></v>
<v t="rodrigob.121403173614.869"><vh>body key handlers (tree)</vh>
<v t="rodrigob.121403173614.870"><vh>idle_body_key</vh>
<v t="rodrigob.121403173614.871"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.872"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.873"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.874"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="rodrigob.121403173614.875"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.876"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.877"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.878"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.879"><vh>onBodyChanged</vh></v>
<v t="rodrigob.121403173614.880"><vh>OnBodyKey</vh></v>
<v t="rodrigob.121403173614.881"><vh>onBodyWillChange</vh></v>
</v>
<v t="rodrigob.121403173614.1059"><vh>tree.OnContinueDrag</vh>
<v t="rodrigob.121403173614.1060"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="rodrigob.121403173614.1061"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1062"><vh>tree.OnCtontrolT</vh></v>
<v t="rodrigob.121403173614.1063"><vh>tree.OnDrag</vh></v>
<v t="rodrigob.121403173614.1064"><vh>tree.OnEndDrag</vh>
<v t="rodrigob.121403173614.1065"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1066"><vh>headline key handlers (tree)</vh>
<v t="rodrigob.121403173614.1067"><vh>onHeadChanged</vh></v>
<v t="rodrigob.121403173614.1068"><vh>OnHeadlineKey</vh></v>
<v t="rodrigob.121403173614.1069"><vh>idle_head_key</vh>
<v t="rodrigob.121403173614.1070"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1071"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1072"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1073"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1074"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1075"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
<v t="rodrigob.121403173614.1076"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="rodrigob.121403173614.1077"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1078"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1079"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1080"><vh>tree.OnPopup &amp; allies</vh>
<v t="rodrigob.121403173614.1081"><vh>OnPopupFocusLost</vh></v>
<v t="rodrigob.121403173614.1082"><vh>createPopupMenu</vh>
<v t="rodrigob.121403173614.1083"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1084"><vh>enablePopupMenuItems</vh>
<v t="rodrigob.121403173614.1085"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1086"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1087"><vh>Incremental drawing</vh>
<v t="rodrigob.121403173614.1088"><vh>allocateNodes</vh></v>
<v t="rodrigob.121403173614.1089"><vh>allocateNodesBeforeScrolling</vh></v>
<v t="rodrigob.121403173614.1090"><vh>updateNode</vh></v>
<v t="rodrigob.121403173614.1091"><vh>setVisibleAreaToFullCanvas</vh></v>
<v t="rodrigob.121403173614.1092"><vh>setVisibleArea</vh></v>
<v t="rodrigob.121403173614.1093"><vh>tree.updateTree</vh></v>
</v>
<v t="rodrigob.121403173614.1094"><vh>Selecting &amp; editing (tree)</vh>
<v t="rodrigob.121403173614.1095"><vh>abortEditLabelCommand</vh></v>
<v t="rodrigob.121403173614.1096"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="rodrigob.121403173614.1097"><vh>editLabel</vh></v>
<v t="rodrigob.121403173614.1098"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="rodrigob.121403173614.1099"><vh>tree.expandAllAncestors</vh></v>
<v t="rodrigob.121403173614.1100"><vh>tree.scanForTabWidth</vh>
<v t="rodrigob.121403173614.1101"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1102"><vh>tree.select</vh>
<v t="rodrigob.121403173614.1103"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1104"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1105"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1106"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1107"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1108"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1109"><vh>tree.set...LabelState</vh>
<v t="rodrigob.121403173614.1110"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1111"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1112"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1113"><vh>tree.moveUpDown</vh></v>
</v>
<v t="rodrigob.121403173614.1114"><vh>file leoUndo.py</vh>
<v t="rodrigob.121403173614.1115"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1116"><vh>&lt;&lt; Define optional ivars &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1117"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="rodrigob.121403173614.1118"><vh>clearIvars</vh></v>
</v>
<v t="rodrigob.121403173614.1119" a="E"><vh>State routines...</vh>
<v t="rodrigob.121403173614.1120"><vh>clearUndoState</vh></v>
<v t="rodrigob.121403173614.1121"><vh>canRedo &amp; canUndo</vh></v>
<v t="rodrigob.121403173614.1122"><vh>enableMenuItems</vh></v>
<v t="rodrigob.121403173614.1123"><vh>getBead, peekBead, setBead</vh></v>
<v t="rodrigob.121403173614.1124"><vh>redoMenuName, undoMenuName</vh></v>
<v t="rodrigob.121403173614.1125"><vh>setRedoType, setUndoType</vh></v>
<v t="rodrigob.121403173614.1126"><vh>setUndoParams</vh></v>
<v t="rodrigob.121403173614.1127"><vh>setUndoTypingParams</vh>
<v t="rodrigob.121403173614.1128"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1129"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1130"><vh>setUndoTypes</vh></v>
</v>
<v t="rodrigob.121403173614.1131"><vh>u.redo</vh>
<v t="rodrigob.121403173614.1132"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1133"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1134"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1135"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1136"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1137"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1138"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1139"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1140" a="E"><vh>u.undo</vh>
<v t="rodrigob.121403173614.1141"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1142"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1143"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1144"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1145"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1146"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1147"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1148"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1149"><vh>Undo helpers</vh>
<v t="rodrigob.121403173614.1150"><vh>findSharedVnode</vh></v>
<v t="rodrigob.121403173614.1151"><vh>undoDemote</vh></v>
<v t="rodrigob.121403173614.1152"><vh>undoPromote</vh></v>
<v t="rodrigob.121403173614.1153"><vh>undoReplace</vh></v>
<v t="rodrigob.121403173614.1154"><vh>undoRedoText</vh>
<v t="rodrigob.121403173614.1155"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1156"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1157"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1158"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1159"><vh>undoSortChildren</vh></v>
<v t="rodrigob.121403173614.1160"><vh>undoSortSiblings</vh></v>
<v t="rodrigob.121403173614.1161"><vh>undoSortTopLevel</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1162"><vh>file leoNodes.py</vh>
<v t="rodrigob.121403173614.1163"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1164"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1165"><vh>class tnode</vh>
<v t="rodrigob.121403173614.1166"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1167"><vh>t.__init__</vh></v>
<v t="rodrigob.121403173614.1168" a="E"><vh>Getters</vh>
<v t="rodrigob.121403173614.1169"><vh>hasBody</vh></v>
<v t="rodrigob.121403173614.1170"><vh>loadBodyPaneFromTnode</vh></v>
<v t="rodrigob.121403173614.1171" a="E"><vh>Status bits</vh>
<v t="rodrigob.121403173614.1172"><vh>isDirty</vh></v>
<v t="rodrigob.121403173614.1173"><vh>isRichTextBit</vh></v>
<v t="rodrigob.121403173614.1174"><vh>isVisited</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1175" a="E"><vh>Setters</vh>
<v t="rodrigob.121403173614.1176" a="E"><vh>Setting body text</vh>
<v t="rodrigob.121403173614.1177"><vh>saveBodyPaneToTnode</vh></v>
<v t="rodrigob.121403173614.1178"><vh>setTnodeText</vh></v>
<v t="rodrigob.121403173614.1179"><vh>setSelection</vh></v>
</v>
<v t="rodrigob.121403173614.1180"><vh>Status bits</vh>
<v t="rodrigob.121403173614.1181"><vh>clearDirty</vh></v>
<v t="rodrigob.121403173614.1182"><vh>clearRichTextBit</vh></v>
<v t="rodrigob.121403173614.1183"><vh>clearVisited</vh></v>
<v t="rodrigob.121403173614.1184"><vh>setDirty</vh></v>
<v t="rodrigob.121403173614.1185"><vh>setRichTextBit</vh></v>
<v t="rodrigob.121403173614.1186"><vh>setVisited</vh></v>
</v>
<v t="rodrigob.121403173614.1187"><vh>setCloneIndex</vh></v>
<v t="rodrigob.121403173614.1188"><vh>setFileIndex</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.1189" a="E"><vh>class vnode</vh>
<v t="rodrigob.121403173614.1190"><vh>&lt;&lt; vnode constants &gt;&gt;  ### Warning: changes meaning of visitedBit</vh></v>
<v t="rodrigob.121403173614.1191"><vh>Birth &amp; death</vh>
<v t="rodrigob.121403173614.1192"><vh>v.__cmp__ (not used)</vh></v>
<v t="rodrigob.121403173614.1193"><vh>v.__init__</vh>
<v t="rodrigob.121403173614.1194"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="rodrigob.121403173614.1195"><vh>v.__repr__ &amp; v.__str__</vh></v>
</v>
<v t="rodrigob.121403173614.1196"><vh>v.Callbacks (handles event hooks)</vh>
<v t="rodrigob.121403173614.1197"><vh>OnBoxClick</vh></v>
<v t="rodrigob.121403173614.1198"><vh>OnDrag</vh></v>
<v t="rodrigob.121403173614.1199"><vh>v.OnEndDrag</vh></v>
<v t="rodrigob.121403173614.1200"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="rodrigob.121403173614.1201"><vh>OnHeadlineKey</vh></v>
<v t="rodrigob.121403173614.1202"><vh>OnHyperLinkControlClick</vh></v>
<v t="rodrigob.121403173614.1203"><vh>OnHyperLinkEnter</vh></v>
<v t="rodrigob.121403173614.1204"><vh>OnHyperLinkLeave</vh></v>
<v t="rodrigob.121403173614.1205"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="rodrigob.121403173614.1206"><vh>OnIconDoubleClick</vh></v>
</v>
<v t="rodrigob.121403173614.1207"><vh>Comparisons (vnode)</vh>
<v t="rodrigob.121403173614.1208"><vh>afterHeadlineMatch</vh></v>
<v t="rodrigob.121403173614.1209"><vh>at/../NodeName</vh></v>
<v t="rodrigob.121403173614.1210"><vh>isAt/../Node</vh></v>
<v t="rodrigob.121403173614.1211"><vh>isAnyAtFileNode &amp; isAnyAtFileNodeName</vh></v>
<v t="rodrigob.121403173614.1212"><vh>isAtIgnoreNode</vh></v>
<v t="rodrigob.121403173614.1213"><vh>isAtOthersNode</vh></v>
<v t="rodrigob.121403173614.1214"><vh>matchHeadline</vh></v>
</v>
<v t="rodrigob.121403173614.1215"><vh>File Conversion (vnode)</vh>
<v t="rodrigob.121403173614.1216"><vh>convertTreeToString</vh></v>
<v t="rodrigob.121403173614.1217"><vh>moreHead</vh></v>
<v t="rodrigob.121403173614.1218"><vh>v.moreBody</vh></v>
</v>
<v t="rodrigob.121403173614.1219" a="E"><vh>Getters</vh>
<v t="rodrigob.121403173614.1220" a="E"><vh>Children</vh>
<v t="rodrigob.121403173614.1221"><vh>childIndex</vh></v>
<v t="rodrigob.121403173614.1222"><vh>firstChild</vh></v>
<v t="rodrigob.121403173614.1223"><vh>hasChildren</vh></v>
<v t="rodrigob.121403173614.1224"><vh>lastChild</vh></v>
<v t="rodrigob.121403173614.1225"><vh>nthChild</vh></v>
<v t="rodrigob.121403173614.1226"><vh>numberOfChildren (n)</vh></v>
</v>
<v t="rodrigob.121403173614.1227"><vh>Status Bits</vh>
<v t="rodrigob.121403173614.1228"><vh>isCloned</vh></v>
<v t="rodrigob.121403173614.1229"><vh>isDirty</vh></v>
<v t="rodrigob.121403173614.1230"><vh>isExpanded</vh></v>
<v t="rodrigob.121403173614.1231"><vh>isMarked</vh></v>
<v t="rodrigob.121403173614.1232"><vh>isOrphan</vh></v>
<v t="rodrigob.121403173614.1233"><vh>isSelected</vh></v>
<v t="rodrigob.121403173614.1234"><vh>isTopBitSet</vh></v>
<v t="rodrigob.121403173614.1235"><vh>isVisible</vh></v>
<v t="rodrigob.121403173614.1236"><vh>isVisited</vh></v>
<v t="rodrigob.121403173614.1237"><vh>status</vh></v>
</v>
<v t="rodrigob.121403173614.1238"><vh>bodyString</vh></v>
<v t="rodrigob.121403173614.1239"><vh>currentVnode (vnode)</vh></v>
<v t="rodrigob.121403173614.1240"><vh>edit_text</vh></v>
<v t="rodrigob.121403173614.1241"><vh>findRoot</vh></v>
<v t="rodrigob.121403173614.1242"><vh>headString &amp; cleanHeadString</vh></v>
<v t="rodrigob.121403173614.1243"><vh>isAncestorOf</vh></v>
<v t="rodrigob.121403173614.1244"><vh>isRoot</vh></v>
<v t="rodrigob.121403173614.1245"><vh>v.exists</vh></v>
</v>
<v t="rodrigob.121403173614.1246"><vh>Setters</vh>
<v t="rodrigob.121403173614.1247"><vh>Head and body text</vh>
<v t="rodrigob.121403173614.1248"><vh>appendStringToBody</vh></v>
<v t="rodrigob.121403173614.1249"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="rodrigob.121403173614.1250"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="rodrigob.121403173614.1251"><vh>setHeadStringOrHeadline</vh></v>
</v>
<v t="rodrigob.121403173614.1252"><vh>computeIcon &amp; setIcon</vh></v>
<v t="rodrigob.121403173614.1253"><vh>Status bits</vh>
<v t="rodrigob.121403173614.1254"><vh>clearAllVisited</vh></v>
<v t="rodrigob.121403173614.1255"><vh>clearAllVisitedInTree</vh></v>
<v t="rodrigob.121403173614.1256"><vh>clearClonedBit</vh></v>
<v t="rodrigob.121403173614.1257"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="rodrigob.121403173614.1258"><vh>clearMarked</vh></v>
<v t="rodrigob.121403173614.1259"><vh>clearOrphan</vh></v>
<v t="rodrigob.121403173614.1260"><vh>clearVisited</vh></v>
<v t="rodrigob.121403173614.1261"><vh>clearVisitedInTree</vh></v>
<v t="rodrigob.121403173614.1262"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="rodrigob.121403173614.1263"><vh>initStatus</vh></v>
<v t="rodrigob.121403173614.1264"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="rodrigob.121403173614.1265"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="rodrigob.121403173614.1266"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="rodrigob.121403173614.1267"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="rodrigob.121403173614.1268"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="rodrigob.121403173614.1269"><vh>setOrphan</vh></v>
<v t="rodrigob.121403173614.1270"><vh>setSelected (vnode, new)</vh></v>
<v t="rodrigob.121403173614.1271"><vh>setVisited</vh></v>
</v>
<v t="rodrigob.121403173614.1272"><vh>setSelection</vh></v>
<v t="rodrigob.121403173614.1273"><vh>setT</vh></v>
<v t="rodrigob.121403173614.1274"><vh>trimTrailingLines</vh></v>
</v>
<v t="rodrigob.121403173614.1275" a="E"><vh>Tree Traversal (vnode)</vh>
<v t="rodrigob.121403173614.1276"><vh>back</vh></v>
<v t="rodrigob.121403173614.1277"><vh>lastNode</vh></v>
<v t="rodrigob.121403173614.1278"><vh>level</vh></v>
<v t="rodrigob.121403173614.1279"><vh>next</vh></v>
<v t="rodrigob.121403173614.1280"><vh>nodeAfterTree</vh></v>
<v t="rodrigob.121403173614.1281"><vh>parent</vh></v>
<v t="rodrigob.121403173614.1282"><vh>threadBack</vh></v>
<v t="rodrigob.121403173614.1283"><vh>threadNext</vh></v>
<v t="rodrigob.121403173614.1284"><vh>visBack</vh></v>
<v t="rodrigob.121403173614.1285"><vh>visNext</vh></v>
</v>
<v t="rodrigob.121403173614.1286" a="E"><vh>Moving, Inserting, Deleting, Cloning, Sorting (vnode)</vh>
<v t="rodrigob.121403173614.1287" a="E"><vh>Entry Points (vnode)</vh>
<v t="rodrigob.121403173614.1288"><vh>doDelete</vh></v>
<v t="rodrigob.121403173614.1289"><vh>insertAfter</vh></v>
<v t="rodrigob.121403173614.1290"><vh>insertAsLastChild</vh></v>
<v t="rodrigob.121403173614.1291"><vh>insertAsNthChild</vh></v>
<v t="rodrigob.121403173614.1292"><vh>moveToRoot</vh></v>
<v t="rodrigob.121403173614.1293"><vh>restoreOutlineFromDVnodes (test)</vh></v>
<v t="rodrigob.121403173614.1294"><vh>v.clone</vh></v>
<v t="rodrigob.121403173614.1295"><vh>v.linkAfter</vh></v>
<v t="rodrigob.121403173614.1296"><vh>v.linkAsNthChild</vh></v>
<v t="rodrigob.121403173614.1297"><vh>v.linkAsRoot</vh></v>
<v t="rodrigob.121403173614.1298"><vh>v.moveAfter</vh></v>
<v t="rodrigob.121403173614.1299"><vh>v.moveToNthChildOf</vh></v>
<v t="rodrigob.121403173614.1300"><vh>v.sortChildren</vh></v>
</v>
<v t="rodrigob.121403173614.1301" a="E"><vh>Helper functions</vh>
<v t="rodrigob.121403173614.1302"><vh>v.addTreeToJoinLists (new in 3.12 beta 2)</vh></v>
<v t="rodrigob.121403173614.1303"><vh>v.cloneTree</vh></v>
<v t="rodrigob.121403173614.1304"><vh>v.copyCloneBitsTo</vh></v>
<v t="rodrigob.121403173614.1305"><vh>v.copyTree</vh></v>
<v t="rodrigob.121403173614.1306"><vh>v.copyTreeWithNewTnodes (new after 3.11.1) (not used at present)</vh></v>
<v t="rodrigob.121403173614.1307"><vh>v.createDependents</vh></v>
<v t="rodrigob.121403173614.1308"><vh>v.destroyDependents</vh></v>
<v t="rodrigob.121403173614.1309"><vh>v.destroyTree (does nothing!)(Called only from destroy dependents)</vh></v>
<v t="rodrigob.121403173614.1310"><vh>v.invalidOutline</vh></v>
<v t="rodrigob.121403173614.1311"><vh>v.joinNodeTo (rewritten for 4.0)</vh></v>
<v t="rodrigob.121403173614.1312"><vh>v.joinTreeTo</vh></v>
<v t="rodrigob.121403173614.1313"><vh>v.shouldBeClone</vh></v>
<v t="rodrigob.121403173614.1314"><vh>v.unjoinTree</vh></v>
<v t="rodrigob.121403173614.1315"><vh>v.unlink</vh></v>
<v t="rodrigob.121403173614.1316"><vh>validateOutlineWithParent</vh>
<v t="rodrigob.121403173614.1317"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1318"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.1319"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="rodrigob.121403173614.1321" a="E"><vh>Code</vh>
<v t="niederberger.20040825222327" a="E"><vh>Things left to do</vh>
<v t="niederberger.20040825222327.1" a="ETV"><vh>High</vh>
<v t="niederberger.20040920180258"><vh>Disconnect bug</vh></v>
</v>
<v t="niederberger.20040825222327.2" a="E"><vh>Medium</vh>
<v t="niederberger.20040922110026" a="E"><vh>pyzeroconf problems</vh>
<v t="niederberger.20040922111043"><vh>Another rendezvous bug</vh></v>
<v t="niederberger.20040922110926"><vh>Rendez Vous crash the program if pc is without internet</vh></v>
</v>
<v t="rodrigob.20040918185607" a="E"><vh> Concurrent editable todos</vh></v>
</v>
<v t="niederberger.20040825222327.3" a="E"><vh>Low</vh>
<v t="rodrigob.20040125223416" a="E"><vh>hook problem</vh></v>
</v>
</v>
<v t="rodrigob.20040125160038"><vh>Code perspectives</vh>
<v t="rodrigob.20040129141624" a="EM"><vh>network</vh>
<v t="rodrigob.20040913233519" a="M"><vh>&lt;&lt;about the connections process&gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.1" a="EM"><vh>class ChalksNode</vh>
<v t="rodrigob.20040125154815.2" a="EM"><vh>connect to/disconnect from parent node</vh>
<v t="rodrigob.20040913221730" a="E"><vh>connect</vh>
<v t="rodrigob.20040909060311" a="M"><vh>start collaborating</vh></v>
</v>
<v t="rodrigob.20040913221730.1"><vh>disconnect</vh></v>
</v>
<v t="rodrigob.20040912225813" a="E"><vh>add/del sites</vh>
<v t="rodrigob.20040912225813.1" a="E"><vh>add site</vh></v>
<v t="rodrigob.20040912225813.2"><vh>del site</vh></v>
</v>
<v t="rodrigob.20040125154815.3" a="E"><vh>edit content</vh>
<v t="rodrigob.20040125154815.4" a="EM"><vh>set text</vh></v>
<v t="rodrigob.20040125154815.5"><vh>insert text</vh></v>
<v t="rodrigob.20040125154815.6" a="M"><vh>delete text</vh></v>
<v t="rodrigob.20040125154815.8" a="E"><vh>fill body</vh>
<v t="rodrigob.20040125154815.9" a="E"><vh>helpers functions</vh>
<v t="rodrigob.20040125154815.10"><vh>&lt;&lt; def index_to_list &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.11"><vh>&lt;&lt; def in_range &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.12"><vh>&lt;&lt; def range_to_pos_and_length &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.13"><vh>&lt;&lt; text was overwritten &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.14" a="E"><vh>&lt;&lt; suppression or deletion &gt;&gt;</vh>
<v t="rodrigob.20040125154815.15"><vh>&lt;&lt; update the deletion buffer &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.16"><vh>&lt;&lt; create a new deletion buffer &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.17"><vh>&lt;&lt; "normal" keys &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.18"><vh>&lt;&lt; text paste &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.19" a="M"><vh>flush body</vh></v>
<v t="rodrigob.20040125154815.7"><vh>send operation</vh></v>
</v>
<v t="rodrigob.20040127182438" a="E"><vh>remote callable methods</vh>
<v t="rodrigob.20040127184605"><vh>send message</vh></v>
<v t="rodrigob.20040920122333" a="EM"><vh>receive operation</vh></v>
</v>
</v>
<v t="rodrigob.20040125194534" a="EM"><vh>class ChalksAvatar</vh>
<v t="rodrigob.20040126020641" a="M"><vh>collaborate in/out</vh></v>
<v t="rodrigob.20040129150513" a="E"><vh>logout</vh></v>
<v t="rodrigob.20040915120517" a="E"><vh>bi directional methods</vh>
<v t="rodrigob.20040915120517.1"><vh>send message</vh></v>
<v t="rodrigob.20040915120517.2"><vh>receive operation</vh></v>
</v>
</v>
<v t="rodrigob.20040121155420" a="EM"><vh>ConcurrentEditableNode</vh>
<v t="rodrigob.20040128013418" a="E"><vh>__init__</vh></v>
<v t="rodrigob.20040128011816"><vh>receive operation</vh></v>
<v t="rodrigob.20040128011809" a="E"><vh>add/del site</vh>
<v t="rodrigob.20040129165804" a="EM"><vh>add site</vh>
<v t="rodrigob.20040130122927"><vh>&lt;&lt; expand the vectors and matrices &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040129165804.1" a="EM"><vh>del site</vh>
<v t="rodrigob.20040129165804.2"><vh>del clients (server)</vh></v>
</v>
</v>
<v t="rodrigob.20040128011921" a="E"><vh>network methods</vh>
<v t="rodrigob.20040128011921.1" a="E"><vh>connect to parent </vh>
<v t="rodrigob.20040130224144" a="M"><vh>old</vh></v>
<v t="rodrigob.20040129181502"><vh>get_data</vh></v>
</v>
<v t="rodrigob.20040130225705"><vh>disconnect_from_parent</vh></v>
<v t="rodrigob.20040130225148" a="EM"><vh>collaborate_in</vh>
<v t="rodrigob.20040130225208" a="M"><vh>set_state &lt;= THIS IS THE ACTUAL WORK</vh></v>
</v>
<v t="rodrigob.20040128011939"><vh>send operation</vh></v>
</v>
<v t="rodrigob.20040130225148.1" a="M"><vh>get_state</vh></v>
<v t="rodrigob.20040128012459" a="EM"><vh>collect_garbage</vh></v>
<v t="rodrigob.20040128012627"><vh>generate operations</vh></v>
<v t="rodrigob.20040909033320"><vh>set text</vh></v>
</v>
<v t="rodrigob.121403173614.1509" a="EM"><vh>ConcurrentEditable</vh>
<v t="rodrigob.121403173614.1510"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.1511"><vh>apply</vh></v>
<v t="rodrigob.121403173614.1512"><vh>execute</vh>
<v t="rodrigob.121403173614.1513"><vh>insert_text</vh></v>
<v t="rodrigob.121403173614.1514"><vh>delete_text</vh></v>
</v>
<v t="rodrigob.121403173614.1515"><vh>undo</vh></v>
<v t="rodrigob.121403173614.1516" a="E"><vh>collect_garbage</vh>
<v t="rodrigob.20040121161315" a="E"><vh>update SVT</vh></v>
</v>
<v t="rodrigob.121403173614.1517"><vh>generate operations</vh></v>
</v>
<v t="rodrigob.20040121155542"><vh>TestConcurrentEditableNode</vh>
<v t="rodrigob.20040128013509"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.20040128013523"><vh>TestConcurrentEditableServer</vh></v>
</v>
<v t="rodrigob.20040125153141" a="EM"><vh>&lt;&lt; install the collaboration service &gt;&gt;</vh>
<v t="rodrigob.20040125200531.1"><vh>Chalks realm</vh></v>
<v t="rodrigob.20040125200531" a="M"><vh>dummy checker</vh></v>
</v>
</v>
<v t="rodrigob.20040831112258"><vh>gui</vh>
<v t="rodrigob.20040121151612" a="E"><vh>body (construct the gui)</vh>
<v t="rodrigob.20040122173046" a="E"><vh>&lt;&lt; create frames &gt;&gt;</vh>
<v t="rodrigob.20040123123802.1" a="EM"><vh>&lt;&lt; create the splitter &gt;&gt;</vh>
<v t="rodrigob.20040123123829"><vh>&lt;&lt; configure &gt;&gt;</vh></v>
<v t="rodrigob.20040123130224.1"><vh>&lt;&lt; place &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125153909"><vh>&lt;&lt; create the log widget &gt;&gt;</vh></v>
<v t="rodrigob.20040125153909.1"><vh>&lt;&lt; create the text widget &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040122173046.1"><vh>&lt;&lt; install the menu &gt;&gt;</vh></v>
<v t="rodrigob.20040122173046.3"><vh>&lt;&lt; install the status bar &gt;&gt;</vh></v>
<v t="rodrigob.20040122173046.2"><vh>&lt;&lt; install the chat bar &gt;&gt;</vh></v>
<v t="rodrigob.20040125210836" a="E"><vh>helpers</vh>
<v t="rodrigob.20040122182446.1"><vh>class Redirect</vh></v>
<v t="rodrigob.20040123142018"><vh>ask yes no or cancel</vh></v>
</v>
</v>
<v t="rodrigob.20040123124005" a="E"><vh>gui commands/events</vh>
<v t="rodrigob.20040124184444" a="E"><vh>text widget commands</vh>
<v t="rodrigob.20040125154636" a="E"><vh>onTextKey</vh>
<v t="rodrigob.20040125192325"><vh>get text selection</vh></v>
</v>
<v t="rodrigob.20040125154657"><vh>idle_text_key (hook caller of ChalksNode.fill_body) </vh></v>
<v t="rodrigob.20040125145031"><vh>Cut/Copy/Paste</vh></v>
</v>
<v t="rodrigob.20040123130224" a="E"><vh>split bar commands</vh>
<v t="rodrigob.20040121150952.2"><vh>resizePanesToRatio</vh></v>
<v t="rodrigob.20040121150952.7" a="E"><vh>onDragSplitBar</vh>
<v t="rodrigob.20040121150952.6"><vh>divideSplitter</vh></v>
</v>
</v>
<v t="rodrigob.20040122175312"><vh>menu commands</vh>
<v t="rodrigob.20040123133928" a="M"><vh>open</vh></v>
<v t="rodrigob.20040123140212"><vh>save</vh>
<v t="rodrigob.20040125211222"><vh>save text</vh></v>
</v>
<v t="rodrigob.20040123134358" a="E"><vh>connect to</vh>
<v t="niederberger.20040911130819" a="M"><vh>&lt;&lt; server list callback &gt;&gt;</vh></v>
<v t="rodrigob.20040125213003" a="M"><vh>&lt;&lt; connect to callback &gt;&gt;</vh></v>
<v t="rodrigob.20040125213003.1"><vh>&lt;&lt; validation callback &gt;&gt;</vh></v>
<v t="niederberger.20040911120126"><vh>&lt;&lt; server monitor callback &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040913224357"><vh>disconnect</vh></v>
</v>
<v t="rodrigob.20040121153312" a="E"><vh>chat bar commands (onChatTextEntry)</vh>
<v t="rodrigob.20040912221032" a="E"><vh>enable/disable Chat</vh></v>
</v>
<v t="rodrigob.20040124160427"><vh>status bar commands</vh>
<v t="rodrigob.20040121153834.4"><vh>updateStatusRowCol</vh></v>
</v>
<v t="rodrigob.20040123123802" a="M"><vh>help command</vh>
<v t="rodrigob.20040123132311.1" a="E"><vh>&lt;&lt; chalks help &gt;&gt;</vh>
<v t="rodrigob.20040126020116"><vh>network graph (about Server, Client, Children, Parent, and Trees)</vh></v>
</v>
<v t="rodrigob.20040122173128" a="M"><vh>online_homepage</vh></v>
</v>
<v t="rodrigob.20040913232538"><vh>set/clear connected</vh></v>
</v>
<v t="rodrigob.20040123133012"><vh>log</vh>
<v t="rodrigob.20040123134959"><vh>log_error</vh></v>
<v t="rodrigob.20040128005315"><vh>exception</vh></v>
<v t="rodrigob.20040124165851"><vh>set_status</vh></v>
</v>
</v>
<v t="rodrigob.20040831112258.1" a="E"><vh>concurrent edition</vh>
<v t="rodrigob.20040125154815.1" a="EM"><vh>class ChalksNode</vh>
<v t="rodrigob.20040125154815.2" a="EM"><vh>connect to/disconnect from parent node</vh>
<v t="rodrigob.20040913221730" a="E"><vh>connect</vh>
<v t="rodrigob.20040909060311" a="M"><vh>start collaborating</vh></v>
</v>
<v t="rodrigob.20040913221730.1"><vh>disconnect</vh></v>
</v>
<v t="rodrigob.20040912225813" a="E"><vh>add/del sites</vh>
<v t="rodrigob.20040912225813.1" a="E"><vh>add site</vh></v>
<v t="rodrigob.20040912225813.2"><vh>del site</vh></v>
</v>
<v t="rodrigob.20040125154815.3" a="E"><vh>edit content</vh>
<v t="rodrigob.20040125154815.4" a="EM"><vh>set text</vh></v>
<v t="rodrigob.20040125154815.5"><vh>insert text</vh></v>
<v t="rodrigob.20040125154815.6" a="M"><vh>delete text</vh></v>
<v t="rodrigob.20040125154815.8" a="E"><vh>fill body</vh>
<v t="rodrigob.20040125154815.9" a="E"><vh>helpers functions</vh>
<v t="rodrigob.20040125154815.10"><vh>&lt;&lt; def index_to_list &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.11"><vh>&lt;&lt; def in_range &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.12"><vh>&lt;&lt; def range_to_pos_and_length &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.13"><vh>&lt;&lt; text was overwritten &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.14" a="E"><vh>&lt;&lt; suppression or deletion &gt;&gt;</vh>
<v t="rodrigob.20040125154815.15"><vh>&lt;&lt; update the deletion buffer &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.16"><vh>&lt;&lt; create a new deletion buffer &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.17"><vh>&lt;&lt; "normal" keys &gt;&gt;</vh></v>
<v t="rodrigob.20040125154815.18"><vh>&lt;&lt; text paste &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040125154815.19" a="M"><vh>flush body</vh></v>
<v t="rodrigob.20040125154815.7"><vh>send operation</vh></v>
</v>
<v t="rodrigob.20040127182438" a="E"><vh>remote callable methods</vh>
<v t="rodrigob.20040127184605"><vh>send message</vh></v>
<v t="rodrigob.20040920122333" a="EM"><vh>receive operation</vh></v>
</v>
</v>
<v t="rodrigob.20040121155420" a="M"><vh>ConcurrentEditableNode</vh>
<v t="rodrigob.20040128013418" a="E"><vh>__init__</vh></v>
<v t="rodrigob.20040128011816"><vh>receive operation</vh></v>
<v t="rodrigob.20040128011809" a="E"><vh>add/del site</vh>
<v t="rodrigob.20040129165804" a="EM"><vh>add site</vh>
<v t="rodrigob.20040130122927"><vh>&lt;&lt; expand the vectors and matrices &gt;&gt;</vh></v>
</v>
<v t="rodrigob.20040129165804.1" a="EM"><vh>del site</vh>
<v t="rodrigob.20040129165804.2"><vh>del clients (server)</vh></v>
</v>
</v>
<v t="rodrigob.20040128011921" a="E"><vh>network methods</vh>
<v t="rodrigob.20040128011921.1" a="E"><vh>connect to parent </vh>
<v t="rodrigob.20040130224144" a="M"><vh>old</vh></v>
<v t="rodrigob.20040129181502"><vh>get_data</vh></v>
</v>
<v t="rodrigob.20040130225705"><vh>disconnect_from_parent</vh></v>
<v t="rodrigob.20040130225148" a="EM"><vh>collaborate_in</vh>
<v t="rodrigob.20040130225208" a="M"><vh>set_state &lt;= THIS IS THE ACTUAL WORK</vh></v>
</v>
<v t="rodrigob.20040128011939"><vh>send operation</vh></v>
</v>
<v t="rodrigob.20040130225148.1" a="M"><vh>get_state</vh></v>
<v t="rodrigob.20040128012459" a="EM"><vh>collect_garbage</vh></v>
<v t="rodrigob.20040128012627"><vh>generate operations</vh></v>
<v t="rodrigob.20040909033320"><vh>set text</vh></v>
</v>
<v t="rodrigob.121403173614.1509" a="M"><vh>ConcurrentEditable</vh>
<v t="rodrigob.121403173614.1510"><vh>receive operation</vh></v>
<v t="rodrigob.121403173614.1511"><vh>apply</vh></v>
<v t="rodrigob.121403173614.1512"><vh>execute</vh>
<v t="rodrigob.121403173614.1513"><vh>insert_text</vh></v>
<v t="rodrigob.121403173614.1514"><vh>delete_text</vh></v>
</v>
<v t="rodrigob.121403173614.1515"><vh>undo</vh></v>
<v t="rodrigob.121403173614.1516" a="E"><vh>collect_garbage</vh>
<v t="rodrigob.20040121161315" a="E"><vh>update SVT</vh></v>
</v>
<v t="rodrigob.121403173614.1517"><vh>generate operations</vh></v>
</v>
<v t="rodrigob.121403173614.1547"><vh>Tests (ConcurrentEditable)</vh>
<v t="rodrigob.121403173614.1548"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.121403173614.1549"><vh>TestConcurrentEditable2</vh></v>
<v t="rodrigob.121403173614.1550"><vh>TestConcurrentEditableServer</vh></v>
<v t="rodrigob.20040121155542"><vh>TestConcurrentEditableNode</vh>
<v t="rodrigob.20040128013509"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.20040128013523"><vh>TestConcurrentEditableServer</vh></v>
</v>
</v>
</v>
</v>
<v t="rodrigob.20040119132914" a="E"
marks="rodrigob.20040119152542,rodrigob.20040123131236,rodrigob.20040125150558,rodrigob.20040125153141,rodrigob.20040125200531,rodrigob.20040123131236.1,rodrigob.20040129131141,rodrigob.20040125204408,rodrigob.20040123123802.1,rodrigob.20040123133928,niederberger.20040911130819,rodrigob.20040125213003,rodrigob.20040123123802,rodrigob.20040122173128,rodrigob.20040125154815.1,rodrigob.20040125154815.2,rodrigob.20040909060311,rodrigob.20040125154815.4,rodrigob.20040125154815.6,rodrigob.20040125154815.19,rodrigob.20040920122333,rodrigob.20040125194534,rodrigob.20040126020641,"
expanded="rodrigob.20040119133203,rodrigob.20040119152542,rodrigob.20040125153141,rodrigob.20040123142302,rodrigob.20040121151612,rodrigob.20040122173046,rodrigob.20040123123802.1,rodrigob.20040125210836,rodrigob.20040123124005,rodrigob.20040124184444,rodrigob.20040125154636,rodrigob.20040123130224,rodrigob.20040121150952.7,rodrigob.20040123134358,rodrigob.20040121153312,rodrigob.20040123132311.1,rodrigob.20040125154815.2,rodrigob.20040913221730,rodrigob.20040912225813,rodrigob.20040125154815.3,rodrigob.20040125154815.8,rodrigob.20040125154815.9,rodrigob.20040125154815.14,rodrigob.20040127182438,rodrigob.20040125194534,rodrigob.20040915120517,"><vh>@thin Chalks.py</vh></v>
<v t="rodrigob.121403173614.1502"
marks="rodrigob.121403173614.1509,rodrigob.121403173614.1532,rodrigob.121403173614.1533,rodrigob.121403173614.1535,rodrigob.121403173614.1536,rodrigob.121403173614.1544,rodrigob.20040121155420,rodrigob.20040129165804,rodrigob.20040129165804.1,rodrigob.20040130224144,rodrigob.20040130225148,rodrigob.20040130225208,rodrigob.20040130225148.1,rodrigob.20040128012459,"
expanded="rodrigob.121403173614.1503,rodrigob.121403173614.1508,rodrigob.121403173614.1516,rodrigob.121403173614.1530,rodrigob.121403173614.1531,rodrigob.121403173614.1537,rodrigob.121403173614.1540,rodrigob.121403173614.1541,rodrigob.20040121154800,rodrigob.20040128011809,rodrigob.20040129165804,rodrigob.20040129165804.1,rodrigob.20040128011921,rodrigob.20040128011921.1,rodrigob.20040130225148,"><vh>@thin ConcurrentEditable.py</vh></v>
<v t="rodrigob.20040912220039"
marks="rodrigob.20040912220039.14,rodrigob.20040912220039.15,rodrigob.20040912220039.16,rodrigob.20040912220039.17,rodrigob.20040912220039.18,rodrigob.20040912220039.19,rodrigob.20040912220039.21,rodrigob.20040912220039.22,rodrigob.20040912220039.23,rodrigob.20040912220039.25,rodrigob.20040912220039.26,rodrigob.20040912220039.27,rodrigob.20040912220039.28,rodrigob.20040912220039.29,rodrigob.20040912220039.30,rodrigob.20040912220039.31,rodrigob.20040912220039.32,rodrigob.20040912220039.33,rodrigob.20040912220039.34,rodrigob.20040912220039.35,rodrigob.20040912220039.37,rodrigob.20040912220039.38,rodrigob.20040912220039.39,rodrigob.20040912220039.40,rodrigob.20040912220039.42,rodrigob.20040912220039.43,rodrigob.20040912220039.44,rodrigob.20040912220039.45,rodrigob.20040912220039.47,rodrigob.20040912220039.48,rodrigob.20040912220039.49,rodrigob.20040912220039.50,rodrigob.20040912220039.52,rodrigob.20040912220039.53,rodrigob.20040912220039.54,rodrigob.20040912220039.55,rodrigob.20040912220039.57,rodrigob.20040912220039.58,rodrigob.20040912220039.59,rodrigob.20040912220039.60,rodrigob.20040912220039.62,rodrigob.20040912220039.63,rodrigob.20040912220039.64,rodrigob.20040912220039.65,rodrigob.20040912220039.66,rodrigob.20040912220039.67,rodrigob.20040912220039.68,rodrigob.20040912220039.69,rodrigob.20040912220039.70,rodrigob.20040912220039.71,rodrigob.20040912220039.72,rodrigob.20040912220039.73,rodrigob.20040912220039.75,rodrigob.20040912220039.76,rodrigob.20040912220039.77,rodrigob.20040912220039.78,rodrigob.20040912220039.79,rodrigob.20040912220039.80,rodrigob.20040912220039.81,rodrigob.20040912220039.82,rodrigob.20040912220039.83,rodrigob.20040912220039.84,rodrigob.20040912220039.85,rodrigob.20040912220039.86,rodrigob.20040912220039.87,rodrigob.20040912220039.88,rodrigob.20040912220039.89,rodrigob.20040912220039.90,rodrigob.20040912220039.92,rodrigob.20040912220039.93,rodrigob.20040912220039.94,rodrigob.20040912220039.95,rodrigob.20040912220039.96,rodrigob.20040912220039.97,rodrigob.20040912220039.98,rodrigob.20040912220039.100,rodrigob.20040912220039.101,rodrigob.20040912220039.102,rodrigob.20040912220039.103,rodrigob.20040912220039.104,rodrigob.20040912220039.105,rodrigob.20040912220039.107,rodrigob.20040912220039.108,rodrigob.20040912220039.110,rodrigob.20040912220039.111,rodrigob.20040912220039.113,rodrigob.20040912220039.114,rodrigob.20040912220039.115,rodrigob.20040912220039.116,rodrigob.20040912220039.118,rodrigob.20040912220039.119,rodrigob.20040912220039.120,rodrigob.20040912220039.121,rodrigob.20040912220039.122,rodrigob.20040912220039.123,rodrigob.20040912220039.124,rodrigob.20040912220039.125,rodrigob.20040912220039.126,rodrigob.20040912220039.127,rodrigob.20040912220039.128,rodrigob.20040912220039.129,rodrigob.20040912220039.130,rodrigob.20040912220039.131,rodrigob.20040912220039.132,rodrigob.20040912220039.133,rodrigob.20040912220039.134,rodrigob.20040912220039.136,rodrigob.20040912220039.137,rodrigob.20040912220039.138,rodrigob.20040912220039.139,rodrigob.20040912220039.140,rodrigob.20040912220039.141,rodrigob.20040912220039.142,rodrigob.20040912220039.143,rodrigob.20040912220039.144,rodrigob.20040912220039.145,rodrigob.20040912220039.146,rodrigob.20040912220039.147,rodrigob.20040912220039.148,rodrigob.20040912220039.149,rodrigob.20040912220039.150,rodrigob.20040912220039.151,rodrigob.20040912220039.152,rodrigob.20040912220039.153,rodrigob.20040912220039.154,"
expanded="rodrigob.20040912220039.13,"><vh>@thin Rendezvous.py</vh></v>
<v t="rodrigob.20040125151012"><vh>@thin Chalks.xhtml</vh></v>
<v t="rodrigob.20040912211519"><vh>Tests</vh>
<v t="rodrigob.20040125173910"><vh>@thin Test_Chalks.py</vh></v>
<v t="rodrigob.20040912211426"
expanded="rodrigob.20040912211426.2,"><vh>@thin Test_ChalksServerMonitor.py</vh></v>
<v t="rodrigob.121403173614.1547"><vh>Tests (ConcurrentEditable)</vh>
<v t="rodrigob.121403173614.1548"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.121403173614.1549"><vh>TestConcurrentEditable2</vh></v>
<v t="rodrigob.121403173614.1550"><vh>TestConcurrentEditableServer</vh></v>
<v t="rodrigob.20040121155542"><vh>TestConcurrentEditableNode</vh>
<v t="rodrigob.20040128013509"><vh>TestConcurrentEditable1</vh></v>
<v t="rodrigob.20040128013523"><vh>TestConcurrentEditableServer</vh></v>
</v>
</v>
</v>
<v t="rodrigob.20040129132740"><vh>docs</vh>
<v t="rodrigob.20040129130513.1"><vh>Unicode utils...</vh>
<v t="rodrigob.20040129130513.2"><vh>isUnicode</vh></v>
<v t="rodrigob.20040129130513.3"><vh>isValidEncoding</vh></v>
<v t="rodrigob.20040129130513.4"><vh>reportBadChars</vh></v>
<v t="rodrigob.20040129130513.5"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="rodrigob.20040129130513.6"><vh>getpreferredencoding from 2.3a2</vh>
<v t="rodrigob.20040129130513.7"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="rodrigob.20040129130513.8"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.20040123132311.1" a="E"><vh>&lt;&lt; chalks help &gt;&gt;</vh>
<v t="rodrigob.20040126020116"><vh>network graph (about Server, Client, Children, Parent, and Trees)</vh></v>
</v>
<v t="rodrigob.122403220526.1" a="E"><vh>developers docs</vh>
<v t="niederberger.20040825214919" a="E"><vh>old (from LeoN)</vh>
<v t="niederberger.20040825221501"><vh>&lt;&lt; LeoNtest docs &gt;&gt; (about LeoN tests)</vh>
<v t="niederberger.20040825221501.1"><vh>&lt;&lt; usage &gt;&gt;</vh></v>
</v>
<v t="niederberger.20040825221453"><vh>About security and permissions</vh>
<v t="niederberger.20040825221453.1"><vh>&lt;&lt; admingui help &gt;&gt; (for administrators)</vh>
<v t="niederberger.20040825221453.2"><vh>see image misc/admin_gui.png</vh></v>
</v>
</v>
<v t="niederberger.20040825221442"><vh>Outline transfer format</vh></v>
<v t="niederberger.20040825221401" a="E"><vh>About the LeoChecker, LeoAvatar, and where is the Realm hidden</vh>
<v t="niederberger.20040825221401.1" a="E"><vh>Server login (server side login classes)</vh>
<v t="niederberger.20040825221401.2"><vh>class LeoChecker</vh></v>
<v t="niederberger.20040825221401.3"><vh>class LeoAvatar</vh></v>
<v t="niederberger.20040825221401.4"><vh>requestAvatar (CollaborativeOutline.requestAvatar)</vh></v>
<v t="niederberger.20040825221401.5" a="E"><vh>Perspectives</vh>
<v t="niederberger.20040825221401.6" a="E"><vh>class OutlinePerspective</vh>
<v t="niederberger.20040825221401.7"><vh>Own account editing</vh></v>
<v t="niederberger.20040825221401.8"><vh>Messages and presence methods</vh></v>
<v t="niederberger.20040825221401.9" a="E"><vh>Outline editing methods</vh>
<v t="niederberger.20040825221401.10"><vh>helpers functions (data&lt;-&gt;outline)</vh>
<v t="niederberger.20040825221401.11"><vh>outline_to_data</vh></v>
<v t="niederberger.20040825221401.12"><vh>data_to_outline</vh></v>
</v>
<v t="niederberger.20040825221401.13"><vh>get outline</vh></v>
<v t="niederberger.20040825221401.14"><vh>select node</vh></v>
<v t="niederberger.20040825221401.15"><vh>Edit tree (class OutlinePerspective)</vh>
<v t="niederberger.20040825221401.16"><vh>base operations</vh>
<v t="niederberger.20040825221401.17"><vh>create_node</vh></v>
<v t="niederberger.20040825221401.18"><vh>create_clone</vh></v>
<v t="niederberger.20040825221401.19"><vh>delete_node</vh></v>
<v t="niederberger.20040825221401.20"><vh>move_node</vh>
<v t="niederberger.20040825221401.21"><vh>&lt;&lt; check permissions &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.22"><vh>&lt;&lt; check locks &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.23"><vh>&lt;&lt; apply &gt;&gt;</vh></v>
<v t="niederberger.20040825221401.24"><vh>&lt;&lt; propagate &gt;&gt;</vh></v>
</v>
</v>
<v t="niederberger.20040825221401.25"><vh>upload outline</vh></v>
<v t="niederberger.20040825221401.26"><vh>download outline</vh></v>
</v>
<v t="niederberger.20040825221401.27" a="E"><vh>Edit nodes</vh>
<v t="niederberger.20040825221401.28"><vh>lock/unlock</vh></v>
<v t="niederberger.20040825221401.29"><vh>update node</vh></v>
<v t="niederberger.20040825221401.30"><vh>collaborate in/out</vh></v>
<v t="niederberger.20040825221401.31"><vh>receive_op</vh>
<v t="niederberger.20040825221401.32"><vh>insert/delete text</vh></v>
</v>
</v>
</v>
</v>
<v t="niederberger.20040825221401.33"><vh>class AdminOutlinePerspective</vh>
<v t="niederberger.20040825221401.34"><vh>accounts</vh></v>
<v t="niederberger.20040825221401.35"><vh>permissions</vh></v>
</v>
</v>
</v>
</v>
<v t="niederberger.20040825215445" a="E"><vh>About client and server objects</vh></v>
<v t="rodrigob.121403173614.57" a="E"><vh>General view of the system</vh>
<v t="rodrigob.010104211709"><vh>see image misc/leon_scheme.png</vh></v>
</v>
</v>
<v t="niederberger.20040825221442.1"><vh>text difference transfer format</vh></v>
<v t="rodrigob.010104212717"><vh>networking requirements</vh>
<v t="rodrigob.121403173614.21"><vh>Leo over network requirements (original post)</vh>
<v t="rodrigob.121403173614.22" a="E"><vh>&lt;&lt; Step one, Merging &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.23" a="E"><vh>&lt;&lt; Step two, Publishing &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.24" a="E"><vh>&lt;&lt; Step three, Interacting by turns &gt;&gt;</vh></v>
<v t="rodrigob.121403173614.25" a="E"><vh>&lt;&lt; Step four, Realtime interaction &gt;&gt;</vh></v>
</v>
</v>
<v t="rodrigob.121403173614.58"><vh>Code explanation</vh>
<v t="rodrigob.010104213529"><vh>&lt;&lt; notation &gt;&gt;</vh></v>
</v>
<v t="niederberger.20040906222819"><vh>General view of the system</vh></v>
<v t="rodrigob.121403173614.66" a="E"><vh>About client and server objects</vh></v>
<v t="rodrigob.121403173614.1506"><vh>ConcurrentEditable algorithm explanation</vh></v>
<v t="rodrigob.121403173614.60"><vh>About ConcurrentEditableClient and ConcurrentEditableServer</vh></v>
<v t="rodrigob.121403173614.37"><vh>Release file tree</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="niederberger.20040825214919"></t>
<t tx="niederberger.20040825215445">This node provide a little overview of the classes instances and they hierarchy.
Superior lines include inferior (lower level) items.

Client Machine
has a Leo process 
    has a LeoN Plugin (that install a twisted reactor under the hood of the Leo process)
        has a LeoClient class instance (one per @leoServer outlines)
            after connection LeoClient has a RemoteReference of the OutlinePerspective instance on the server (attribute .perspective)
                after connection to a collaboration node, 
                LeoClient instance get an instance of the ClientNode class (subclass of ConcurrentEditableClient) (.client_node attribute)


Server Machine
has a LeoNServer process
    has a service.Application class instance
        has a CollaborativeOutline class instance (is a Realm too (provide LeoAvatars))
            has a LeoChecker instance
            has a CollaborativeNode class instances (and childrens are linked to him)
                is a ConcurrentEditableServer subclass
        has a LeoServerWeb instance

Each Leo client connection on the server create a LeoAvatar. LeoAvatar provide access to OutlinePerspective and AdminOutlinePerspective. This two perspectives centralize all the comunication between clients and the server.</t>
<t tx="niederberger.20040825221401">Look at the "Server login" code perspective body.</t>
<t tx="niederberger.20040825221401.1">@
In this perspective you will find the Server Login classes and methods.

The server login system use the Twisted Cred system. Look at the twisted documentation for the Cred HowTo, the documentation explain in detail the concepts, relations and possiblities.

Essencially the login is composed of three elements, the Realm that provide Avatars after checking the autorization. The Checker is an autenthifiaction object. An the Avatar is a remote perspective of the server (the client possibilities in the server space).

Being smart, and to avoid to many short classes, the Realm is embedded in the CollaborativeOutline server structure.
To persist his data and to maintain a logic object hierarchy the CollaborativeOutline instance "has-a" .checker instance.

CollaborativeOutline is a collaborative outline and is a Realm and has a LeoChecker.
@c</t>
<t tx="niederberger.20040825221401.2">class LeoChecker:
    """
    An ultra simple Leo checker.
    Implement management methods.
    
    (should be edited in order to be able to persist)
    """
    # look at ./twisted/test/test_newcred.py for hash usage examples
    
    __implements__ = checkers.ICredentialsChecker

    credentialInterfaces = (credentials.IUsernamePassword, credentials.IUsernameHashedPassword)

    def __init__(self, **users):
        self.users = users # users is a dictionary of username-&gt;password mapping
        return

    def userExist(self, username):
        return self.users.has_key(username)
        
    def addUser(self, username, password):
        self.users[username] = password
        
    def delUser(self, username):
        del self.users[username]
        
    def setPassword(self, username, password):
        self.users[username] = password

    def _cbPasswordMatch(self, matched, username):
        if matched:
            return username
        else:
            return failure.Failure(error.UnauthorizedLogin("The password of %s did not matched with database." % username))

    def requestAvatarId(self, credential):		
        if credential.username in self.users:
            return defer.maybeDeferred(credential.checkPassword, self.users[credential.username]).addCallback(self._cbPasswordMatch, credential.username)
        else:
            return failure.Failure(error.UnauthorizedLogin("%s is not listed in the authorized users." % credential.username))
</t>
<t tx="niederberger.20040825221401.3">class LeoAvatar(pb.Avatar):
    """
    The server side representation of the user.
    There is one avatar instance per client connection to the server
    """
    
    def __init__(self, avatarId, mind, outline=None):
        
        self.Outline = outline # the outline contain a .checker attribute
        self.perspectives = []
        self.mind = mind # store it for later use
        self.avatarId = avatarId
        
        assert mind, LeoError("LeoN strictly require references to the client connecting.")
        
        #pb.Avatar.__init__(self, avatarId, mind) # pb.Avatar has no __init__ method.
        
        return  
    
    def perspective_get_perspective(self, kind, base_node_url):
        """
        """
        perspective = None
        
        if kind == "outline":
            perspective = OutlinePerspective(self.avatarId, base_node_url, self.Outline, self.mind)
           
        elif kind == "admin_outline":
            perspective = AdminOutlinePerspective(self.avatarId, base_node_url, self.Outline, self.mind)
            
        else:
            raiseLeoError("unknown perspective requested")
        
        if perspective:
            self.perspectives.append(perspective) # are there really more than one perspective per avatar ?
        
        return perspective
        
        
    def logout(self,):
        """
        Detach the requested perspectives.
        """
        
        #print "Avatar is login out self.avatarId == %s" % self.avatarId # just for debugging
        
        for t_perspective in self.perspectives:
            t_perspective.logout()
        
        del self.perspectives
            
        return

    
    
    



</t>
<t tx="niederberger.20040825221401.4">def requestAvatar(self, avatarId, mind, *interfaces):
    """
    The user have been authenticated and it is requesting an Avatar.
    """
    if pb.IPerspective not in interfaces:
        raise NotImplementedError	
    
    avatar = LeoAvatar(avatarId, mind, self) # one avatar instance per conection

    return pb.IPerspective, avatar , avatar.logout # implemented interface reference, interface instance, logout method

</t>
<t tx="niederberger.20040825221401.5"></t>
<t tx="niederberger.20040825221401.6">class OutlinePerspective(pb.Referenceable):
    """
    This class present a external access to an outline branch.
    This are the method that the client can access in the server space.
    The OutlinePerspective attach itself to the outline
    """
    
    # __init__ is a merge of old init and attach

    def __init__(self, name, base_node_url, outline, clientref):
        #pb.Referenceable.__init__(self) # pb.Referenceable  has no __init__ method
                
        self.Outline  = outline	# the internal Outline is capitalized because it make reference at the Server instance. (so ?)
        if not self.Outline:
            raise LeoError("Cannot attach a client if no CollaborativeOutline instance is attached to the Perpective (bug of the Service).")

        # store the perspective reference Node. Once logged we only have access to the Downside nodes.
        self.base_path = base_node_url
        self.base_node = self.Outline.get_node(base_node_url)
        assert self.base_node, LeoError("Could not found the reference node (base_node_url '%s')"% base_node_url)
        
        self.selected_node  = None
        self.selected_node_path = base_node_url
        self.local_permissions = [] # the permissions associated to the local nodes
        

        self.name     = name
        self.client   = clientref
        self.status   = "online"
        
        # attach to the CollaborativeOutline
        if self.Outline.users.has_key(self.name):
            self.Outline.users[self.name].append(self)
        else:
            self.Outline.users[self.name]= [ self ] # important, the outline manage a dictionary of lists of users perspective (an user user can be logged more than once at different point with one or more clients.)
            
        
        # attach us to the base node        
        if self.base_node.base_node_of.has_key(self.name):
            self.base_node.base_node_of[self.name].append(self)
        else:
            self.base_node.base_node_of[self.name] = [self]
        
        
        # attach us to the selected node
        self.selected_node = self.Outline.get_node(self.base_path)
                
        if self.selected_node.users.has_key(self.name):
            self.selected_node.users[self.name].append(self)
        else:
            self.selected_node.users[self.name] = [self]
            
            

        # set presence
        self.remote_set_presence("online")
        
        
        self.client.callRemote("post_message", "LeoServer", 
                                           "%s, you are welcome to the system."%(self.name.capitalize())).addErrback(raiseMessageError, self.name)
    
        return

        
    def logout(self,):
        """
        A client is closing his relation with this perspective (i.e. this outline).
        """
        
        print "%s at %s is login out." % (self.name, self.base_path)
        
        self.remote_collaborate_out() # collaborate_out (will do nothing if was not collaborating)
            
        #  dettach us from the selected node        
        self.selected_node.users[self.name].remove(self)
        if not self.selected_node.users[self.name]: # if there are no more clients connected
            del self.selected_node.users[self.name]  # forget our name
            
        # dettach from the CollaborativeOutline
        self.Outline.users[self.name].remove(self)
        if not self.Outline.users[self.name]: # if there are no more clients connected
            del self.Outline.users[self.name]  # forget our name
            
        #  dettach us from the base node        
        if self.base_node.base_node_of.has_key(self.name):
            self.base_node.base_node_of[self.name].remove(self)
        if not self.base_node.base_node_of[self.name]:
            del self.base_node.base_node_of[self.name]
        

        
        return
        

    @others

</t>
<t tx="niederberger.20040825221401.7">def remote_change_password(self, newpassword):
    """
    Let the users change they password.
    """
    
    self.Outline.checker.setPassword(self.name, newpassword)

    self.client.callRemote("post_message", "LeoServer", "Own password; updated.").addErrback(raiseMessageError, self.name)		
    return</t>
<t tx="niederberger.20040825221401.8">
def remote_get_actual_users_list(self, ):
    """ 
    Return the list of the logged users and they state.
    """
    
    t_list = map(lambda x: (x, self.outline.users[x].status),self.Outline.users.keys())
    
    return t_list
    
    
def remote_set_presence(self, state):
    """
    Set the presence of one user 
    """
    
    self.status = state
    
    for t_list in self.Outline.users.values(): # a list of client references
        for t_value in t_list:
            t_value.client.callRemote("post_presence", self.name, state).addErrback(raiseLeoError, "could not post your presence to %s"%(t_value.name))
    
    return

def remote_send_message(self, to, txt):
    """ 
    Send a message to
    """
    
    if to == "_everyone":
        for t_list in self.Outline.users.values():
            for t_value in t_list:
                t_value.client.callRemote("post_message", self.name, txt).addErrback(raiseMessageError, t_value.name)
        return

    if to == "_room":
        for t_list in self.selected_node.users.values():
            for t_value in t_list:
                t_value.client.callRemote("post_message", self.name, txt).addErrback(raiseMessageError, t_value.name)
        return
    
    
    if not self.Outline.users.has_key(to):
        raise LeoError("The user '%s' is not logged into this outline."%(to))
        #raise LeoError("The user '%s' is not logged into this outline. %s"%(to, str(self.Outline.users))) # just for debugging
    
    for t_perspective in self.Outline.users[to]:
        t_perspective.client.callRemote("post_message", self.name, txt).addErrback(raiseMessageError, self.name)
        
    return</t>
<t tx="niederberger.20040825221401.9">@
Add the logic of the distributed application and then call the native Outline method.
@c

</t>
<t tx="niederberger.20040825221401.10">@
Server side, data&lt;-&gt;outline transformation
@c</t>
<t tx="niederberger.20040825221401.11">def outline_to_data(self, parent_node):
    """
    Recieve a node instance and return a list in the format.
    ([node1_instance, node2_instance, ..], [0, 1, 2, [4, 1], 5, 2, 6, ..])
    Clones suboutlines appears only once (node '2' in the previous example) 
    Used as a helper function to construct the data to send.
    parent_node is also included in the result.
    """
        
    # inner helper recursive function ---------------------------
    def level_list(childrens, t_dic):
        t_list = []
        for t_node in childrens:
            if not t_dic.has_key(t_node): # if not in the dic
                t_dic[t_node] = len(t_dic) # add it, with his index
                
            t_list.append(t_dic[t_node]) # add the entry
            
            if t_node.childrens and t_dic[t_node] == (len(t_dic) - 1): # if has childrens, and it is the first appearance
                t_list.append(level_list(t_node.childrens, t_dic)) # add the new level, recursivelly
            
            # lets continue with the actual level 
        
        return t_list # tada... easy
    # end of inner recursive function ----------------------------
    
    t_dic = {parent_node:0}	
    nodes_hierarchy = [0, level_list(parent_node.childrens, t_dic)]
    nodes_list = range(len(t_dic))
    for t_node, pos in t_dic.items():
        nodes_list[pos] = t_node

    return (nodes_list, nodes_hierarchy)</t>
<t tx="niederberger.20040825221401.12">def data_to_outline(self, parent, nodes_list, nodes_hierarchy, t_dic):
    """
    Receive data in the format ([(name, body), (name,body), ...], [0 1 [2 3 1] 4])
    and append the new nodes to the parent.
    If the parent already has childrens, will add them to the last position.
    t_dic contain a map of "already scanned indexes" -&gt; node_instance object. This allow to create the required clones.
    Recursive function.
    """
 
    NodeClass = self.Outline.nodeClass #NodeClass( parent_node=None, position=-1, name="New CollaborativeNode", text=""):
    last_node = parent
    
    for t_item in nodes_hierarchy:
        
        if type(t_item) is int:
          
            if not t_dic.has_key(t_item): # if not already created, create a new node
                #print t_item, len(nodes_list), nodes_list # just for debugging
                t_name, t_text = nodes_list[t_item]
                last_node = NodeClass(parent, position=-1, name=t_name, text=t_text) # new node
                t_dic[t_item] = last_node
            else: # the node already was created, now we should create a clone of it.
                twin = t_dic[t_item]
                self.Outline.create_clone(twin, parent, position=-1) #create_clone(twin, parent, position=-1):
                last_node = twin 
                
        elif type(t_item) in [list, tuple]:
            self.data_to_outline(last_node, nodes_list, t_item, t_dic) # recursive call for the next level
            
        else:
            self.es_error("&lt;LeoClient Error&gt; The nodes hierarchy in the uploaded data contain an unmanageable object of type %s"%( type(t_item)))
    
    
    return


</t>
<t tx="niederberger.20040825221401.13">
def remote_get_outline(self,):
    """
    Return a copy own perspective outline branch.
    The format is
    (["name1", "name2", ..], [0, 1, 2, [4, 1], 5, 6, ..])
    """
    
    base_node = self.Outline.get_node(self.base_path)
    assert base_node, LeoError("Could not find the base_node (base_path '%s')" % self.base_path)
        
    nodes_list, nodes_hierarchy = self.outline_to_data(base_node) # format ([node1_instance, node2_instance, ..], [0, 1, 2, [4, 1], 5, 6, ..])
    nodes_list = map(lambda x:x.name, nodes_list) 

    return (nodes_list, nodes_hierarchy) # tada... so easy.

</t>
<t tx="niederberger.20040825221401.14">def remote_select_node(self, path):
    """
    Set our selected node and
    return the content of the selected node.
    """
    
    t_node = self.Outline.get_node(path)
    
    if not t_node:
        raiseLeoError("Could not found the required node. (%s)"%(path))
        return
    
    self.selected_node_path = path
    # if actual node is locked, unlock it
    if self.selected_node.is_locked == self.name:
        self.remote_unlock_selected_node()
        
    # dettach from previous node
    try:
        self.selected_node.users[self.name].remove(self)
    except:
        # we where not attached to the previous node....
        pass
    
    # select the new node
    self.selected_node = t_node
    
    # attach us
    if self.selected_node.users.has_key(self.name):
        self.selected_node.users[self.name].append(self)
    else:
        self.selected_node.users[self.name] = [self]
    
    # obtain the contents of the selected node
    content = self.selected_node.get_text()
    
    return content
</t>
<t tx="niederberger.20040825221401.15">@
Each instance is responsable of his task, to check permissions and to propagate the event to the other clients.
@c

def absolute_path(self, relative_node_path): 
    """
    transforme a relative path to a valid server url
    """
    assert type(relative_node_path) is unicode, LeoError("Received relative paths have to be unicode (received type %s)" % type(relative_node_path))
    return self.base_path + relative_node_path[1:]	



</t>
<t tx="niederberger.20040825221401.16">@
The set of base operations that allow any desirable tree modification.
@c</t>
<t tx="niederberger.20040825221401.17">def remote_create_node(self, path, text=u"", position=-1):
    """ 
    The perspective receive relatives paths (relatives to the self perspective).
    The CollaborativeOutline receive absolutes paths.
    """

    t_list = self.Outline.path_to_list(self.absolute_path(path))
        
    parent_path, name = t_list[:-1], t_list[-1]
    parent_node       = self.Outline.get_node(parent_path)
    
    if not parent_node:
        raiseLeoError("Could not found the parent of the new node  (%s)"%(parent_path) )
        return
        
    # check if authorized to edit the tree
    local_permissions = self.Outline.get_permissions(self.name, parent_path)

    if "Tree_edit" not in local_permissions:
        raise Unauthorized, "You are not allowed to edit this tree. (your local permissions are %s)"%(local_permissions)
        
    # check if the tree is not locked
    # regulation: node creation have no restrictions

    # apply	
    self.Outline.create_node(parent_node, name=name, text=text, position=position)
    
        
    # propagate. only two cases, will see it, will not see it. Easy. -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    
    # obtain the perspectives related to this event
    t_dic = self.Outline.get_upward_perspectives(parent_node) # return a dic of 'perspective'-&gt;"relative_path"
    
    for t_perspective, t_rpath in t_dic.items():
        t_rpath = "%s/%s" % ( t_rpath, name) 
        t_perspective.client.callRemote("create_node", t_rpath, position) # propagate the event to other clients

    
    return</t>
<t tx="niederberger.20040825221401.18">def remote_create_clone(self, twin_path, parent_path, position=-1):
    """ 
    The perspective methods receive relatives paths (relatives to the self perspective).
    """

    twin_path   = self.absolute_path(twin_path)
    parent_path = self.absolute_path(parent_path)
    
    twin   = self.Outline.get_node(twin_path)
    parent = self.Outline.get_node(parent_path)

    # check existance
    assert twin, LeoError("Could not find the twin")
    assert parent, LeoError("Could not find the parent")

    # check permissions
    local_permissions = self.Outline.get_permissions(self.name, parent_path)
    if "Tree_edit" not in local_permissions:
        raise Unauthorized, "You are not allowed to edit this tree. (your local permissions are %s)"%(local_permissions)

    local_permissions = self.Outline.get_permissions(self.name, twin_path)
    if "Read" not in local_permissions:
        raise Unauthorized, "You are not allowed to read the node to clone. (your local permissions are %s)"%(local_permissions)

    # check recursive outline construction
    assert twin != parent and twin not in  self.Outline.get_upward_nodes(parent), LeoError("Recursive graphs are not allowed, Leo(N) only accept Acyclic Graphs.\nTwin node '%s' is parent of the node '%s'." % (twin_path, parent_path))
    
    # create the clone -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    self.Outline.create_clone(twin, parent, position)
    
    # propagate -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    # three cases: will see it, will see it as a node creation, will not see it. simple but non trivial.
    
    twin_perspectives   = self.Outline.get_upward_perspectives(twin)   # return a dic of 'perspective'-&gt;"relative_path"    
    parent_perspectives = self.Outline.get_upward_perspectives(parent) # return a dic of 'perspective'-&gt;"relative_path"
    
    for t_perspective, t_rpath in parent_perspectives.items():
        if twin_perspectives.has_key(t_perspective): # if user see the parent of new node and the root twin
            # he will see a clone
            t_twin_rpath = twin_perspectives[t_perspective]
            t_perspective.client.callRemote("create_clone", t_rpath, t_twin_rpath, position) # propagate the event to other clients
        else: # only see the parent, but not the original node
            # he will see a new node (not cloned)
            t_rpath = t_rpath + '/' + twin.name
            t_perspective.client.callRemote("create_node", t_rpath, position) # propagate the event to other clients  


    return</t>
<t tx="niederberger.20040825221401.19">def remote_delete_node(self, node_path):
    """ 
    The perspective receive relatives paths (relatives to the self perspective).
    """

    node_path = self.absolute_path(node_path) 
    
    if node_path == "/": #node == self.Outline.root_node:
        raise Unauthorized, "The Root Node is unerasable."
        
    # check if authorized to edit the tree
    local_permissions = self.Outline.get_permissions(self.name, node_path)
    if "Tree_edit" not in local_permissions:
        raise Unauthorized, "You are not allowed to edit this tree. (your local permissions are %s)"%(local_permissions)


    node = self.Outline.get_node(node_path)
    
    # check if the tree is not locked
    # regulation: only nodes that no one is editing can be erased
    
    # helper recursive function ----
    def check_no_other_users(t_node):
        if t_node.users.values() != [] and t_node.users.values() != [[self]]:
            raiseLeoError("Nodes being edited by other users can not be erased.")
            return
        if t_node.base_node_of:
            raiseLeoError("This node is the base node of %s so it can not be deleted." % t_node.base_node_of.keys() )
            return
        for t_child in t_node.childrens:
            check_no_other_users(t_child)
                    
        return
    # end of helper recursive function ----
    
    check_no_other_users(node) # will raise an exception if there are problems

    # obtain the perspectives related to this event (need to do this *before* deleting the node)
    t_dic = self.Outline.get_upward_perspectives(node) # return a dic of 'perspective'-&gt;"relative_path"

    # apply
    self.Outline.delete_node(node)

    # propagate the event to all the interested users: every user that register an access from parent to upstairs
    # only two cases, will see it, will not see it.
        
    for t_perspective, t_rpath in t_dic.items(): 
        t_perspective.client.callRemote("delete_node", t_rpath) # propagate the event to other clients

    return

</t>
<t tx="niederberger.20040825221401.20">    
    
def remote_move_node(self, node_path, new_path, position=-1):
    """ 
    The perspective receive relatives paths (relatives to the self perspective).
    Allow move, a renaming+move
    """

    node_path  = self.absolute_path(node_path)
    new_path   = self.absolute_path(new_path)
    
    try:
        t_list     = filter(lambda x:x, new_path.split('/')) 
        new_parent_lpath = t_list[:-1] #lpath is a list path
        new_parent_path = u'/' + '/'.join(new_parent_lpath)
        new_name   = t_list[-1]
    except:
        LeoError("Could no separate the parent and the new node name. (new_path %s)" % new_path) 
    
    old_name   = filter(lambda x:x, node_path.split('/'))[-1]


    &lt;&lt; check permissions &gt;&gt;
    &lt;&lt; check locks &gt;&gt;
    &lt;&lt; apply &gt;&gt;
    &lt;&lt; propagate &gt;&gt;

    return
    
</t>
<t tx="niederberger.20040825221401.21"># check if authorized to edit the tree -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
permissions = self.Outline.get_permissions(self.name , node_path)
if "Tree_edit" not in permissions:
    raise Unauthorized, "%s not allowed to move the requested node. (permissions %s at '%s')"%(self.name.capitalize(), permissions, node_path)

permissions = self.Outline.get_permissions(self.name , new_parent_path)
if "Tree_edit" not in permissions:
    raise Unauthorized, "%s not allowed to edit the tree associated to the new node position. (permissions %s at '%s')"%(self.name.capitalize(), permissions, new_parent_path)


# check nodes existance -:-:-:-:-:-
node = self.Outline.get_node(node_path)    
if not node:
    raiseLeoError("Could not found the node to move (and rename). (node_path '%s')"% node_path)

old_parent_path = '/'.join(node_path.split('/')[:-1])
old_parent = self.Outline.get_node(old_parent_path)
assert old_parent, LeoError("Could not find the old parent (parent_path '%s')" % old_parent_path)


new_parent = self.Outline.get_node(new_parent_path)
assert new_parent, LeoError("Could not find the new parent (parent_path '%s')" % new_parent_path)


# check recursive outline construction
assert node != new_parent and node not in self.Outline.get_upward_nodes(new_parent), LeoError("Recursive graphs are not allowed, Leo(N) only accept Acyclic Graphs.\nMoved node '%s' is parent of the destination node '%s'." % (node_path, new_parent_path))
</t>
<t tx="niederberger.20040825221401.22"># check if the tree is not locked -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-


# regulation: no one has to be editing the node during edition because for some users a node move can be seen as a deletion.
    
# future regulation: the node and their descendant can only be edited by users that view both the old_path and the new_path. If not some user will see that they actual edition node is deleted, that inasceptable. (too complicated to implement in the first version, KISS)
    
# helper recursive function ----
def check_no_other_users(t_node):
    if t_node.users.values() != [] and t_node.users.values() != [[self]]:
        raiseLeoError("Nodes being edited by other users can not be erased. (detected the presence of %s)"%(t_node.users.keys()))
        return
    for t_child in t_node.childrens:
        check_no_other_users(t_child)
                            
    return
# end of helper recursive function ----

check_no_other_users(node) # will raise an exception if there are problems
</t>
<t tx="niederberger.20040825221401.23">
# apply -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
self.Outline.move_node(node_path, new_parent_path, position = position)

# rename the node, if necessary
old_name = node.name
if new_name != old_name: # check renaming
    node.name = new_name
</t>
<t tx="niederberger.20040825221401.24"># apply to the other clients -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
# depending on the perspective a move can look as an insertion, a deletion or a move.
# propagate the event to all the interested users
# propagation is cpu intensive ...

# obtain the perspectives related to this event
old_view_dic = self.Outline.get_upward_perspectives(old_parent) # return a dic of 'perspective'-&gt;"relative_path"
new_view_dic = self.Outline.get_upward_perspectives(new_parent) # return a dic of "relative_path" -&gt; [perspectives]
        
#print "new_parent t_dic", t_dic # just for debugging
#print "new_view_dic", new_view_dic # just for debugging

outline_list = None # will create it only if required

for t_perspective in new_view_dic.keys(): # users that will see an insertion
    if old_view_dic.has_key(t_perspective): # the user will see a move
        old_rpath = old_view_dic[t_perspective] + '/' + old_name
        new_rpath = new_view_dic[t_perspective] + '/' + new_name
        t_perspective.client.callRemote("move_node", old_rpath, new_rpath, position=position)
        del old_view_dic[t_perspective] # already counted    
    else: # the user will see an insertion
        new_rpath = new_view_dic[t_perspective] + '/' + new_name
        if not outline_list: # if the data have not been obtained calculate it now
            data = self.Outline.outline_to_data(node)
            outline_list = (map(lambda x: x[0], data[0]), data[1]) # change ([(name, body), (name,body)], [0 1 [2 3 1] 4]) to ([name, name], [0 1 [2 3 1] 4])
        t_perspective.callRemote("paste_outline", new_rpath, position, outline_list) # send the data to the other clients
    
    
for t_perspective in old_view_dic.keys(): # the rest of the old users will see a deletion
    old_rpath = old_view_dic[t_perspective] + '/' + old_name
    t_perspective.client.callRemote("delete_node", old_rpath)
    </t>
<t tx="niederberger.20040825221401.25">def remote_upload_outline(self, parent_path, position, data):
    """
    This method allow clients to update outlines.
    The clients upload data to the server, this method transform this data in a real outline, and propagate the event.
    The format of data is : ([(name, body), (name,body), ...], [0 1 [2 3 1] 4])
    """
       
    # check if authorized to edit the tree -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    local_permissions = self.Outline.get_permissions(self.name, parent_path)

    if "Tree_edit" not in local_permissions:
        raise Unauthorized, "You are not allowed to append branches to this tree. (your local permissions are %s)"%(local_permissions)

    # create the local outline -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    parent_node = self.Outline.get_node(parent_path)
    assert parent_node, LeoError("Could not find the parent node where insert the uploaded data (parent_path '%s')" % parent_path)

    assert len(data[1])== 2, LeoError("The nodes hierarchy have not the correct format. (a parent node and all his childrens) (len(data[1]) == %i != 2) " % len(data[1]) )
    
    # security check of names with "/" (an error would be too much disastrous)
    data = (map(lambda x: (x[0].replace("/", "&amp;sl;"), x[1]), data[0]), data[1])
    
    # add the first item at the correct position, the rest is recursive,
    t_name, t_text = data[0][data[1][0]]
    t_node = self.Outline.nodeClass(parent_node, position, name=t_name, text=t_text) #NodeClass( parent_node=None, position=-1, name="New CollaborativeNode", text=""):
    t_dic = {data[1][0]:t_node} # index -&gt; node_instance
    
    # now deploy the data in the rest of the t_node childrens
    self.data_to_outline(t_node, data[0], data[1][1], t_dic) # data_to_outline(parent, nodes_list, nodes_hierarchy, t_dic)
    
    
    # propagate the event to the other clients -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
    # obtain the outline 
    outline_list = (map(lambda x: x[0], data[0]), data[1]) # change ([(name, body), (name,body)], [0 1 [2 3 1] 4]) to ([name, name], [0 1 [2 3 1] 4])
    
    # send outline to the interested clients 
    # only two cases, will see it, will not see it. Easy.
    
    # obtain the perspectives related to this event
    t_dic = self.Outline.get_upward_perspectives(parent_node) # return a dic of 'perspective'-&gt;"relative_path"
    
    for t_perspective, t_rpath in t_dic.items(): 
        t_perspective.client.callRemote("paste_outline", t_rpath, position, outline_list) # send the data to the other clients
            
    return
</t>
<t tx="niederberger.20040825221401.26">def remote_download_outline(self, path):
    """
    Return the data related to a specific outline. This method is called by client that desire to "copy" an online outline.
    Data format,
    (
        ([("node1_name", "node1_text"), ("node2_name", "node2_text"), ..], [0, 1, 2, [4, 1], 5, 6, ..]),
        {1:["user1", "user2"], 5:["user2", "user4"]}
    )
    i.e. outline data plus data of who is editing the copied nodes, very important to warn the user of corrupt, or in edition version.
    """
    
    # transform a local outline to his data representation
    
    base_node = self.Outline.get_node(path)
    assert base_node, LeoError("Could not find the base_node to download (base_node_path '%s')" % path)
    
    nodes_list, nodes_hierarchy = self.outline_to_data(base_node) # format ([node1_instance, node2_instance, ..], [0, 1, 2, [4, 1], 5, 6, ..])
    data = (map(lambda x:(x.name, x.get_text()), nodes_list) , nodes_hierarchy) 


    warnings = {} #the "being edited by" warnings. {1:["user1", "user2"], 5:["user2", "user4"]} 
    c = 0
    for t_node in nodes_list:
        if t_node.users:
            warnings[c] = t_node.users.keys()
        c+=1
        
        
    return (data, warnings)
</t>
<t tx="niederberger.20040825221401.27"># Perspective access to node contents edition methods</t>
<t tx="niederberger.20040825221401.28">def remote_selected_node_is_locked(self,): # is this method necessary ?
    """
    Used by the client to know who is locking the node.
    """
    
    if self.selected_node:
        return self.selected_node.is_locked
    
    return None


def remote_lock_selected_node(self, ):
    """ 
    """

    # check the permissions	
    if self.selected_node.is_locked and self.selected_node.is_locked != self.name:
        raiseLeoError("The selected node is already locked by '%s'."%(self.selected_node.is_locked))
            
    self.selected_node.is_locked = self.name
        
    return
    
def remote_unlock_selected_node(self, ):
    """ 
    """

    if self.selected_node.is_locked != self.name:
        raiseLeoError("The selected node is locked by '%s', you can not unlock it."%(self.selected_node.is_locked))
        
    
    self.selected_node.is_locked = None # no one has a lock over this node
    
    return
</t>
<t tx="niederberger.20040825221401.29">

def remote_update_node(self, path, text): # this method should be generic or only for the selected node
    """ 
    """

    node = self.Outline.get_node(path)
        
    # check if it is already locked by you
    if node.is_locked != self.name:
        raiseLeoError("The selected node is locked by '%s', you can not edit it."%(self.selected_node.is_locked))

    # apply
    self.Outline.update_node(node, text)

    # propagate the event to all the interested users
    for t_value in node.users.values():
        t_value.client.callRemote("update_node", text ).addErrback(raiseLeoError, "could not update the node for user %s"%(t_value.name))		
        
    return	
    

def remote_update_selected_node(self, text): # this method should be generic or only for the selected node
    """ 
    """

    # check if it is already locked by you
    if self.selected_node.is_locked != self.name:
        raiseLeoError("The selected node is locked by '%s', you can not edit it."%(self.selected_node.is_locked))

    # apply		
    self.Outline.update_node(self.selected_node, text)

    # propagate the event to all the interested users
    for t_list in self.selected_node.users.values():
        for t_value in t_list:
            t_value.client.callRemote("update_selected_node", text ).addErrback(raiseLeoError, "could not update the selected node of %s"%(t_value.name))
        
    return	
</t>
<t tx="niederberger.20040825221401.30"># Allow external users to start collaborating


def remote_collaborate_in(self):
    """
    Login into the collaborative server associated to the selected node
    """
    
    site_index, num_of_sites, base_state_vector, base_text, ops_list = self.selected_node.add_client(self.client)
    
    self.site_index = site_index
    
    return (site_index, num_of_sites, base_state_vector, base_text, ops_list)


def remote_collaborate_out(self):
    """
    Logout from the collaborative server associated to the selected node
    """

    # logout of the Collaborative Node
    self.selected_node.del_client(self.client)
    
    self.site_index = None
    
    return
    
    

</t>
<t tx="niederberger.20040825221401.31">def remote_receive_op(self, *args, **kws):
    """
    Perspective access to the selected nodes operations
    """
    
    # check if it is already locked by you
    if self.selected_node.is_locked and (self.selected_node.is_locked != self.name):
        raiseLeoError("The selected node is locked by '%s', you can not edit it."%(self.selected_node.is_locked))
        
    if self.site_index == None:
        raiseLeoError("You have not logged in the node, so you are not able to edit it.")

    kws["source_site"] = self.site_index # if this perspective manage the call, it has to comes from that source
    kws["who"] = self.name # stamp the operation with our name
    
    # apply		
    self.selected_node.receive_operation(ConcurrentEditable.Operation(*args, **kws))
    return</t>
<t tx="niederberger.20040825221401.32">def remote_insert_text(self, startpos, text, timestamp = None):
    """ 
    
    (version will be used for leo step4)
    """
    
    # check if it is already locked by you
    if self.selected_node.is_locked and (self.selected_node.is_locked != self.name):
        raiseLeoError("The selected node is locked by '%s', you can not edit it."%(self.selected_node.is_locked))
        
    if self.site_index == None:
        raiseLeoError("You have not logged in the node, so you are not able to edit it.")

    if timestamp == None:
        raiseLeoError("Operation 'insert_text' called without a timestamp.")
        
        
    # apply		
    self.selected_node.receive_operation(ConcurrentEditable.Operation("Insert", startpos, text, timestamp = timestamp, source_site = self.site_index, who= self.name))
    
    # the selected, cnode will propage the event to the related users.
    # cnode : CollaborativeNode, is a ConcurrentEditableServer
        
    return
    
def remote_delete_text(self, startpos, length, timestamp = None):
    """ 
    """
    
    # check if it is already locked by you
    if self.selected_node.is_locked and (self.selected_node.is_locked != self.name):
        raiseLeoError("The selected node is locked by '%s', you can not edit it."%(self.selected_node.is_locked))
        
    if self.site_index == None:
        raiseLeoError("You have not logged in the node, so you are not able to edit it.")
        
    if timestamp == None:
        raiseLeoError("Operation 'delete_text' called without a timestamp.")

        
    if not ( type(startpos) == type(length) and type(startpos) is int):
        raiseLeoError( "Type of the arguments for delete text are incorrect. (expected IntType got %s, %s)"%(type(startpos), type(length) ) )
    
    # apply		
    self.selected_node.receive_operation(ConcurrentEditable.Operation("Delete", startpos, length, timestamp = timestamp, source_site = self.site_index, who= self.name))
    
    # the selected, cnode will propage the event to the related users.
    # cnode : CollaborativeNode, is a ConcurrentEditableServer
    
    return

</t>
<t tx="niederberger.20040825221401.33">@
this is the server side representation of the administrator
@c

class AdminOutlinePerspective(pb.Referenceable):
    """
    This perspective implement the methods required for a remote administration to the Outline.
    Focused on the User accounts and accesses administration.
    One perspective per Administrator connection in the rare case that there is more than One authorizer associated with LeoService.
    
    This perspective manage accounts, acesses and permissions.
    An Authenticater has accounts.
    An account has acesses to certain nodes.
    A node has permissions for certains accounts.
    """
    
    def __init__(self, name, base_node_url, outline, mind):
        #pb.Referenceable.__init__(self) # pb.Referenceable  has no __init__ method
        
        # check the permissions        
        permissions = outline.get_permissions(name, base_node_url)
        assert "Admin_node" in permissions, Unauthorized("Not authorized to admin the node '%s' (local permissions %s)"%( base_node_url, permissions))  
        
        
        self.Outline = outline		# the internal Outline is capitalized because it make reference at the Server instance.
        self.checker = outline.checker
        self.base_path = base_node_url
        self.base_node = self.Outline.get_node(self.base_path)		
              
        self.name   = name
        self.client = mind
        deferred = self.client.callRemote("post_message", 
                                         "LeoServer", 
                                          "%s, you have now access to the Admin Perspective."%(name.capitalize()))
        
        deferred.addErrback(raiseLeoError, "Could not send a message to user %s"%(name))
        
        return

                
    def logout(self,):
        """
        A client is closing his relation with this perspective (i.e. this outline).
        """
        
        print "Admnistrator %s at %s is login out" % (self.name, self.base_path)
        
        return
        
    def absolute_path(self, relative_node_path): 
        """
        transform a relative path to a valid server url
        """
        return self.base_path + '/' + relative_node_path[1:]	

    @others
    





</t>
<t tx="niederberger.20040825221401.34">def remote_create_account(self, name, password):
    """
    Add an account in the same Authorizer that gives the access to the Admin perspective.
    """
    
    # should I check that the name is free ?
    assert not self.checker.userExist(name), LeoError("The user account %s already exist" % name)
    
    self.checker.addUser(name, password)
    
    self.client.callRemote("post_message", "LeoServer", 
                            "An account for %s have been created."%(name.capitalize())).addErrback(raiseMessageError, self.name)
    
    return


def remote_change_password(self, name, password):
    """
    Change the password of an existing account.
    """
    
    # should I check that the name is free ?
    assert self.checker.userExist(name), LeoError("The user account %s does not exist (can not change his password)" % name)
    
    self.checker.setPassword(name, password)
    
    self.client.callRemote("post_message", "LeoServer", 
                            "The password of  %s have been edited."%(name.capitalize())).addErrback(raiseMessageError, self.name)
    
    return


def remote_delete_account(self, name):
    """
    Delete an account in the same Authorizer that gives the access to the Admin perspective.
    """
    
    self.checker.delUser(name)
    
    # should I delete the permissions in the outline too ? &lt;&lt;&lt;&lt; YES, to avoid false permissions of future users 
    # need to visit the entire outline (ouch !)
    
    
    self.client.callRemote("post_message",  "LeoServer", 
                           "The account %s has been deleted."%(name.capitalize())).addErrback(raiseMessageError, self.name)
    
    return


def remote_get_users_list(self,):
    """
    Return the list of existing users name
    """
    return  self.checker.users.keys()
</t>
<t tx="niederberger.20040825221401.35">def remote_get_users_permissions(self, rpath):
    """
    Return the dictionnary of the permissions of a node.
    """        
    path = self.absolute_path(rpath)
    t_node = self.Outline.get_node(path)
    assert t_node, LeoError("Could not found the indicated path '%s'" % path)
    return t_node.permissions


def remote_get_permissions(self, name, rpath):
    """
    Permissions are related to the aviable actions per node. 
    They also are herited to the subnodes.
    valid permissions are : ['Read', 'Node_edit', 'Tree_edit', 'Admin_node'] 
    """
    # could put here and access check, but will not (in sake of cpu usage)
        
    # get the path node
    path = self.absolute_path(rpath)
    t_node = self.Outline.get_node(path)
    assert t_node, LeoError("Could not found the indicated path '%s'" % path)
    permissions = self.Outline.get_permissions(name, t_node)	
    
    return permissions


def remote_delete_permissions(self, name, rpath):
    """
    Erase the permissions of one user in the node. The permissions of upper nodes will be herited (propagated).
    """
    # could put here and access check, but will not (in sake of cpu usage)
        
    # get the path node
    path   = self.absolute_path(rpath)
    t_node = self.Outline.get_node(path)
    assert t_node, LeoError("Could not found the indicated path '%s'" % path)
    
    if t_node.permissions.has_key(name):
        del t_node.permissions[name]
    
    return 


def remote_set_permissions(self, name, rpath, permissions):
    """
    Permissions are related to the aviable actions per node. 
    They also are herited to the subnodes.
    valid permissions are : ['Read', 'Node_edit', 'Tree_edit', 'Admin_node'] 
    """

    # get the path node
    path   = self.absolute_path(rpath)
    t_node = self.Outline.get_node(path)
    
    if not t_node:
        raisePathError(path)
        
    # check if the requested path is under the admin perspective
    res_node = self.Outline.find_upward(lambda x: self.base_node == x, path)
    if not res_node:
        raiseLeoError("You are not allowed to edit the permissions of this node. (%s)"%(path))

        
    if type(permissions) not in [list, tuple]:
        raiseLeoError("Permissions should be a list or a tuple")

    for permission in permissions:
        if permission not in ["Read", "Node_edit", "Tree_edit", "Admin_node"]:
            raiseLeoError("Unknown permission '%s'"%(permission))
        
    t_node.permissions[name] = list(permissions)

    # check if the user is logged and update his permissions.
    if t_node.users.has_key(name):	
        for t_perspective in t_node.users[name]:
            t_perspective.local_permissions = self.Outline.get_permissions(t_perspective.name, t_perspective.selected_node_path)
            
    self.client.callRemote("post_message", "LeoServer", 
                           "%s permissions have been updated."%(name.capitalize())).addErrback(raiseMessageError, self.name)
    
    return






</t>
<t tx="niederberger.20040825221442">@nocolor
There are outlines transfers, at node paste, copy and at clients connection.
To transfer the outline we use our own dummy transfer format.

The format is an abuse of python data objects, and it has some similarities with the leo xml format.
The data object is a tuple of two elements 

(&lt;nodes_data&gt;, &lt;nodes_hierarchy&gt;)

&lt;nodes_data&gt; is a list of (&lt;name&gt;, &lt;body&gt;) tuples, or only of nodes names if only the headline is being transfered: a list of &lt;name&gt;.
If a node name contain the character '/' is is replaced by the sequence "&amp;sl;", to avoid paths confusions. Both headline and body have to be unicode strings.

&lt;nodes_hierarchy&gt; is a recursive list numbers and lists.  Each number correspond to a index in the &lt;nodes_data&gt; list. Each list correspond to a new outline sublevel, that is attached to the previous node. If an index appears twice, then a clone will be created. The suboutlines of the clones is only indicated at the first appearance, the next instance the suboutline will herited by the clone.


Examples:

    data1 = ([(u"dnö&amp;sl;\\de1",u""),(u"dnode2",u""),(u"dnod€/\\3",u""),(u"dnode4",u"")], [0,[1, 3,[2, 1], 1, 2, 3, 1]]) 
    data2 = ([u"dnö&amp;sl;\\de1", u"dnode2", u"dnod€/\\3", u"dnode4"], [0,[1, 3,[2, 1], 1, 2, 3, 1]]) 

    Notice that there are many clones. One of them, '3' has a suboutline.


This data object is sent as it is via PB that serialize/unserialize it (jelly). The PB serialization format is a compact binary representation (see the twisted documentation).

The code that use this format can be found at "LeoN.leo/Code/Code Perspectives/Upload/Download nodes"

In the future the transfer format will probably modified (change in the path system, better use of the PB remoterefence, copy and cacheable features).</t>
<t tx="niederberger.20040825221442.1"></t>
<t tx="niederberger.20040825221453">Read the Admin Gui help to get more information about the permissions system of LeoN.
The security is based on password access. 
Be aware that the data is transmited in a non encripted binary format. Do not manage sensible data.

&lt;&lt; admingui help &gt;&gt;

</t>
<t tx="niederberger.20040825221453.1">@color
@language python
# this is the documentation that will see the end user, give a description of the panel and his usage
# this is part of the code, do not delete the "help" definition and the """ elements.
help = \
"""

The administration gui allow you to do two things:
    - Define the permissions of each user at each node
    - Define the accounts of the server, defined by they name and password.

The accounts are defined at the server level. The permissions are defined at a per node level.
    
Thus the interface is separated in two areas, the left pane -the users accounts- and the right pane -the node permissions-.

The left pane present the list of the defined accounts, and interfaces to create new accounts, to change passwords and to delete some accounts. Be carefull, there is no undo! 

Creating an account for an user is not enough to allow it to access the server, you need to define his permissions at the access point.

The right pane allow you to you the edit the per node per user permissions.
The LeoN permissions system is similar to the Zope permissions system.

If a node contain no permissions information about an user, they permissions will be herited from uper nodes. So defining the permissions for the root node will be valid for all the nodes of the system. To change the permissions in a branch, edit the permissions of the root node of the branch.

You have to understand that adding permissions for a user at a node and leaving in blank the options indicate that you are Prohibiting all those permissions for that user, starting from that node and in the suboutline.

The admin gui allow you to edit the permissions of the node where you raised the dialog.
You can add users permissions using the "Add user entry &gt;&gt;&gt;" button, that will add an entry in the node permissions list.

You can edit the different permissions of the node by selecting different users via the  "User:" combobox, click over the user name and a choice list will appear. Remember to press the "Save Changes" button to confirm the modifications.

The button "Delete users permissions" will eliminate the entry at that node, and the permissions for that user at that node will be searched upward in the server outline.

If no permissions entry are found for an user, by default he will have no permissions at (thus it will not be able to connect to the server).

Remember to define the permissions of the users recently created. 
Avoid defining permissions in every node, if would become difficult to maintain. Try to always edit the permissions at the project root nodes.

The users accounts and their permissions are persisted in the server '.tap' file.

Read/Access: allow the users to retreive the node body content and connect at that point.
Node edit:   allow to enter in collaborative mode and edit the node body content.
Tree edit:   allow to insert, move and delete nodes in the outlines. 
Admin node:  allow to edit the permissions of that node, and the accounts of the server (allow access to this dialog).

Note: be aware that in the actual version the server/client connections are not encrypted. Thus all the data, including the passwords are transmited in a easy to deduce binary format. Do not transfer sensible data over insecure network.
"""


@others</t>
<t tx="niederberger.20040825221453.2"></t>
<t tx="niederberger.20040825221501">@
Probably the third most important element for sucessfull code development are the tests.
The test suite for LeoN is centralized the "LeoNtest.py" script.

Both CollaborativeOutline and LeoServer provide they own automated unit tests.

CollaborativeOutline execute a test similar to the original paper typical example.
LeoServer execute a test between a raised server and a SimpleClient object (that only print the command received). The correctness of the execution can be checked if no error is raised, if the printed information is consistent and if the webpage publishing is consistent too.

LeoClient tests are more difficults, because they require network events.
By the moment I have not figured a clean way to get the defered objects of the client side.
The file "LeoNtest.leo" provide a simple demo outline and some executable nodes.
The executable nodes allow to automatize some predefined actions on the client. By the moment we use a timing system to be sure that the network event has been realized.
Client side tests are somewhat incipients.

LeoNtest.py will supose that the his directory contain an executable file named "leon.py" that correspond to a symbolic link to the "leo.py" file a Leo distribution that has already LeoN installed and enabled.

Use "LeoNtest.py -h" to see the options of the tests execution. ("usage" child node)
@c</t>
<t tx="niederberger.20040825221501.1">@color 
@language python
# LeoNtest.py usage string

usage= \
"""
Understood options:
    'no_server', run only the concurrent editable tests;
    'just_server', ommit the concurrent editable tests;
    '1', run server tests and open one client;
    '2', run server tests and open two clients;
    'save_tap', if run the server test, will create a '.tap' twisted server file at shutdown;
    'help' or '-h', show this help message
    if no option, will run all tests.
    
Example:
    'LeoNtest.py 1 save_tap'
"""
</t>
<t tx="niederberger.20040825222327">@language plain
This node contains reminders and all things left to do in general, grouped by priority.
Currently they may be related to coding, researching, packaging, everything.</t>
<t tx="niederberger.20040825222327.1">- inspect and make a consistent use of the timestamp (operations creation, emission, reception, application) (&lt;&lt;&lt; the next big thing)

- in Test_Chalks, separate both instance stdout redirection (run in threads ?). Test_Chalks should be reimplemented.

- Why does site show the insertion point index and the other one does not ? (left of the chat bar) (Test_Chalks exclusive problem, a reason more to rewrite it)

- Work on concurrenteditablenode (make consistent use of the new site_id system)

- the rendezvous system does not seem to be working under linux (available servers list is empty)

</t>
<t tx="niederberger.20040825222327.2">- we should add to rendezvous published data which filename we are serving, and unregister our server and register it again with the new filename when a new file is opened
  currently it registers only once at startup and unregisters on app shutdown. 
  But before all that, implement unRegisterServer() method on ChalksServerMonitor
  

- connect_to_parent -&gt; logged_in -&gt; start_colaborating are unnecesarry. The node can start collaborating when just connecting.



- work on ConcurrentEditableNode, ChalksNode

- implement the file open complications
- document the system internals, add docustrings for the methods
- clean up the "self.splitVerticalFlag" / "verticalFlag"  usage

- should not allow a connection to the same instance, on localhost. Chat behaves strangely on such connections. (different instances serving on different ports is ok, for tests). </t>
<t tx="niederberger.20040825222327.3">- test the fill_body routine. 

- do edition tests with the "delayed line"

- Implement a LiveEvil nevow web front end to the chat sessions, will be so cool.

- parse argv options (using twisted options system) to allow enabling/disabling web service

- implement a persistence system for the user options (using python default tools) (need to save the nickname... last edited files... and ?)

- To enhance Gui separation should create a ChalksGui Interface and make Chalks implement it trough a TkChalks method
http://www.twistedmatrix.com/documents/current/howto/components
ChalksGui code should be in Chalks.py, TkChalks code should be in TkChalks.py

- create a circle similar configuration file system

- write the help text
</t>
<t tx="niederberger.20040906222819">Components of Chalks are Python, Twisted, ConcurrentEditable and Tkinter.

&gt;&gt; improve it later and actually give a general view of how parts fit together &lt;&lt;

To develop the network code we use Twisted. Twisted is a framework (a library of functions and classes) for Python. Twisted is very important because it provides many features. It allows very easily to construct server apps ('.tap' files), create networked client applications (reactors, general class design), to communicate two pieces of software (perspective broker), to provide web services (woven/nevow), and much more. 

ConcurrentEditable provides a pure python implementation of the concurrent edition algorithms developed by Chengzheng Sun's team. We extended a little the idea (on the technical aspect) to provide a client/server implementation (subclassing the base system), and thus ConcurrentEditableClient/Server were born.</t>
<t tx="niederberger.20040911012711">@
This are the class definitions used to render us beauty outline over the WWW.

The web rendering is done using the Woven component of Twisted.
Look at the twisted documentation to see how to use Woven.
@c

@
Usage:

site = server.Site(page.Page(interfaces.IModel(self), templateFile="Chalks.xhtml", templateDirectory="./templates/")
web_service = reactor.listenTCP(port, site)

@c</t>
<t tx="niederberger.20040911012711.1">class utf8Page(page.Page):

    def render(self, request):
        request.setHeader("Content-type", "text/html; charset=utf-8")
        return page.Page.render(self, request)

</t>
<t tx="niederberger.20040911012711.2">@
We define an adaptator to let Woven use the Chalks instance
@c

class ChalksModel(model.MethodModel):
    """
    Model adaptator for the web templates that publish a Chalks instances
    
    When the MyDataModel adapter is wrapped around an instance
    of MyData, the original MyData instance will be stored in 'original'
    """
    
    def wmfactory_name(self, request):
        return self.original.filename or "Chalks"
    
    def wmfactory_text(self, request):
        return self.original.text_widget.get("1.0", END).encode("utf-8")
                
    def wmfactory_users(self, request):
        ret = []
        return ret

    def wmfactory_HB(self, request):
        return map(lambda x: str(x), self.original.HB) 
        
    def wmfactory_delayed_operations(self, request):
        return map(lambda x: str(x), self.original.delayed_operations)

    def wmfactory_base_text(self, request):
        return self.original.base_text.encode("utf-8")

    def wmfactory_MSV(self, request):
        return self.original.minimum_state_vector


components.registerAdapter(ChalksModel, Chalks, interfaces.IModel)
</t>
<t tx="niederberger.20040911120126">def server_monitor_callback(servers):    
    """
    this is called whenever the dict of known servers changes
    
    sample server data for reference:
                                'address':     info.getAddress(),
                              'identifier':  info.getName(),
                              'port':       
    """        
    self.server_listbox.delete(0, END)  # remove all items
    self.cur_server_list = servers # set internal dict of current known servers. This is used later by the listbox callback to known which server the user clicked
    
    for server in servers.values(): # add all servers
        if server['identifier'] == self.service_name: # skip ourself
            continue
        ipadr = '.'.join(map(lambda x:str(ord(x)),unpack('cccc', server['address'])))  # Ahhhhh ! Is this the best way for unpacking 4 bytes on a binary stream ?
        svr_string = server['identifier'] + ' [%s]' % ipadr
        print svr_string
        self.server_listbox.insert(END, svr_string)</t>
<t tx="niederberger.20040911130819">def onServerListClick(event=None):
    if not self.server_listbox.curselection():
        return  # &lt;&lt;&lt; tkinted only seems to consider entries as selected after clicking twice on a listbox
    
@ aargh, Tkinter is disgusting:
1) curselection() returns STRINGS instead of ints when referring to indexes
2) curselection() only returns something after you click TWICE on the list box. After that, it starts working as expected
3) Listbox has no scrollbar, we have to set it up manually with:
    """
    frame = Frame(master)
    scrollbar = Scrollbar(frame, orient=VERTICAL)
    listbox = Listbox(frame, yscrollcommand=scrollbar.set)
    scrollbar.config(command=listbox.yview)
    scrollbar.pack(side=RIGHT, fill=Y)
    listbox.pack(side=LEFT, fill=BOTH, expand=1)
    """
@c    
    server = self.cur_server_list[self.cur_server_list.keys()[int(self.server_listbox.curselection()[0])]]
    
    ipadr = '.'.join(map(lambda x:str(ord(x)),unpack('cccc', server['address'])))
    address_entry.delete(0, END); address_entry.insert(END, ipadr)
    port_entry.delete(0, END); port_entry.insert(END, str(server['port']))
    
</t>
<t tx="niederberger.20040920180258">
&lt;local&gt; Exception in Tkinter callback
&lt;local&gt; Traceback (most recent call last):
&lt;local&gt;   File "E:\PYTHON23\lib\lib-tk\Tkinter.py", line 1345, in __call__
&lt;local&gt;     return self.func(*args)
&lt;local&gt;   File "C:\Documents and Settings\rodrigob\Escritorio\chalks\src\Chalks.py", line 1409, in onDisconnect
&lt;local&gt;     self.node.disconnect_from_server()
&lt;local&gt;   File "C:\Documents and Settings\rodrigob\Escritorio\chalks\src\Chalks.py", line 1786, in disconnect_from_server
&lt;local&gt;     deferred = self.avatar.callRemote("collaborate_out")
&lt;local&gt; AttributeError: ChalksNode instance has no attribute 'avatar'


When a parent disconnects, we need to send the collaborate_out msg to all of it's children. Code for that is on ChalksNode.remote_send_message(). We need to refactor that code out of remote_send_message, since sending commands to all children is a common thing and will be needed by other methods later.</t>
<t tx="niederberger.20040922110026">Place all pyzeroconf/rendezvous bugs/issues here so they can be reported to original authors later:

- why does Test_Chalks is sooo slow to quit ? (seeems to be related with rendez vous, when disabled it quit in a fraction of seconds).
  This has to do with Rendezvous.py threading mechanism. It has a long timeout when waiting for all socket monitoring threads to finish.</t>
<t tx="niederberger.20040922110926">This is a pyzeroconf bug, we will just catch the exception and disable rendezvous support when this happens.

Traceback:


./Test_Chalks.py
Creating two Chalks instances
Chalks 0.0.1, started. Licensed under the GNU GPL. Copyright 2004, Chalks Development Team (http://chalks.berlios.de)
                                                                                                                             
Starting Chalks service at chalks://localhost:8787
Knowing your internet address (i.e. your IP) other users can connect themself to your session using the port 8787.
Traceback (most recent call last):
  File "./Test_Chalks.py", line 56, in ?
    app1 = Chalks.Chalks()
  File "/home/rodrigob/projets/chalks/svn/trunk/src/Chalks.py", line 276, in __init__
    self.server_monitor = ChalksServerMonitor()
  File "/home/rodrigob/projets/chalks/svn/trunk/src/Chalks.py", line 2803, in __init__
    self.startListening()  # make it active
  File "/home/rodrigob/projets/chalks/svn/trunk/src/Chalks.py", line 2855, in startListening
    self.rendezvous = Rendezvous()
  File "/home/rodrigob/projets/chalks/svn/trunk/src/Rendezvous.py", line 1595, in __init__
    self.socket.setsockopt(socket.SOL_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(_MDNS_ADDR) + socket.inet_aton('0.0.0.0'))
  File "&lt;string&gt;", line 1, in setsockopt
socket.error: (19, 'No such device')
</t>
<t tx="niederberger.20040922111043">Started listening local network for Chalks servers ...
Registering your server with rendezvous ...
Traceback (most recent call last):
  File "C:\prj\chalks\src\Chalks.py", line 2898, in ?
    app = Chalks()
  File "C:\prj\chalks\src\Chalks.py", line 299, in __init__
    self.server_monitor.registerService(self.service_name, self.server_address,
self.server_port, user_name)
  File "C:\prj\chalks\src\Chalks.py", line 2883, in registerService
    r.registerService(info)
  File "C:\prj\chalks\src\Rendezvous.py", line 1656, in registerService
    self.checkService(info)
  File "C:\prj\chalks\src\Rendezvous.py", line 1735, in checkService
    raise NonUniqueNameException
Rendezvous.NonUniqueNameException


Happened when starting two instances one immediately after the other. Seeding the random number generator with system time should fix it.
Actually there is no need to fix it, just wrap with try: except:, since later service names will be properly advertised with correct filenames.</t>
<t tx="rodrigob.010104175231"></t>
<t tx="rodrigob.010104211709"></t>
<t tx="rodrigob.010104212717">no real requirement right now, but issues we should think about:

- users behind very tight proxies/firewalls (perhaps there won't be much to do about them, since http through port 80 is the only traffic they can get)
- latency of twisted's tcp connections, since tcp is the only protocol we use as opposed to udp. But I also think there isn't much to be done here, as we heavily rely on twisted spread/pb for all our networking needs.
- do we really need web publishing using Woven as LeoN had ?</t>
<t tx="rodrigob.010104213529">Notation:

We should try adhering to Twisted Matrix's coding conventions [1], which encompasses most conventions found on PEPs blessed by the python community.

[1]http://twistedmatrix.com/documents/howto/coding-standard

But some are important enough to get mentioned here:

this_is_variable
ThisIsAClass
this_is_a_function_or_method

t_* denotes temporary variables</t>
<t tx="rodrigob.010104213829">distro .leo files MaJusCuLe inconsistence


In the distribution you can find the files  

docs/LeoDocs.leo, 
plugins/leoPlugins.leo and  
src/LeoPy.leo

is propose to rename the "leoPlugins.leo" as "LeoPlugins.leo", in the sake of consistency.</t>
<t tx="rodrigob.121403173614.1">
This is the LeoN outline, here you will find all the LeoN documentation and text aviable (some pictures are referenced too).

Start reading the README file (subnode). For more information, explore the Docs node. Enjoy !</t>
<t tx="rodrigob.121403173614.3">What is LeoN ?
--------------

LeoN means "Leo over Network".

Leo is an multiplatform open source extensible outliner. http://leo.sf.net

LeoN is a plugin for Leo that allow near to real time collaboration between Leo editors.

LeoN is separated in two parts: the client plugin and the server.
The LeoN plugin allow Leo to connect to a  LeoN server.

To setup a local LeoN system you need both components.
A LeoN server can store as many projects as the users desire.

Leo and LeoN are written in Python. http://www.python.org
LeoN require Twisted, a network module for Python. http://www.twistedmatrix.com
Leo, LeoN, Twisted and Python are open source multiplatform projects.

</t>
<t tx="rodrigob.121403173614.4">Release Status
--------------

LeoN
Release  &gt;&gt;&gt;HAVE TO REWRITE IT&lt;&lt;&lt; '0.1.0 alpha'
CodeName "Feux d'artifice"

This is the first alpha release of LeoN.

This release provide all the required features to use Leo in a networked ambient.

All the system is designed and implemented, but many parts still buggy. 
This version provide a system that need to be tested, critized, and stabilized.

It is important to recall that all the described features are aviables and working, but in alpha stages. This code is not ready for production use and it does NOT ensure the data preservation. Use carefully, to do some test and give feedback to the author.

It is important to notice that this release has the garbage collector of the concurrent edition system disabled. That mean the program posibly will increment, slowly, his memory usage. This is not an issue for an alpha release, where the code is not expected to run more than a few hours continously; but is important in case someone would reuse this code directly. This topic was delayed for the next release because it require a special focus, at the conceptual level.


Next steps
----------

- check and enable the gargabe collector implementation
- make hard rock the concurrent editable module
- debug, debug, debug
- check the approach as a valid solution
- step2, 3 and 4 are aviable, step1 still not created (different work). step1: leo outlines merge 


Know bugs
---------

This release is alpha stage so some things will fail and some things are known to fail. Anyway it is necessary to specify *any* bug found, during tests some weirdness appeared so this are area were bugs are expected to be detected.

- the permissions system is not hard rock and some prohibited data can be accesses (example, via outline download)
- move outlines get weird, something at the outline positions level
- there can be unicode problems at the passwords level, not checked
- the software is developed on a Linux ambient, no idea about possible windows/mac os platform specific bugs
- some hooks in the systems are hardcoded, so there can be ways to do not trigger them (example, nodes renaming)
- the system is designed and implemented considering networks delays, but the author have no access to two remotes machines for testing purpose. Only tests on a LAN have been realized, probably some underlying bugs related to the delay lines could remain. (the next tests will be realized using simulated delay lines).
- the Todo list include elements that can be considered bugs</t>
<t tx="rodrigob.121403173614.5">Instalation
-----------

Short
-----

Copy the 'leo_plugin' directory in you leo pluglins directory. Enable in your "plugin/pluginsManager.txt" the file "mod_LeoN.py". Run Leo.


Detailed
--------

The installation is manual, Leo still developing a better plug-ins installation system.

Please follow this instructions:

1- First ensure that you have properly installed in your system:
    a- python 2.x (python 2.3 is recomended), http://www.python.org 
    b- Leo &gt;= 4.1, http://leo.sf.net
    c- Twisted &gt;= 1.1.1 (a python module), http://www.twistedmatrix.com
    
  Ensure that you use the correct versions.

2- Decompress the LeoN distribution file, enter into the created directory. This directory contain two subdirectories "leo_plugin" and "leon_server".

LeoN is composed of two parts: a client plugin and a LeoN server.

3- The release has a directory named "leo_plugin", copy all the contents of this directory in the "plugins" directory of your Leo installation. 

4- Edit the file "plugin/pluginsManager.txt" of your Leo installation, add a line with the text "mod_LeoN.py". 
  We recommend to also include a line with the plugin "redirect_to_log.py". 

5- Congratulations you have finished the installation of LeoN ! 
  At the next start of Leo you should see in the message bar the text "Welcome to LeoN"

Please read the Usage instruction to know how to use the code, specially about how to startup a LeoN server and how to use the Leo(N) client.

In the future we expect to create an all-in-one install file (technically feasible, at least Twisted+Leo+LeoN).</t>
<t tx="rodrigob.121403173614.6">Usage instructions
------------------

The usage is subdivided in four topics,

1. How to install LeoN ?
2. How to run a server ?
3. How to connect to a server ?
4. Panoramas

---

&lt;&lt; 1. how to install LeoN ? &gt;&gt;

&lt;&lt; 2. how to run a server ? &gt;&gt;

&lt;&lt; 3. how to connect to a server ? &gt;&gt;

&lt;&lt; 4. panoramas &gt;&gt;

---
     
The above instructions should be enough to reproduce the screenshots presented at http://souvenirs.sf.net .

The intention of this release is to allow more people to introduce them in the LeoN project, we expect feedback, bugs report, and constructive critics.

Explore the LeoN.leo outline for more infos, details, code notes and future plans.

We encourage you to post comments, critiques, suggestions for this project in the Sourceforge Leo Devel forum (link aviable at http://leo.sf.net) or a the author mail &lt;rodrigo_b at users dot sourceforge dot net&gt;.

</t>
<t tx="rodrigob.121403173614.8">The chat bar provide a simple chat system.

The idea is to avoid the users to use the "Document" for inter-persons comunication, the chat is aviable to do that.

The chat bar allow you to write to the "_room", that is the actual node. This mean that everyone actually reading that node will receive your message.

You can edit the "blue name" to change the destiny of your message,  if you write another one nickname you send private messages to him. Special names are "_room" and "_everyone". The last one will send the message to any client connected to the server, please be polite in the usage of this feature.

The chat bar also provide some specials commands. Write '/help' to anyone to get a list of the possible commands and his usage.


Note: the alpha release has only proof of concepts commands, future release will include more usefull ones (example, '/who' should be usefull).</t>
<t tx="rodrigob.121403173614.9">Documentation of LeoN.

Remember: Open Source is no sense if code is no usable nor reusable. To be usable the app has to be functional and documentented. To be reusable the code has to be clean, functional, commented and documented.</t>
<t tx="rodrigob.121403173614.10">RodrigoB keep a day by day log of his programs. Curious people will be able to see the development timeline.</t>
<t tx="rodrigob.121403173614.11">
Step 3   ---------------------------------------
31/05/03 File creation. Programming. RodrigoB.
01/06/03 Programming. RodrigoB.
03/06/03 Programming. RodrigoB.
05/06/03 Programming. Status post. RodrigoB.
06/06/03 Programming Gui. RodrigoB.
07/06/03 Programming Gui. RodrigoB.
08/06/03 Programming Gui. RodrigoB.
10/06/03 Programming Gui and Web service. bugfix. RodrigoB.
12/06/03 Programming server, web, gui. bugfixes. RodrigoB.
13/06/03 Programming gui, bugfixes. Screenshots. RodrigoB.
15/06/03 Random Programming. RodrigoB.
16/06/03 Added self.last_node_dirty_text. Creation of the actions hook. RodrigoB.
18/06/03 Programming users coloring, icondclick, leoclient edit tree methods, outline manipulation. RodrigoB.
19/06/03 Programming disconnection, deletion and outline manipulation. RodrigoB.
20/06/03 Programming deletion and outline manipulation. Testing and debugging. RodrigoB.
21/06/03 Searching the HeadString renamed hook, found; installed the drawText hook. bugsfixing. RodrigoB.
22/06/03 Implementation of check_pending_confirmations. RodrigoB.
25/06/03 (startup of step4)
28/06/03 Checkup of Leo 3-12 beta 1 (discovering leaps). Added delete_text in test.RodrigoB.
29/06/03 Programming rename_callback. Testing outline edition. RodrigoB.

Step 4   ---------------------------------------
25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
         Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.
17/07/03 Thinking about ConcurrentEditableServer. RodrigoB.
18/07/03 Working on ConcurrentEditableServer. RodrigoB.

Merged   ---------------------------------------
18/07/03 Merging the outline in one general tree. RodrigoB.
20/07/03 Merging the directories of devel ambient. Moving LeoN over Leo 3.12 and Twisted 1.0.6. 
         Creating mod_LeoN.py. Setup of on show-popup-menu. RodrigoB.
21/07/03 editing module loading in mod_LeoN.py. Minor edits. RodrigoB.
22/07/03 Setting templates dir as relative adress. Solving a tiny but horrible problem with onBodykey2 and leo3.12. RodrigoB.
24/07/03 Copy ConcurrentEditable at UTFSM. Working on. RodrigoB.
26/07/03 Testing some persistence stuff. Basic persistence with Twisted is trivial. Creation of start/stop_LeoServer.sh. 
         Working on ConcurrentEditableServer/Client. RodrigoB.
27/07/03 Working on ConcurrentEditableServer/Client. Undesired memory reference bug fixed. RodrigoB.
29/07/01 Working. RodrigoB.
30/07/01 Working. RodrigoB.
31/07/01 Working. RodrigoB.
01/08/01 Working. RodrigoB.
03/08/01 Eureka.  RodrigoB.
04/08/01 Working on the Eureka documentation and implementation. Passed unit test. Cleaning up. 
         Merging UTFSM local version with the release. Preparing the release. Release '0**0'. RodrigoB.


ConcurrentEditable 0.0.2 ----------------------------------------------------------------------------------------------

release version 0.0.2 (major, minor, release)

this version is not supposed to be error prone, but it is good code base.
-------------------------------------------------------------------------

25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
         Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.
18/07/03 Working on ConcurrentEditableServer. RodrigoB.
24/07/03 Copy ConcurrentEditable at UTFSM. Working on. RodrigoB.
26/07/03 Working on ConcurrentEditableServer/Client. RodrigoB.
27/07/03 Working on ConcurrentEditableServer/Client. Undesired memory reference bug fixed. RodrigoB.
29/07/01 Working. RodrigoB.
30/07/01 Working. RodrigoB.
31/07/01 Working. RodrigoB.
01/08/01 Working. RodrigoB.
03/08/01 Eureka.  RodrigoB.
04/08/01 Working on the Eureka documentation and implementation. Passed unit test. Cleaning up.  RodrigoB.

</t>
<t tx="rodrigob.121403173614.13">06/12/2003

- mod_http reinclusion in the tree, importing last @file
- 

@
   code1
   @others
   code2
@c


- Crash report,
copy node in leo4, paste in 3.12,
got error, outline was fine, (probably autosaved), quited to go to leo4. The
file was errased, only the failed pasted data was into LeoN.leo


- put the entries in the work log.

- ctrl and Control


Leo Crash, errors and a simple plugin.

This is a long post that touch for simple topics,

/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\
1. Tonight Leo 4.0 erased my LeoN.leo project ! 
Fortunatelly Leo keeps all the critical data in the @files and I have the good habit of doing backups often (two days ago).
But this insident could have been grave. How such a thing happened ?
Yesterday I started the port of LeoN from Leo3.12 to Leo4.1 (previous beta seemed too much inmatures to start such work). Working on new adaptation I required to copy some nodes of the Leo4.1 code to the LeoN outline. When doing such copy-paste an error raised during the paste (something about node attributes) and the pasted outline give a tree of empty nodes. I deleted this failed paste nodes, saved the project and quited to open LeoN.leo with Leo4.1. When I opened it with Leo4.1 Horror ! all the LeoN project had disapeared, and the only nodes in LeoN.leo where, the outline that I just tried to paste (the nodes where non empty this time). Frightened, I quited and checked the LeoN.leo file size, all the data was lost.

After some minutes to come back into my mind, I checked the output files and realized that the real lost was minor (just some nodes of the outline that I edited recently). 

The Leo version I'm using comonly is 
Leo 4.0.4, build  1.100 , October 29, 2003
Python 2.3.2, Tk 8.4.4

is very stable and I had no problem working with it in LeoN. This is the first oops that I get.

I had no idea how this could happen, but it happened when I pasted an outline of Leo4.1 to Leo4.0.

I do not know if this is a particular error, a backward problem or anything. I jusst wanted to point that:
- thanks Edward for keeping fat .leo files AND keeping always the @file nodes syncronised
- I know that this error is a strange condition (backward copy/paste), but I do not understand why the Visual Output was fine, but Leo saved a totally different outline.
- I would like to remember to Edward to enforce checks and safety during copy/paste operations. If I had a project in a pure Leo outline (no @file outputs) this issue would have been fatal.


That is all for point 1.

/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\
2. @ @ @ behaviour

That was a post I had in my yesterday LeoN outline that was lost.
Yesterday I discovered what I consider a colorizer bug, Leo4.1 beta 5 have the same behaviour.
If I write in a @file node

@color
@language python

@ 
    some snap code
    @others
    more snap code
@c

in the output file "more snap code" will be NOT commented, but in Leo that line will appear as a red comment line.
I do not know which is the "correct behaviour" but the colorizer should be consisten with it.

I need to put

@ 
    some snap code
    @ others
    more snap code
@c

in order to obtain the desired behaviour (but I supose that then sub nodes are not incrusted).

/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\
3. Control the Ctrl

Starting LeoN port to Leo4.1 I discovered that in Tkinter Gui code there is

c.frame.log.logControl

and 

c.frame.body.bodyCtrl

I consider this an inconsistency, please choose a notation. Consistent notation help plugins developers to discover and play with the Leo code in a more pleasant way.


/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\
4. UpDown plugin,

I have just developed a tiny plugin that make the body/tree a continuous space. When going down in the body, you will continue until the end of the node, and if insist with the keyboard you will "jump" to the next node. 

This behaviour is usefull when reading text subdivised in nodes, the jump to the next node is automatic.

I will send this plugin to Edward, after receiving some comments of the idea (and restoring the LeoN project outline).

/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\-_-/-|-\

That is all, sorry for the long post, but I had no access to my super work outline. 

Even with this fatal crash experiencie, Leo still being such a great and unique piece of code !

RodrigoB.











</t>
<t tx="rodrigob.121403173614.14">Random notes used as a guidelines for the development. Not intended to document the design. Historic values, curious people will be able to explore rodrigob's cryptic psychology.</t>
<t tx="rodrigob.121403173614.15">
&lt;&lt;What is LeoN?&gt;&gt;

&lt;&lt;Status&gt;&gt;

&lt;&lt;Instalation&gt;&gt;

&lt;&lt;Usage&gt;&gt;


----
LeoN project. Rodrigo Benenson. 2003. &lt;rodrigob at elo dot utfsm dot cl&gt;
Part of the code is based on the research papers of Chengzheng Sun.
Released under GNU GPL. http://www.gnu.org</t>
<t tx="rodrigob.121403173614.16">
What is LeoN ?
--------------

LeoN means "Leo over Network".

Leo is an multiplatform open source extensible outliner. http://leo.sf.net

LeoN is a plugin for Leo that allow near to real time collaboration between Leo editors.
Leo and LeoN are written in Python. http://www.python.org

LeoN require Twisted a network module for Python. http://www.twistedmatrix.com

Leo, LeoN, Twisted and Python are open source multiplatform projects.

LeoN is separated in two parts: the client plugin and the server.
The LeoN plugin allow Leo to connect to a  LeoN server.

To setup a local LeoN system you need both components.
A LeoN server can store as many projects as the users desire.


Features
--------

&lt;propaganda will be written later&gt;

</t>
<t tx="rodrigob.121403173614.17">
Release Status
--------------

LeoN
Release  '0**0' (pre-alpha) (zero power zero)
CodeName "Code Curious"

This first release attempt to destroy the vapourware status of LeoN.

This release DO NOT WORK AND IS NOT USEFULL in any sense. 

But will allow incredules to believe and curious to observe.
The entire framework is coded and most of the API is implemented.
This is the caterpillar that will become the butterfly.

What is working
---------------

- Server startup
- Plugin integration to Leo
- Unit test of client server (connection, node edition, tree edition, administration)
- Client GUI connection and lock/unlock edition 
- Ultra basic web serving of the server contents

- A separated ConcurrentEditable implementation pass the unit tests.

- Twisted server daemonizing and basic persistence

Next steps
----------

- Implement the administration Gui
- Merge the ConcurrentEditable implementation with the whole system
- Support clones
- Refine user interface
- Refine the server side persistence
- create better web publishing systems
- ultra easy installation and setup
- debug, debug
</t>
<t tx="rodrigob.121403173614.18">
Instalation
-----------

The first releases being focused to development have no user friendly install and setup.

To install LeoN you need to first ensure yourself that Twisted is properlly installed in your system. http://www.twistedmatrix.com.
Obviously you also need a working installation of leo. http://leo.sf.net

LeoN is composed of two parts: a client plugin and a LeoN server.

The release has a directory named "leo_plugin", copy all the contents of this directory in the "plugins" directory of your Leo installation. Congratulations you have finished the installation of LeoN !

Please read the Usage instruction to know how to use the code, specially about how to use the Leo(N) client and how to startup a LeoN server.
</t>
<t tx="rodrigob.121403173614.19">
Usage instructions
------------------

The actual release do not provide any funtional version of LeoN but it has some executable code to play with.
We will supose that you have decompressed the release file and that you have followed the installation instructions.

Actually there are four interesant panoramas, presented in logical order:

Code lecture:
    - The first thing that you can do is to open with Leo the file "LeoN.leo" included in the release. It contain an outline of the project and all the related code and notes.

ConcurrentEditable unit tests:
    - Enter into the directory "your_leo_installation/plugins/LeoN".
    - Then execute the file "ConcurrentEditable.py". This will execute three different unit tests. Ensure that this test are passed. 
      More information about what is going can be found in the LeoN.leo outline (and in ConcurrentEditable.py docustrings).
      
LeoN code base test:
    - This test is a little more complicated. You will need three opened console windows and a web navigator.
    - First ensure yourself that your Leo configuration has the Plugins Enabled.
    - In the first console window go to the directory "your_leo_installation/plugins/LeoN". Then execute the file "LeoNtest.py", this will run the unittests of the LeoServer and the LeoClient.
      If everything run fine you should see a lot of passed 'steps' and a message similar to "Look at http://localhost:8788 for the results" and the console will be blocked, do not kill this process : the LeoServer is running.
     - With your web navigator visit the site http://localhost:8788 to see the actual web publishing capabilities.
     - Now comes the funny part. In your second console open with Leo the file "your_leo_installation/plugins/LeoN/LeoNtest.leo".
     - If LeoN is well installed you should see in the log console the message "starting LeoN". The test outline is open, put your eyes over the node "@leoServer ...".
     - Double click the Icon of this node (or push secondary mouse button and then "Connect to LeoServer").
     - If everything go fine an outline will apear, a chat bar will apear, and some log messages will be printed.
     - Repeat this three steps in your third console, using the file "your_leo_installation/plugins/LeoN/LeoNtest_user2.leo".
     - Use your window manager to put both Leo(N) instances side to side, the first instance correspond to the connection of user1 and the second to user2.
     - Click over the different nodes to observe his content.
     - Use the chat bar to chat between the users. (click to the user name to change it)
     - If both user are selecting the same node. Try clicking over the text and start editing. Unsent text buffer if raised and color marked. Sent and unconfirmed text is sunken. Received text appears colored in the other window (clicking over it gives you author info).
       Don't consider the yellow messages in the log pane. This are debug messages that will be hidden for the end user.
     - Don't reclaim if any other strange action breaks the aplication. I had tell you, this release is not usefull.
     
Server persistence and daemonizing:
    - The following procedure explain how to setup and execute the Server daemon, that include server side persistence.
    - Copy the contents of folder "the_uncompressed_release/leon_server" to any other one where you have write access (if you already have write access then this step is optional).
    - Execute the bash command "start_LeoServer" (.sh or .bat depending of your platform)
    - Now open the previously mentioned "LeoNtest.leo" file to connect you to the server and edit some contents.
    - Close Leo.
    - Stop and restart the server using "stop_LeoServer", then "start_LeoServer" and constat that your edition persisted the shutdown. (constatation can be made via "http://localhost:8788" or via Leo again.)
      Note: on this release window users should use stop_LeoServer.py
    

The above instructions should be enough to reproduce the previously presented screenshots. (at http://souvenirs.sf.net)
The intention of this release is to gives you a felling of the real status of LeoN.

Explore the LeoN.leo outline for more infos, details, code notes and future plans.

Feel free to comment this project at &lt;rodrigob at elo dot utfsm dot cl&gt;	 or in the Sourceforge Leo forum (link aviable at http://leo.sf.net).
</t>
<t tx="rodrigob.121403173614.20">Just some copies of the drafts of most of the published topics.</t>
<t tx="rodrigob.121403173614.21">Leo over network requirements
-----------------------------

This is my résumé of the Requirements and design issues for Leo over the Network. (LeoN).

First in sake of simplicity a N-clients/One server architecture is imposed, being much more easy to design and implement.
Also it's required that the code could be as most Plugin as possible and as most python Modules independent as possible (one and only one installation required).

Now, the list presented approximately in the logic order of implementation:

&lt;&lt;Step one, Merging&gt;&gt;

&lt;&lt;Step two, Publishing&gt;&gt;

&lt;&lt;Step three, Interacting by turns&gt;&gt;

&lt;&lt;Step four, Realtime interaction&gt;&gt;

Please comment this document.

RodrigoB. </t>
<t tx="rodrigob.121403173614.22">Step one, "Merging":
- A tool to merge two Leo files.
This is independent of the networing stuff, but is an essential piece of code.
This is the first real domain specific difficulty to solve. There should be a logic for the Node merging and for the Tree (nodes dispositions) merging.

(Guy X send a mail with a new version to Guy Y. Avoid hand edit for Guy Y.)
(Guy X send to the server a new tree/branch version, allow Guy X to solve the diffs)

</t>
<t tx="rodrigob.121403173614.23">
Step two, "Publishing":
- The server should be seen as a branch in the local client Tree.
That mean a congruent integration in the actual client. Could be something like "@leo-server 123.56.68.1:9543 Homeworks".
(Guy X connect to server A)

- The server should present an HTML output to see the outline via the web.
Then editing/merging the server version will also create a Publication of the Leo outline. This code can also be developed independently of the networking stuff.
(Guy Z know nothing about Leo and want to read that document )

- There should be a way to merge a local branch to the online tree.
This is a smart interface implementation for the problem 1.
(Guy Y want to merge his local branch to the server version)
</t>
<t tx="rodrigob.121403173614.24">Step three, "Interacting by turns":
- The Leo client and server should integrate a chat service.
This allow a better interrelation between online editors.
(Guy X want to know who is reading/editing the same node, and discuss with him/them some related topics)

- There should be a way to edit online the outline, at least via node locking/unlocking.
The users could see who is editing and reading the Node. This is the second truly difficult problem.
(Guy X want to edit that horrible bug)

- There should be an administration system to setup at least four boolean permisions for each user (+plus the user 'anonymous'); Read, Edit nodes, Edit tree, Admin permissions.
(The server owner don't want every one to edit his creation. Only trusted person should be able to edit it, we need some control)
</t>
<t tx="rodrigob.121403173614.25">Step four, "Realtime interaction":
- There should be a way that multiple online users edit on realtime the same Node.
This is the final step and is truly difficult. Probably this code should be merged from a parallel (but related) project.
(Guy X,Y,Z having a code party.)

- The client should show the editors cursors and edition on realtime.
Adquire the status, of Hydra Open Source, Multiplatform, Clone.
(Guy X,Y,Z enjoying the code party.)

Some features were intentionally omited:
- Versioning system. (there exists better solutions)
- Voice chat. (there exists parallel solutions)

</t>
<t tx="rodrigob.121403173614.26"></t>
<t tx="rodrigob.121403173614.27">Hi,

this post pretend to resume the status of LeoN (Leo over Network; that is the implementation of the Colaborative features).

Two or three month ago the Forum activities incremented notoriously and it becomes clear that Leo should deploy his paradigm over the wires. Actually Leo 3 is great for home usages, but today most computer users use Internet as a primary source for information exchange, it was to sad to use Leo just as mail attachments... So Leo over Network adopted a shape, post by post most convergence and similar desires where verbalized. 

This stage was sumarized (at least I tried) in a list of requeriments (http://sourceforge.net/forum/message.php?msg_id=2009949).

After this I proposed a divition of this requirements in a logical order of development from the most urgent/difficult to the less urgent/difficult. Then LeoN was splitted into four steps (http://sourceforge.net/forum/message.php?msg_id=2025658). (Merge, Publish, Turns edit, Realtime edit)

By the same time Leo was living the Leo4 revolution, a lot of confusion, meditation and enlightenment appeared in this obscure era. In the same time some post were oriented over the technical aspects of LeoN, more speciffically which software should be reused.

My personal apreciation and study make me decide that Twisted was clearly the best tool for LeoN. The pro and cons were posted, in junction of the first draft of LeoN design (http://sourceforge.net/forum/message.php?msg_id=2040564)

Even if the four steps were in logical order there are mostly orthogonal.

Step1: was very discussed in the forum an seems to be implemented into the Leo core, as some kind of Merge assistant. (no clarity about the specific implementation until now, some technical aspects were discussed previously)

Step4: it is the hardest part and should probably left to a group of pythonic computer scientists (anyone there ?)

Step2 and Step3 are the target of the code I'm working on. First I'm focusing on Step3, but Step2 is already included in the design.
Step2 has many viable implementation, XSTL seems one the bests. The actual design propose a parallel implementation of Step2, this will mentioned in the following lines.


Actually I have reached the first stage in the code development, and I want to present the design aspects.
Much of the actual LeoN design was driven in an autocratic fashion, but Open Source is very much like lema, Just do it.

The core Server/Client is working and now I will focus on GUI integration.

I'm not a Professional Programmer but I thing to have enough experience on the area to create an usefull implementation. My design/coding style is very much like Sculpture (no I'm not a sculptor). I have an idea of how the final figure should look, but I code the big parts and then refine, trying to always having enough space to what we want to do. This the philosophy of the actual code.

The code implements:

    - Users login/logout to outline nodes, using an url style.
    - Outline retrieval
    - Users chating
    - Per node chat rooms
    - Users presence
    - Remote administration of permissions (very much on the Zope style), creation of accounts definition of access points in the outline, and definition of per node permissions.
    - Multi users node editions, on a lock/unlock schema
    - Tree editions, on a lock/unlock schema
    
    
The design will allow:

    - Good enought Leo GUI integration
    - Clones
    - Persistence (should already be there but I have not tested it, I will wait until the GUI integration is ready)
    - (Hope so) good enought multiuser edition.
    - Configurable Direct Weblishing of the outlines
    - Heuu... 
    
The list maybe look impresive, but remember this is the first implementation, no realeases, no real usage testings (all tests are made at localhost...), for your perspective consider LeoN vapourware.
 
As mentioned in a previous post as the code is based on Twisted almost 75% of the code is already documented. (uff...) (anyone interesed should access to twisted matrix, howto, Perspective Browser topics)

So lets talk about the code,
there are three files:
LeoServer
LeoClient
LeoNtesting, this file run automatic operations at the core level, to test the code methods.

Here is an introduction of to the objects manipulated, instead of describing one by one and let you get the figure, I will give you the figure and you can imagine how each one should like.

==== Design notes =====


intro
-----

LeoN is strongly based on the Twisted design.
This description is restricted to the LeoN case, the architecture is very flexible, but here I expose only a particular case.
The architecture is One Server multiple Clients, in sake of simplicty, and to allow publishing. 

Everyting is strongly Object Oriented. Twisted provide a code base for client/server implementation, for connections, for authentication, for object exchange and for remote procedures calls. We consider all of this tools as done, and we focus the work on the application specific logic.

Dynamics
--------

The Client is simple.
The Server is not so simple.

The Client has a Referenceable Object that is given to the server during the connection. This allow the server to trigger some action on the client side.
The client instanciate this Referenceable Object and then connect to the server.
There exist one LeoClientReferenceable instance per CollaborativeOutline that the client access.

The server is a Twisted application. This application create a Perspective Broker Factory to implement Multiple Services. Each Service is associated to an Authorizer Object that manage the access to the services.
Then LeoServer define the LeoService. The Leo Service has one persistent instance of the so called CollaborativeOutline class.

This class implement is the central element of the LeoServer (everyone touch it).

When a Client want to connect to the LeoServer it is received by the PerspectiveBroker factory. This one use the associated Authorizer to allow access of the client to the LeoService.

The LeoService is then charged to create a Perspective of the Outline. There is one Perspective per client connection. More specifically, the LeoService bring to the client an OutlinePerspective (subclass of Twisted Perspective), I repeat, the LeoService bring an OutlinePerspective to each LeoClient (start to make sense?).

The OutlinePerspectives connect themself in the CollaborativeOutline that have the informati on and methods necessary for the Perspective interactions, the CollaborativeOutline keep a track of all the related OutlinePerspectives. Of course the Collaborative Outline is by itself an Outline so it also contain the data nodes and the tree structure. The Collaborative  Outline is supposed to reuse the logic of Leo.

The identification of the nodes is made via an Url system (instead of a remote object reference). The Url approach allow a better encapsulation of the Outline object, is more natural to the users and will ease the integration of the publishing system.


The system logic is then centred into classes:
- CollaborativeOutline, contain the data and track the users.
- OutlinePerspective, is the access portal of clients to the CollaborativeOutline
- LeoClientReferenceable, is the access portal of the Server to the user client.

Admin
-----

A Perspective give you a view of the system. There is another perspective named AdminOutlinePerspective and allow the admin users to edit the outline permissions. 

The admin schema have some similarities to Zope.
As the center object is a tree the permissions have the transversality property the permissions of a parent node are herited by the child nodes.

There are Three Security levels on LeoN:
- Authorizer Accounts; if the user has no account it will not be able to login.
- Identity keyring, also named: acess points; when the user is identified the server obtain an Identity object, this object contain a list of (Service, access point) pairs. An access point is a node url. The user will be able to logon only on they access points or in their children nodes.
- Permissions; after having checked the identity and verified that the user has a valid key to access to a certain outline, each node have a set of permissions defined for the mentioned user. The permissions are "Read", "Node_edit", "Tree_edit". This will limit the actions of the users on the outline. 

The AdminOutlinePerspective allow the admin users to add/delete accounts, define users access points and set the per node permissions (but not to see or edit the outline, another perspective is required).

To access to the AdminOutlinePerspective the user will have to request access to the url "/&lt;some_node_url&gt;/_admin". (so "_admin" is much like the zopist "manage").




==== end of Design notes =====


I could enter in more details but I think they are not necessary (except if there is a request).


As I mentioned now I'm focusing in pluggin in LeoClient into the Gui.
Latter I would like to develop into LeoServer a web service that directly publish the Outline, this is essentally very easy, the hard part is how to make it truly flexible (as users always want more...)


This post describe roughtly (in a poor english) the status of LeoN and what I pretend it to be.
I don't need any special feedback because I will work on it at least until the first release. But as I said I prefer to write what is going on, to avoid confutions, deceptions or redundance.

I still planning the first release for this or the next weekend (depending on how hard Leo plugins result and how I feel about my final exams..)


RodrigoB.

</t>
<t tx="rodrigob.121403173614.28">14/06/03

Hi, 
it's time to news!

Screenshots
-----------

For the impacients (and not so impacient too), the first screenshots of  LeoN at

http://ryalias.freezope.org/souvenirs/leon/screenshots


The job until now have been done fluently and is very pleaseant to observe the first results. It's clear that the first times are always easy and the hard part come in the middle time of the code development. Due to this it is important to focus very well the development from the first moments.

Status
------

The actual status of LeoN can be resumed to:
- Step1 have been left to the core Leo development
- Step2 and Step3 code base are ready at exception of two important items (as far as I know)
- Leo &lt;=&gt; LeoN gui integration is alpha 
- Step4 is being evaluated


The 'two important items' are:
------------------------------

- Clones, this have been intentionally left due to Leo 4.0 clone code inestability. As it was mentioned there is class CollaborativeOutline that give an api to manipulate the server internal outline. The clone manipulation still unimplemented because I pretend to reuse the Leo logic into this class. For the first times Clones is not a essential feature (very important, but it can work without it).

- Anonymous/Guest users, in my laziness I have not implemented this special case, there are many way to manage them and I still having not decided between the tradeoffs.


Leo &lt;=&gt; LeoN gui integration:
-----------------------------


- I know that Edward has put an important energy in making Leo easy to extend, but anyway the Leo code extension and complexity make the job not always very easy. Some things were trivial, some things seemed trivial but did not worked and other one still very complicated.

I'm a bit worried about the Leo code complexity I have the strange feeling that there are a lot of strange and redundant code, the object encapsulation seems broken or simply I still do not catching the coding style. Anyway I ask myself if Leo 4.0 should not include a code pruning.

(Example: insertFirst, insertLast, insertNChild could be simply inserChild(*args, position=-1); where position is 0, -1 or N respectivly)

The most difficult Gui integration seems to be the Vnodes manipulations. The vnode creation (when the outline headlines are downloaded) was trivial. But intercepting all the event over the outline seems hard because Leo have a lot of commands for 	Dragging, moving, cutting, Pasting, Inserting node, deleting nodes and I have not found they commom denominator. I'm maybe wrong, but I gonna need some orientation.

Appart from this difficulty, and some minors details (that maybe will become bigger with the time, or maybe not) I have two very simple punctual  requests: (sorry, my laziness will not let me put this on a separate post)

First:
Let the mainloop in a special function. So plugins can replace it. (LeoN need this, the Tk update is a event into the Twisted reactor)

Second:
The LeoGlobals redirect class need a flush method (just for interface compatibility)

leoglobals/debugging/files/redirecting/methods/

    def flush(self, *args):
    # just for compatibility
    return
 
I will post in future messages my questions about some tricky integrations requirements.

I think that LeoN need a so deep integration with Leo that after it, there will be no doubt about the plugin architecture success.


Step4 is being evaluated:
-------------------------

Well that it is an important point, now that the code is starting it is not so clear to me how much we should wait before the start of the Step4.

I have been reading the key reference paper:

Reversible inclusion and exclusion transformation for string-wise operations in cooperative editing systems (1998)
http://citeseer.nj.nec.com/sun98reversible.html

That describe the algorithm used in REDUCE (link posted some days ago).
The only part left to the implementor the structures required to allow the implementation of the described operators.

Personally I believe that the value of LeoN with Step4 will be much, much major that without it (the same thing can be said for Step1), and, obviously the job is much more motivating that dealing with Tkinter interfaces (but not more or less important).

This bring us to the next ambiguity.

The near future:
----------------

What should be done in the near future?

I'm a university student that is already involved with time demanding projects. I have time enougth to work on LeoN, but a limited time. 

This is probably the most important open source comunity project in which I have participated and I would know what do you think should be the logical order.

Essays:
1- Keep the code, work on it until Step2 and Step3 are usable and then release. (conservative approach)
2- Release the alpha code and let work like ants. (liberal approach)
3- Let the code as it is, focus on Step4 and then finish Step2 and Step3 to have a valuable release.
4- Release the alpha code, let other people finish the interface, and focus yourself on Step4.
5- ?


Personally I'm tempted to follow option 3, but I know it is risky...
Comment, opinion, any co-coder interested?


Final comments
--------------

LeoN is very exiting and I believe (if success) will present a great advance in for the OpenSource community demonstrating the power of python, twisted, the Leo outlining paradigm and the OpenSource community ability to develop usefull code (How much I would like to had access to LeoN 1.0 five years ago...).

I hope that LeoN will have an usable release in two or three month and that it will have a full featured version during March 2004.

(If you have not seen the screenshots yet, do it now.)

RodrigoB.

</t>
<t tx="rodrigob.121403173614.29">29/06/03

Hi!

It's time to news again. This last weeks were my final exams weeks but LeoN development is going on as planned.

The last two weeks where focused on the Gui control, intercepting the whole list of actions that the user can do into the collaborative outline. There still some importants events to manage, but I think almost the base code is there. As mentioned this stage is absolutelly non trivial nor little; and is characterised to be some how frustating ("Tk marks are before or bellow a charater? Event occurs before or after effects?", and similars) and slow (because you have to test by hand the gui to debug it). The important elements missing will be done at the time it becomes strictly necessary.


The LeoN code is already pretty big and relativelly complex (3500 raw lines count) and there is a big list of things to do. Anyway no one said it would be easy.
Somes days ago I drafted the code base for Step4, hopefully the more important piece of code, due of it reusability and because I think it will give to LeoN an important sparky effect (near realtime multiuser text edition).


So now the actual plan is:
- Focus the next two weeks on the implementation of Step4 and his unit tests.
- Release the Step4 code. (because it is usefull without Leo and could be used in parallel projects)
- Integrate Step4 and Step(2,3) (one week)
- Move the code over Leo 3.1x  and Twisted 1.0.6 (which unfortunelly changed some classes used in LeoN (cred module)) (horizont: one week)
- After that I will focus strictly on finishing the usability elements and (if everything go fine) will start the releases iterations. This stage will have at least the following milestones:
    - Finish and debug the interface hooks (this can be long...)
    - Implement server persistence (should be easy)
    - Implement the admin interface (should be boring)
    - Implement Clones (two weeks if things go fine)
    - Improve the LeoN web views (implement more than one view  model?)
    - Allow as easy as possible installations

Of course the releases will be all alpha during a probably long period until the developers are happy and then we will switch to beta and when everyone will be happy : the first stable Release !

I'm pretty impacient to finish the vapourware status of LeoN, we have the luck that the timing are acceptable, and Leo has some importants things to do before LeoN will become the first priority. This will give me the time to work on the mentioned plan.

RodrigoB.</t>
<t tx="rodrigob.121403173614.30">As said, it is times to news. Briefly.

about step4
-----------

The code is ready and running since wednesday (mercredi) on the morning, but until now I'm  grumbling-grumbling with the code to get it working as supposed; I have found some minor bugs and solved some conceptuals problems and bugs. Debugging code of someelse algorithm is notoriously harder than working on your own ideas but the work give his fruits and each day we are one step nearer to our dreams.
Most of the hard problems are due to some ambiguities or not so clear ideas in the papers, so I have to crunch my brain to guess the correct way to manage the presented abstractions (or apply a 'guess, try, evaluate' strategy).

Due to this problems, and after five days of debugging work I will delay the code release until I get the unit test passed, this should not take more than a week more (I hope so, but you never know if the actual bug is or not the last one).


what is next
------------

- Finish debug of step4
- Implement and test the one server various clients collaborative editing (a special case of the above class)
- move codebase to 3.12b* and twisted 1.0.6
- merge step2, step3, step4 
- start the release of the code snapshots.
- start working on last frozen elements and on the Todo List:
    - hooks installations and debug (starting by node renaming)
    - admin interface
    - server side persistence 
    - clone support
    - cut and paste (with download interface)
    - better web server views
    - design a web plugin system ?
    - debugging, debugging
    - as easy as possible installations
    - work on the design of LeoN2 features

I will stay working on a two weeks development cycles, and post news at the end of each cycle.


RodrigoB.</t>
<t tx="rodrigob.121403173614.31">This last weeks have been of miscealenous advances. I had to focus on my other projects but some interesant advances had been made in the LeoN rivers.

- Step2,3 and 4 were merged in only one project outline.
- Update of the code base to use Leo 3.12 and Twisted 1.0.6
- Now LeoN is fully installable as a simple Leo plugin (thanks Edward)
- The base persistence for the server side was enabled, allowing an easy server deployement (thanks Twisted).
- I'm preparing the release '0**0' (zero power zero)
- Work and energy has been used to create a "NClients, one Server" adaptation of the ConcurrentEditable algorithm/implementation. Achieving this is important because:
    - it reduce the bandwith usage of the clients (instead of sending one packet to each client only one emition is required), making the implementation more usable and scalable.
    - the packet size do not depend of the number of sites. 
    - the logic for client insertion is not distributed, so the connection to the system should be faster and less error prone.
    
  -&gt; Actually the big code and the unit test are coded; of course now I'm figthing against the universal chaos to get the big code do what the unit test expect of it. I will release LeoN '0**0' (the first non-functional release) as soon as ConcurrentEditable pass this unit test.

Now I'm back into classes so my productivity will decrease a little but LeoN still being an important project, I'm trying to have cool demo for the anual "Electronics Department Students Exposition" in two months.

There is a huge list of very important things to do but the advances are putting us very near to the first usable prototype.
So the next steps are (in a probable order):
    - finish ConcurrentEditable Centralized Network classes (make it pass the unit test).
    - release LeoN '0**0'
    - implement the admin interface gui
    - Merge ConcurrentEditableServer with the code base
    - continue with the gui integration refinement (starting by node renaming problem)
    - clone support
    - cut from and paste to networked nodes (with download interface)
    - better web server views
    - design a web plugin system ?
    - polish, polish
    
RodrigoB.</t>
<t tx="rodrigob.121403173614.32">@nocolor
@language plain

Hi!

There have been a lot of work since the last time, probably very little advances but this mile was very suffered. Anyway today we mark a milestone: the first non-functional LeoN release. (impatient can just go to the link at the end of the post)


This post has three topics:
    - About ConcurrentEditableServer and ConcurrentEditableClient
    - Cocodoc
    - LeoN release '0**0'

About ConcurrentEditableServer and ConcurrentEditableClient
------------------------------------------------------------

This is the point that was missing in the first release of ConcurrentEditable.py, and was the last part of code that I wanted to develop before this release. The work became very hard because the adaption of the original paper network topography to a more engeeniered design is not trivial. I had first attempted the implementation of an abstraction layer that allowed a near to optimal usage. After one week and four days figthing with the implement the indeniable became evident such abstraction layer is imposible. Assuming this I had to affront a more terrible problem how to implement a distributed login/logout system is an eficient maner. There are many approach possible but non of them convinced me, I knew that there was something, something.... After four days of dense grumbles, grumbles the monday at 0.37 AM, while I was almost sleeping I got an Edward's "Aha". The final solution seems very strange in a first perspective, being an apparently suboptimal approach, but this one, that idea was the right one, I could feel it. A simple, strange idea that transformed a difficult, sluggy, full of special cases problem into a clear, simple and robust implementation. It tooks me just some hours to get the third unit test passed, and the final piece for this release was ready. More detail of this topic can be found in the documentation of the file ConcurrentEditable.py.

Actually my principal fears are about some non tested cases of ConcurrentEditable, I think it will crash under special conditions. I think I will need to transform special cases into infinite recursive structures... But anyway we will need more tests to see that, and I'm mentally prepared for such modifications.

By the moment let enjoy this milestone !

Cocodoc
-------

Some days ago I had a meeting with that "so special human specimens" that we can found at my university, a very smart guy with a unique perspective of the world, we had a good chemical approach (heuu, is this english ?). During the hours of talking I mentioned the LeoN project, obviously it was facinated as himself had attacked the problem before. He made me some sugestions for the project and explained to me some problem that I could found during the deployment, at a network level. I could not convince him about the originality of the project. He have the profound conviction that 'everything already exist' in other word, under another circunstances, but the same human idea.
He dedied almost one hour seeking the web until we found/remembered "Cocodoc" the more similar project that we probably will ever found. It is amazing, a 1997 windows 3.1 project. It looks very similar to the Radio Outliner, what a vision ! A must.

http://www.trc.nl/publicaties/1997/cocodoc.pdf



LeoN release '0**0'
-------------------

I'm very pround to announce the first non funtional LeoN release. There are no promises. I had documented exensivelly the installation procedure and usage procedures. 
I'm very interesed to get feedback to know if the installation/execution is reproducable in other machines.
Also I would like to get some feedback about the release format, because it not suposed to change very much in the future releases so I would like to patch it if necesarry.

This release pretend to give to the curious and inside of what really is LeoN and how to reproduce the presented screenshot. It is absolutelly non usefull, but the code present the strict minimal implementation of every aspect that LeoN will cover.

I do not think that I need to say anything more. I had previously mentioned what is going on, what I pretend LeoN to be and what is needed to be done to attain the objective.

As usual the code is aviable at:

http://ryalias.freezope.org/souvenirs/leon


Thanks for your support and feedback.
Long live to LeoN, Leo and the OpenSource community!

RodrigoB.
</t>
<t tx="rodrigob.121403173614.33">what LeoN require from Leo.</t>
<t tx="rodrigob.121403173614.34">leo 3.12 Start problem
----------------------

Hi,

today I'm moving LeoN code to Leo 3.12 and Twisted 1.0.6 and I have detected a problem with the start2 hook:


&gt;&gt;tag argument                                              keys in keywords
&gt;&gt;(hook name)  overrides       when called                  dictionary argument
&gt;&gt;---------    ---------       -----------                  -------------------
&gt;&gt;"start2"                after opening first Leo window    c,v,fileName


but leo.py call

&gt;&gt; 	doHook("start2")

so the hooks of start2 do not receive c,v or fileName.

I supose this is little bug.


I had also troubles with the runMainLoop. The function is now appart from the main code. But I had not found a way to overwrite it being defined into the module. Because if the plugin load the module "leo.py" and overwrite the function, this only work as a local overwrite. I think there is no way to do it if the "runMainLoop" function is not passed as an atribute of an already instanciated object. So I needed to edit a little more the leo.run function.

at line 14, after creating app and before calling step1 &gt;&gt;	app.runMainLoop = runMainLoop # to allow overwritings
and at the last line                                    &gt;&gt;	app.runMainLoop(root)
    
By this way LeoN call "app().runMainLoop = myMainLoop" at "start1" and the magic trick is done.

There is also another issue about installing LeoN as a plugin. Due of the extension and complexity of LeoN it is a plugin separated in various files (three at the moment). So I created a "mod_LeoN.py" (fourth) file that import the required definitions to install the plugin hooks.
The problem is that I could not found a way to import the module "LeoN" if it is located in the plugins dir (where I supose is the correct place). By the moment I put it into the "src" dir (via a symbolic link) but I think that Leo should extend his sys.path to include the plugins dir in order to be able to make import from there.


Finally I would like to mention that now that I will soon come back to the Gui programming and I still not having found a solution to be able the detect the End of a Node Renaming operation (see a the previous post http://sourceforge.net/forum/message.php?msg_id=2081905). This will soon be a non evitable problem to the LeoN development.

RodrigoB.</t>
<t tx="rodrigob.121403173614.35">20/07/2003 

Actually LeoN is getting near and near to the Non Return Line (an amount of code enough for condensation of the vapourware).
To my eyes there are three dangers:
- PB will overload the bandwith
- Problems during adaptation of ConcurrentTextEdition for concurrent outline edition.</t>
<t tx="rodrigob.121403173614.37">Binary package
--------------
chalks.exe
README
COPYING
AUTHORS
chalks.ico (should be embedded inside the executable later)

Source package
--------------
Chalks.leo
README
COPYING
AUTHORS

src/
    Chalks.py (main executable script)
    Chalks.xhtml
    *.py
    Test_*.py
    setup.cfg (for generating RPMs)
    setup.py (distutil install script)
    
</t>
<t tx="rodrigob.121403173614.38">Having done a Concurrent Text Edition system how to implement a Conccurrent Outline Edition system ?

Need a smart mapping between outline data and text data; and between outline operations and text operations.

</t>
<t tx="rodrigob.121403173614.39"></t>
<t tx="rodrigob.121403173614.40">
"3dm":http://www.cs.hut.fi/~ctl/3dm/

"pyxi":http://www.udanax.com/green/</t>
<t tx="rodrigob.121403173614.41">There are too much undefined elements. Probably the publishing action should be a plugin dialog, that let you select the method and the target.

For my perspective I see usefull an Leo Outline -&gt; xHTML translator and an:
- FTP uploader
- SCP uploader
- XMLRPC Zope uploader


The dialog should be an Upload Dialog with a "Render to HTML" checkbox.


Also LeoServer can be extended to render HTML from the CollaborativeOutline. The design need to focus on flexiblity. 
There LeoServer use the Woven object.</t>
<t tx="rodrigob.121403173614.42"></t>
<t tx="rodrigob.121403173614.43">
Some weeks ago I started a more serious study of Twisted Matrix.
Three week ago I only knew that Twisted was pythonic, cool, powerfull, flexible, big, with some funny class names and complicated for a rapid first approach.

Now I have finished my theoric study of Twisted, at least the component of direct interest for LeoN steps 2 and 3, this are my conclusion:

- To my eyes Twisted have all the necessary to implement LeoN.
- It have funny class names (conch, mermelade, perspective, the banana protocol, ...).
- It is big because it does a Lot of things, anyway only the required modules are loaded on the application.
- As it is big it can become complicated.
- Not everything is documented, the documentation is Excellent but the code comments does not seems promising. Most of the necessary (80%) is documented.
- Twisted apply strongly his own paradigm. 
- Twisted is very object oriented.
- The developers are smart enough to make some hard thing incredibly easy.
- It is very pythonic, but on the Object Oriented line.
- The design of networking solution is original, until know nothing said that it is specially bad, so I can suppose that it is in some way good.
- I believe that the learning curve is for programmer is "normal", not very slow because everything is just a strong object orientation, not too fast because there is a lot of documentation to read until you understand the basics.
- There is a lot of nomenclature, that I'm not so sure it is indispensable, but anyway is usefull to know what we are talking about.
- Twisted is not enterely mature. Looking the mailing list history and the last release date I suppose that the Twisted community is alive.
- Twisted seems smart. It is designed and documented in such a way you can get your app runing and doing what you want to.
- As pythonic Twisted is cross platform, they have some work on Java and other stuff, but I feel a *nix orientation.
- Personally I take the risk of innovating using the Twisted Framework.



So lets go to facts:
Pros:
- It is pythonic
- It implement (I will mention only the stuff that look usefull for us):
    - A web server
    - A lot of protocols
    - A framework for network application development
    - A persistence system
    - A very smart Network services integration system (&lt;- cool feature)
    - An authentication system
    - A remote procedure system (this is the key for an easy development of LeoN) (&lt;- cool feature)
    - Implementing chat services is trivial. It also have it own (basic, but it works).
    - It is integrable with GTK, QT and TK applications
- To my eyes Jabber functionalities are implemented in less than a week.
- It is well documented
- As Twisted is a entire Internet Framework it will allow us to focus on the important LeoN aspects, Twisted cover the details; less code to maintain.
- In the worst case LeoServer will depend on one and only one external module (that can do Everything (on the network universe of course)).
- The Leo comunity fit very well on the Twisted users group (people that need a networking layer for them apps). The LeoN needs fit well with the Twisted possibilities.
- If the Twisted design fit with LeoN we have 80% of the documentation already wrote (&lt;- cool feature)


Cons:
- A "lot of protocols" do not include yet Jabber (some attemps on the way)
- It is big, that can be confusing
- It have strange names
- You have to know about Protocols, Factories, Reactors, Mermelade, Perspectives, Identities, before we can start talking about LeoN. (&lt;- ouch)
- Not all the code is stable (the portions of interest are labeled as 'Stable' and 'Semi Stable') (&lt;- this can become dangerous )
- Even if the documentation is good not everything is documented
- Anyway who know's about Twisted Matrix? Neo appears?
- If we use a so big framework that mean that we will be asking every time 'How I do That thing on Twisted'?, this could become boring.

Ok I thing you got the point. Feel free to ask about some Twisted details ("yes how exactly do you pretend to ... "), I will be pleasant to talk about.

I will try to ongo working on this, to see the practical aspects (let's start coding ;p ).

Here is my actual design draft:
- To have a server very simple to setup  (probably zero config) (this is easy for Twisted)
- All the management is made via a transparent remote procedure call protocol (using Perspective)
- The LeoN plugin edit the main Leo function to install the Twisted callback on the Tkinter loop.
- The server provide a Perspective Broker service
- The Leo client connect an user to the service. The handshake do the authentication and exchange reference for remote objects manipulations.

Then the client uses the server object methods:
- .get_outline(outline_path)
- .get_actual_users_list()
- .set_presence(state)
- .select_node(node_path)
- .send_message(to, txt)
- .lock_selected_node()
- .unlock_selected_node()
- .create_node(node_path)
- .update_node(node_path, content)
- .delete_node(node_path)
- .move_node(node_path, new_name)
- .set_cursor_position(line, col)
- .insert_text(startpos, txt)
- .delete_text(startpos, len)

The server has access to the client methods:
- .post_message(from, txt)
- .post_presence(who, state)
- .create_node(node_path)
- .update_node(node_path, content)
- .delete_node(node_path)
- .move_node(node_path, new_name)
- .set_cursor_position(who, line, col)
- .insert_text(who, startpos, txt)
- .delete_text(startpos, len)

This is a very rought draft, actually there is a lack on the aspects:
- How the outline is managed on Leo, I just have a very vague idea about ,I'm suposing that the outline is embedable in a object with the mentioned methods. (create, update, delete node; insert, delete text)
- Twisted define the Cacheable class. This one is supposed to be a big object that people is observing and someone edit him, then the updates are send to the observers... I have to check how this class could be used for us purposes...
- It is not so clear to me how is the best interface for the local administrator of the server. I would that the server could be controled from the local client, _and_ from an external script. I have some ideas, but this still not being so important.
- by the moment I will not see if the used elements of Twisted are or not easilly extracted; (maybe there is a python script to extract all the method and class code out from a code hierarchy, just like py2exe do it?).

I will left those topics after I have the first code running.


by the moment everything are ideas, but I believe that we are not so far of a realization....</t>
<t tx="rodrigob.121403173614.44">The code will be base the Perspective Broker, using authentification and creating a presistent published object.

First we will the search the most usefull toy example to work on.

Then we will create a simple but funcional development framework, that load the server and run the client.

Then we will check the design and start the base implementation.

After that we will seek the LeoCode (hopefully 4 alpha &gt;1 ) to get the internal data structure (something like a chain of vnodes).
With that we will try to make the first plugin that automount a server and allow outline publishing and retreiving, based on authentication.
 
Then we will focus on Chat functionalities.

Finally we will implement the lock/unlock edition system.

That  will be release beta 1.
</t>
<t tx="rodrigob.121403173614.45">pb.Cacheable

Cacheable is a variant of Copyable which is used to implement remote caches. When a Cacheable is sent across a wire, a method named getStateToCacheAndObserveFor is used to simultaneously get the object's current state and to register an Observer which lives next to the Cacheable. The Observer is effectively a RemoteReference that points at the remote cache. Each time the cached object changes, it uses its Observers to tell all the remote caches about the change. The setter methods can just call observer.callRemote("setFoo", newvalue) for all their observers.

On the remote end, a RemoteCache object is created, which populates the original object's state just as RemoteCopy does. When changes are made, the Observers remotely invoke methods like observe_setFoo in the RemoteCache to perform the updates.

As RemoteCache objects go away, their Observers go away too, and call stoppedObserving so they can be removed from the list.

</t>
<t tx="rodrigob.121403173614.46">The log window will be modified to become a chat service. And an extra menu bar will be installed for any necesarry option.
The log will have a Bottom bar with two elements:

To: &lt;combobox&gt; | &lt;textentry&gt;

The combobox will contain ['All', 'Room'].extend(&lt;online users list&gt;)

We will define a class named GuiWindow, the default implementation will hook itself to the LeoGui.</t>
<t tx="rodrigob.121403173614.47">
intro
-----

LeoN is strongly based on the Twisted design.
This description is restricted to the LeoN case, the architecture is very flexible, but here I expose only a particular case.
The architecture is One Server multiple Clients, in sake of simplicty, and to allow publishing. 

Everyting is strongly Object Oriented. Twisted provide a code base for client/server implementation, for connections, for authentication, for object exchange and for remote procedures calls. We consider all of this tools as done, and we focus the work on the application specific logic.

Dynamics
--------

The Client is simple.
The Server is not so simple.

The Client has a Referenceable Object that is given to the server during the connection. This allow the server to trigger some action on the client side.
The client instanciate this Referenceable Object and then connect to the server.
There exist one LeoClientReferenceable instance per CollaborativeOutline that the client access.

The server is a Twisted application. This application create a Perspective Broker Factory to implement Multiple Services. Each Service is associated to an Authorizer Object that manage the access to the services.
Then LeoServer define the LeoService. The Leo Service has one persistent instance of the so called CollaborativeOutline class.

This class implement is the central element of the LeoServer (everyone touch it).

When a Client want to connect to the LeoServer it is received by the PerspectiveBroker factory. This one use the associated Authorizer to allow access of the client to the LeoService.

The LeoService is then charged to create a Perspective of the Outline. There is one Perspective per client connection. More specifically, the LeoService bring to the client an OutlinePerspective (subclass of Twisted Perspective), I repeat, the LeoService bring an OutlinePerspective to each LeoClient (start to make sense?).

The OutlinePerspectives connect themself in the CollaborativeOutline that have the informati on and methods necessary for the Perspective interactions, the CollaborativeOutline keep a track of all the related OutlinePerspectives. Of course the Collaborative Outline is by itself an Outline so it also contain the data nodes and the tree structure. The Collaborative  Outline is supposed to reuse the logic of Leo.

The identification of the nodes is made via an Url system (instead of a remote object reference). The Url approach allow a better encapsulation of the Outline object, is more natural to the users and will ease the integration of the publishing system.


The system logic is then centred into classes:
- CollaborativeOutline, contain the data and track the users.
- OutlinePerspective, is the access portal of clients to the CollaborativeOutline
- LeoClientReferenceable, is the access portal of the Server to the user client.

Admin
-----

A Perspective give you a view of the system. There is another perspective named AdminOutlinePerspective and allow the admin users to edit the outline permissions. 

The admin schema have some similarities to Zope.
As the center object is a tree the permissions have the transversality property the permissions of a parent node are herited by the child nodes.

There are Three Security levels on LeoN:
- Authorizer Accounts; if the user has no account it will not be able to login.
- Identity keyring, also named: acess points; when the user is identified the server obtain an Identity object, this object contain a list of (Service, access point) pairs. An access point is a node url. The user will be able to logon only on they access points or in their children nodes.
- Permissions; after having checked the identity and verified that the user has a valid key to access to a certain outline, each node have a set of permissions defined for the mentioned user. The permissions are "Read", "Node_edit", "Tree_edit". This will limit the actions of the users on the outline. 

The AdminOutlinePerspective allow the admin users to add/delete accounts, define users access points and set the per node permissions (but not to see or edit the outline, another perspective is required).

To access to the AdminOutlinePerspective the user will have to request access to the url "/&lt;some_node_url&gt;/_admin". (so "_admin" is much like the zopist "manage").



Data flow
---------

The system behave like web browsing with pages autoupdate.
When the client request the outline, it receive a hierarchy of headlines.
Each time it request the content of a node is receive the node content.  and then it will receive all the updates to it.
</t>
<t tx="rodrigob.121403173614.48">- Post patch for twisted.cred.perspective (Type -&gt; Types, report error type):

the cause:
----------

import types
isinstance(u"/test1", types.StringType) 
=&gt;0

The patch:
----------

class Perspective:
    """I am an Identity's view onto a service.

    I am the interface through which most 'external' code should
    interact with a service; I represent the actions a user may
    perform upon a service, and the state associated with that
    user for that service.
    """

    _service_cached = 0 # Has my service cached me from a loaded store, or do I live in memory usually?

    def __init__(self, perspectiveName, identityName="Nobody"):
        """Create me.

        I require a name for myself and a reference to the service
        I participate in.  (My identity name will be 'Nobody' by
        default, which will normally not resolve.)
        """
        if not isinstance(perspectiveName, types.StringTypes):
            raise TypeError("Expected string, got '%s' (%s)."% (perspectiveName, type(perspectiveName)))
        if not isinstance(identityName, types.StringTypes):
            raise TypeError("Expected string, got '%s' (%s)."% (identityName, type(identityName)))
        self.perspectiveName = perspectiveName
        self.identityName = identityName


The diff
---------

$ diff perspective.py /usr/local/lib/python2.2/site-packages/twisted/cred/perspective.py 
49,52c49,52
&lt;         if not isinstance(perspectiveName, types.StringType):
&lt;             raise TypeError("Expected string, got %s."% perspectiveName)
&lt;         if not isinstance(identityName, types.StringType):
&lt;             raise TypeError("Expected string, got %s."% identityName)
---
&gt;         if not isinstance(perspectiveName, types.StringTypes):
&gt;             raise TypeError("Expected string, got '%s' (%s)."% (perspectiveName, type(perspectiveName)))
&gt;         if not isinstance(identityName, types.StringTypes):
&gt;             raise TypeError("Expected string, got '%s' (%s)."% (identityName, type(identityName)))
</t>
<t tx="rodrigob.121403173614.49">16/06/2003
LeoN Hooks eureka

Leo Provide a lot of different ways to edit the text and the outline. LeoN have to intercept and translate everyone.
Searching arround in the code for every event is far too hard. After some research I have found the neural point where every relevant command arrives:

the Undoer.

The Undoer receive the command type and the command params. That is exactly the information we need.

So the LeoN plugin  will install a Hook to receive the UndoParams and translate them into the action to send it over the wires.

This clearly simplify enormously the job, because there is only one central function to intercept.


This is an example of the information aviable:

setUndoParams: 25:26:{'oldBack': &lt;v 142746852:u'another node'&gt;, 'undoType': 'Move Right', 'parent': &lt;v 142746852:u'another node'&gt;, 'oldParent': &lt;v 142634324:u'Test for LeoN'&gt;, 'v': &lt;v 142086148:u'another node 2'&gt;, 'oldN': 2, 'n': 0}

So this will be my front of attack. I have the hook already coded (at start2 replace setUndoParams by a custom function, jeje), of course there are some issues ('undo' does not call setUndoParams) but I think I have found what I needed. Now I can center the job on the LeoN interface and core logic.

Probably this idea will be usefull for any plugin that have to survey *all* the outline related actions.

Rodrigob.</t>
<t tx="rodrigob.121403173614.50">
We will try to keep the bandwith usage minimal to obtain better responsiveness, at expenses of the server cpu usage.

# explain here how and where the plugin logic is distributed</t>
<t tx="rodrigob.121403173614.51">29/06/03

Hi!

Shortly, I had briefly mentioned it, but I did not see it in Leo 3.12 beta 1.
It is a requirement related to the ability of the plugins to extend the Popup menu (secondary click over a node).


Should separate leoTree.tree.OnPopup on :
    
    tree.createPopupMenu
and 
    tree.showPopupMenu
    
and we edit the function to behave as (OnHeadlineClick &amp; OnHeadlineRightClick (leoNodes, vnode, callbacks) )

def OnHeadlineRightClick(self,event=None):
    try:
        v = self ; c = v.commands
        if not doHook("headrclick1",c=c,v=v,event=event):
            self.commands.tree.OnActivate(self)
            self.commands.tree.createPopupMenu(self,event)
        
        doHook("headrclick2",c=c,v=v,event=event)
                
        self.commands.tree.showPopupMenu(self,event)
                        
    except:
        es_event_exception("headrclick")
        

By this edit, the headrclick2 hook will be able to add elements to the recently Popup menu created.

Thanks,
RodrigoB.
</t>
<t tx="rodrigob.121403173614.52">29/06/03

endheadedit hook
----------------

Hi,
I need some help,

one of the LeoN requirements is to minimize the bandwith usage. To do so it try to pack as much as possible the user events.
If the user press 5 times the key "delete", LeoN will send only one "delete" command.
The same is applyable to the Nodes renaming. LeoN will send a node renaming at the end of editing only if the node name has changed.

The headkey* hook is not very usefull because it not allow the plugin to know when the user has finished the edition of a node.
Using the python flexiblity LeoN actually intercept some methods in order to make a callback each time an user finish to edit a node HeadString.

The way I have found is to overload the leotree.tree.DrawText command:

#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
def drawText(self_object,v,x,y):
    """
    This function create the text widget were the headstring of a vnode is edited.
    This hook add a convenient binding to this object.
    """
    
    old_name = v.headString()
    
    ret_val = self_object.original_drawText(v,x,y)	
    
    text_widget = v.edit_text
    #text_widget = v.edit_text() # on Leo 3.12
    
    text_widget.bind("&lt;FocusOut&gt;", lambda event: es(" %s renamed as  %s"%(old_name, v.headString()), color="yellow")) # for debuging
        
    #text_widget.bind("&lt;FocusOut&gt;", lambda event: rename_callback(v, old_name, v.headString()) )
        
    return ret_val
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

This hook work fine. BUT it have a problem (that I detected today). It do not work the first time (when Leo just start running). Indeed I have found that it do not work if I try and retry to edit the same node. I have to edit one node, then edit another node and it works for that and every next edition.
The reasons why this behaviour appear are obscures to me.

So my request is: It seems reasonable that the plugins are often more interested in nodes renaming than in text typing into the node name.
The actual hook seems to do not allow to detect when the edition has finished. There is aproposal of simple way to install the required hook, but it have a problem. Could some one help me to fix it, or to find a way to install a "endheadedit" hook ?

Thanks in advance,

RodrigoB.




</t>
<t tx="rodrigob.121403173614.53">The realtime edition  could be implemented initially on a lock/unlock fashion automatized on a per line basis, very much like an online CVS editor...

The complications should be left to a parallel project, or maybe to another community (search, propose and merge/translate)
</t>
<t tx="rodrigob.121403173614.54">
future features
---------------

After the Jasonic comment and some thought I'm tempted to call for a LeoN features brainstorm. The idea is that I will work on the next week on the code merging. This mean that I will check again the global design. It is clear that the LeoN requeriments résumé is the minimun common denominator and that there are plenty of fantasies about what a software like LeoN could be. I care that most of them are able to be real without a full code rewrite. So I'm tempted to check if my thinking are fine and LeoN will be able to give what people most want.
It is clear to me that this is a symptom of insecurity about what I'm doing.


13/07/2003
</t>
<t tx="rodrigob.121403173614.55">Today I was thinking about how to make Leo development more easy, flexible and parallel as possible.
I was thinking that there are some pressure to get the editor a little better, but Edward prefer notably to work on the innovative features; this is good but stop some obvious developments.

So I want to suggest the alternative of decoupling as much as possible the editor component(s) of Leo from the rest of the code. That is to define a clear and reduced interface. By doing this the Leo design and development is decoupled on "How to create a great Outliner" and "How to create a great text editor". 

It's just an idea, with some direct consecuences that I will leave to the reader imagination.

rodrigob.</t>
<t tx="rodrigob.121403173614.56">The most near to LeoN project that I have found: cocodoc. Very similar to Radio Outliner but it is 1997 software, what a vision !

www.trc.nl/publicaties/1997/cocodoc.pdf</t>
<t tx="rodrigob.121403173614.57">Components of LeoN are Python, Leo, Twisted, LeoClient, LeoServer and ConcurrentEditable. Here we try to explain what there are and how they interact.

Python is general use interpreted very high level programming language. Leo, Twisted and LeoN are programmed in Python. Python is programmed in C. 

LeoN is Leo over Network. 
That mean that LeoN try to provide to Leo network capabilities.

To do so we developed two elements: LeoClient and LeoServer

LeoClient is a bunch of code that is used to create a plugin to Leo. That plugin extend the capabilities of Leo in order to be able to communicate and interact with a LeoServer.

LeoServer is a bunch of code that is used to provide services related to Leo and LeoN. The LeoServer code is used to construct an application that act as a server for Leo clients (with LeoN installed) and web navigators.

Many clients connect to a server and interact between them via the server.

Remember, LeoClient and LeoServer are not applications, there are code to extend (Leo via client) or construct applications (a server via the Twisted applications system).

To develop the network code we use Twisted. Twisted is a module (a library of functions and classes) for Python. Twisted is very important because it provide many, many functionalities. It allow very easily to construct server apps ('.tap' files), create networked client applications (reactors, general class design), to communicate two piece of software (perspective broker), to provide web services (woven), and much more. Twisted is very well documented, so the low level of LeoN is already standard and documented.


One of the interesant features that LeoN provide is ability to manage various clients writing into the same node body text in the same time. To do so it have to manage the concurrent edition of such document. The concurrent edition of a document in a distributed way, over a network is not an easy task. It took almost 15 years of research to obtain a theorical answer for such a 'simple idea' (easy to say, hard to do).

ConcurrentEditable provide a pure python implementation of the concurrent edition algorithm developed by the Chengzheng Sun team. I extended a little the idea (on the technical aspect) to provide a client/server implementation (subclassing the base system). LeoClient and LeoServer use ConcurrentEditable to provide the concurrent edition feature to the users.</t>
<t tx="rodrigob.121403173614.58">The "General view of the system" provide a good insight to the different elements of the software (read first).

The main rule here is "Keep It Simple". The second rule is "Comment everything".

Tracing the code can be somewhat complex because everything is dynamic, distributed and it integrate itself with other components.

To understand the code you need to understand the Leo plugin system. Look at the Leo documentation for this topic (at LeoDocs.leo, leoPlugins.leo and LeoPy.leo).

All the unions between Leo and LeoClient can be found in two places, "mod_LeoN.py" and "LeoClient.py/Plugin". There you will find a lot of call to LeoClients objects.

The second thing that you will need to study is Twisted. Twisted has an excelent documentation so please use it http://www.twistedmatrix.com. There are many Twisted concept that you will need to learn, they are simple but profound.
You need to understand "reactor" and "deferred" to read the code (both client and server). 
The client server intercomunication is made using the "Perspective Broker".
On the server side we use also "Cred" for authentification, "Woven" to provide the web publishing, and the "Application" object to construct the server application.

Reactor, deferred and PB are a must to understand the code, take a look to them. The rest is only interesant if you are going to inspect that sections of the code (or if you start considering Twisted for your next internet enabled application ;P).

Essentially we have the two sides client and server.

The clients are constructed as a bunch of hooks to Leo, including the installation of a reactor under the hood of the gui. Then after connection we receive a Perspective from the server, that allows us to translate events in server events, and receive the answer. The server side will receive the event, process it and propagate it to all the interested clients (including if necessary the generator).
The outline actions are undoed, send to the server, and the propagation will generate the local event. The body actions are managed by the concurrent edition system, that take care of the body editions and the operations emisions.

Look at the specific code perspectives for the hooks, the outline events management and the client side concurrent edition.


The server side is a little more complex.

First we do not use the Leo outlines representation, we use our own, that is simpler and fits much better our purpose (Leo take to much care of visualization, LeoServer use the simplest "good enough" approach). As a rough picture the server maintain his own outline representation. That representation is stored in the disk (stored) at the end of the server execution (and restored at restart).
In that representation each node maintain his content, his permissions and manage concurrent edition sessions (see CollaborativeOutline and CollaborativeNode classes). 

In LeoN each node is identified via an url. At each request the web publisher retrieve the indicated node and transform it in a html page (see the "Web" code perspective).

In LeoN each node is identified via an url. This idea is important and is used by both client and server side to refer to the nodes.

At the connection of a client the server check the authentification (using the Checker and the outline permissions) and return to the client the requested perspective. 
LeoServer define two different perspectives OutlinePerspective and AdminOutlinePerspective. The first provide access to data and modification methods over the server outline, the second allow to edit the permissions of the server (and thus is the server side representation of the AdminGui).
When the clients connect them to the server they provide to him a client perspective. This perspective allow the server to modify the local outline, and thus is the way that the events are propagated to the clients.

So at each Leo client event, the event is intercepted, transformed in a action in the OutlinePerspective of the server. At the server the permissions to do the action are checked, the event is efectued and his consecuences are propageted (the event propagation is not trivial because one event do not look the same in every client).

The collaborative edition of the body text is made at another level, that use the same comunication channel but interact with different objects. Each server node is a concurrent editable server, when a client want to collaborate and ClientNode instance is created. This is instance is a ConcurrentEditableClient that connect it self to a concurrent editable server (a server node), and become of the collaborative edition start like network.

To construct the server application we integrate the differents objects (outline, perspective broker, web publisher) into an service.Application object (see twisted documentation).

For more information about the LeoClient and LeoServer objects, look at "About client and server objects".

&lt;&lt; notation &gt;&gt;
</t>
<t tx="rodrigob.121403173614.60">@
(A little explication about centralized network, ConcurrentEditableServer and ConcurrentEditableClient)

The topology suposed in the Chengzheng Sun works is an all-to-all clients connection. This assumption is theoritically correct, in internet (for example) it is supposed that every computer is able to send messages to any other one (under the restriction of the network security configurations).

Otherwise this figure is not appropiate for a real implementation because it require that every client use his bandwith to talk with every other ones and, more important, it require a distributed logic for login and logout to and ongoing session.
A distributed logic is complex and will tend to make the implementation error prone and not very responsive when login/logout. So a smart decision between the tradeoffs is required.

Tradeoffs:
    - logic complexity
    - speed of connection and disconnection
    - memory usage
    - cpu usage
    - bandwidth usage
    - implementation complexity
    - similarity to original paper

My original idea was to create an abstraction layer that will hide the existence of the other clients. Each site should be only aware of it own and the server. This was an ideal solution: all the logic complexity is situated on the server, the connection/disconnection is managed by exclusively by the server, the bandwith usage to not grow as more clients connect, the memory usage and cpu on the clients is minimized. The only problem: it cannot be done. It tooks be 2 week of work and fight with the implementation to obtain the necessary indepth to understand that such abstraction could not be done without modifying the algorithm, and this is a too dangerous attempt.

So another tradeoff equilibrium has to be found.
Without an abstraction layer every client has to be aware of each others. This make necessary an acknoledgement of every client when a connection or disconnection occurs. Doing this in a distributed scenario where already marked packets are travelling in an unknown order is complex and will tend to provide solutions that blocks the comunication before completion the connection process. Also the logic involved in client references addition and deletion is not minor and would attack the responsiveness of the clients during that process. So after various days of medition I think that I have found a good tradeoff.

To manage in a better way the bandwith we keep a Client-Server topology, where the Server acts as a mere repeater to send the received operation to every connected client.
Then the key idea is "to do not decrease the state_vectors". Doing this could be look stupid in a first perspective. But after thinking it a while you maybe will be able to understand how such a barbarity can become a good idea.
As the state_vectors do not decreases then there are only two cases: the state_vector is increased, a client replace an already disconnected one.
Both case as extremelly simples in logic cost and are robust to distributed awardness. Using the key idea the conection/disconection logic is centralized in the server and is very fast because it do not require an acknoledge signal from the rest of the clients.


If client receive an operation with a timestamp (reference state_vector) bigger than it own it will make grow all his references.
If the server recieve a new client it check for previously liberated client indexes and assign it, else it make grow all his timestamps. If a client disconnect it simply erase his reference in repeatear function.
If a client emit an operation with a shorter state vector it is because it has received no operations from the new client so it is secure to extend it with zeros.
Obviously when the last client disconnect from the server, it have the opportunity to clean shi memory and refresh back into it default state vector length.

As you can see everything become simple and robust. Maybe the bandwith usage is suboptimal, but in most usage cases the wasting marges should be reasonable.


The schema used for testing the protocol is intensionally similar to the Twisted Spread distributed object system, because I pretend to use it for the first networked subclass. I suppose that any distributed object engine should be able to deal with the required network methods.

@c
</t>
<t tx="rodrigob.121403173614.66"></t>
<t tx="rodrigob.121403173614.67">@color
@language python
# this is the documentation that will see the end user, give a description of the panel and his usage
# this is part of the code, do not delete the "help" definition and the """ elements.
help = \
"""

The administration gui allow you to do two things:
    - Define the permissions of each user at each node
    - Define the accounts of the server, defined by they name and password.

The accounts are defined at the server level. The permissions are defined at a per node level.
    
Thus the interface is separated in two areas, the left pane -the users accounts- and the right pane -the node permissions-.

The left pane present the list of the defined accounts, and interfaces to create new accounts, to change passwords and to delete some accounts. Be carefull, there is no undo! 

Creating an account for an user is not enough to allow it to access the server, you need to define his permissions at the access point.

The right pane allow you to you the edit the per node per user permissions.
The LeoN permissions system is similar to the Zope permissions system.

If a node contain no permissions information about an user, they permissions will be herited from uper nodes. So defining the permissions for the root node will be valid for all the nodes of the system. To change the permissions in a branch, edit the permissions of the root node of the branch.

You have to understand that adding permissions for a user at a node and leaving in blank the options indicate that you are Prohibiting all those permissions for that user, starting from that node and in the suboutline.

The admin gui allow you to edit the permissions of the node where you raised the dialog.
You can add users permissions using the "Add user entry &gt;&gt;&gt;" button, that will add an entry in the node permissions list.

You can edit the different permissions of the node by selecting different users via the  "User:" combobox, click over the user name and a choice list will appear. Remember to press the "Save Changes" button to confirm the modifications.

The button "Delete users permissions" will eliminate the entry at that node, and the permissions for that user at that node will be searched upward in the server outline.

If no permissions entry are found for an user, by default he will have no permissions at (thus it will not be able to connect to the server).

Remember to define the permissions of the users recently created. 
Avoid defining permissions in every node, if would become difficult to maintain. Try to always edit the permissions at the project root nodes.

The users accounts and their permissions are persisted in the server '.tap' file.

Read/Access: allow the users to retreive the node body content and connect at that point.
Node edit:   allow to enter in collaborative mode and edit the node body content.
Tree edit:   allow to insert, move and delete nodes in the outlines. 
Admin node:  allow to edit the permissions of that node, and the accounts of the server (allow access to this dialog).

Note: be aware that in the actual version the server/client connections are not encrypted. Thus all the data, including the passwords are transmited in a easy to deduce binary format. Do not transfer sensible data over insecure network.
"""


@others</t>
<t tx="rodrigob.121403173614.69">We use the following conventions throughout the code:

a: the application object.
c: a commander
ch: a character
d: a dialog or a dict.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
s: a string
t: a tnode or a Tk.Text widget.
u: an undoer
v: a vnode

See the child of this node called "Overview of Code" for more documentation.
</t>
<t tx="rodrigob.121403173614.70">We need to have the "tags_ranges" at the function bodykey2 (or bodykey1).

bodykey{1,2} are called at leoTree.idle_body_key 

idle_body_key (self,v,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):


&gt;&gt;&gt;grep -n "idle_body_key" *.py&lt;&lt;&lt; returns
 
leoTree.py:1130:                self.idle_body_key(v,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
=&gt; onBodyChanged
leoTree.py:1148:                self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)
=&gt; onBodyKey
leoTree.py:1164:                self.commands.body.after_idle(self.idle_body_key,v,oldSel,undoType,oldYview)
=&gt; onBodyWillChange


grep -n "onBody" *.py
leoCommands.py:769:             c.tree.onBodyChanged(v,undoType,oldSel=oldSel,oldYview=oldYview)

leoFileCommands.py:918:         c.tree.onBodyChanged(current,undoType=None)
leoFind.py:600:         c.tree.onBodyChanged(v,"Can't Undo")
leoFind.py:647:                 c.tree.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)

leoFrame.py:2730:               self.commands.tree.onBodyWillChange(v,"Cut")
leoFrame.py:2764:               self.commands.tree.onBodyWillChange(v,"Paste")
leoFrame.py:2791:                       c.tree.onBodyChanged(v,"Delete",oldSel=oldSel)
leoFrame.py:3348:               c.tree.onBodyChanged(v,"Typing",oldSel=oldSel)

leoTree.py:86:# defines the following simplified event handlers: onBodyChanged, 
leoTree.py:87:# onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders 
leoTree.py:882: # that call onBodyChanged, and commands like "Cut" and "Paste" that call 
leoTree.py:883: # onBodyWillChange.  The former commands have already changed the body 
leoTree.py:1115:        #@+node:2::onBodyChanged
leoTree.py:1119:        def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
leoTree.py:1133:        #@-node:2::onBodyChanged
leoTree.py:1151:        #@+node:4::onBodyWillChange
leoTree.py:1155:        def onBodyWillChange (self,v,undoType,oldSel=None,oldYview=None):
leoTree.py:1168:        #@-node:4::onBodyWillChange



--------------------


Searching the body key binding; found
leoFrame.py:161:                self.body.bind("&lt;Key&gt;", self.tree.OnBodyKey)
</t>
<t tx="rodrigob.121403173614.72">the file "leoFileCommands" contain everything.
It has save, saveTo and saveAs commands. They call write_LEO_file.

"save*" calls the hook "save1" and "save2" before and just after saving the file. An idea is to detach the v_nodes online and then attach them back after the save process was completed.</t>
<t tx="rodrigob.121403173614.74">initial keyword drawText
=&gt; leoTree.py:445: def drawText(self,v,x,y)

drawText called by force_draw_node called by drawNode called by drawTree</t>
<t tx="rodrigob.121403173614.220">@nocolor

Code from other sources that I needed to have under my eyes.
Not interesant (mostly used in first development stages, now almost everything is in my mind or in the code  and his comments).

@color
@language python</t>
<t tx="rodrigob.121403173614.221">should clean up this node some times....</t>
<t tx="rodrigob.121403173614.222">@first #! /usr/bin/env python2.2
# Entry point for Leo in Python.
@language python

import os,string,sys,Tkinter

sys.path.append('/usr/local/leo/leo_cvs/leo/')

&lt;&lt; Import pychecker &gt;&gt;
from leoGlobals import *
from leoPlugins import *
import leoApp,leoFrame

@others

if __name__ == "__main__":
    if len(sys.argv) &gt; 1:
        if sys.platform=="win32": # Windows
            fileName = string.join(sys.argv[1:],' ')
        else:
            fileName = sys.argv[1]
        leoOpen(fileName)
    else:
        run()



</t>
<t tx="rodrigob.121403173614.223">@ pychecker is extremely useful, and it sometimes reports problems erroneously.  In particular, the following warnings are invalid:

in leoFrame.py and leoNodes.py: warnings about the event param not being used. pychecker doesn't understand that these routines are Tkinter callbacks.

in leoApp.py and leoGlobals.py: pychecker doesn't seem to handle globals very well.  There are spurious warnings about globals.

several files: pychecker complains about several routines being "too big", i.e., pychecker doesn't understand about literate programming.

@c

if 0: # Set to 1 for lint-like testing.  This can also be done in idle.
    try:
        import pychecker.checker
    except: pass</t>
<t tx="rodrigob.121403173614.224"># This is useful for reloading after a file has been changed.

def go(*args):

    if len(args) &gt; 0 and type(args[0]) == type(("a","b")):
        args = args[0] # Strip the outer tuple.

    run(args)</t>
<t tx="rodrigob.121403173614.225">def leoOpen(fileName=None,*args):
    
    if fileName == None:
        run()
        return

    # Create a hidden main window: this window never becomes visible!
    root = Tkinter.Tk()
    

    # the first thing that we need to do is to install us in the Tkinter loop.
    from twisted.internet import tksupport
    tksupport.install(root)	# Install the Reactor support
    
    
    &lt;&lt; set the icon image &gt;&gt;
    root.title("Leo Main Window")
    root.withdraw()
    # Initialize application globals
    app = leoApp.LeoApp(root)
    setApp(app)
    if not app.finishCreate(): # do this after gApp exists.
        root.destroy()
        return
    handleLeoHook("start1")
    # Create the first Leo window
    frame1 = leoFrame.LeoFrame()
    frame1.top.withdraw()
    frame1.top.update()
    # Now open the second Leo window
    fileName = os.path.join(os.getcwd(), fileName)
    fileName = os.path.normpath(fileName)
    if os.path.exists(fileName):
        ok, frame = frame1.OpenWithFileName(fileName)
    else: ok = 0
    if ok:
        app.windowList.remove(frame1)
        frame1.destroy() # force the window to go away now.
        app.log = frame # Sets the log stream for es()
    else:
        frame1.top.deiconify()
        app.log = frame1
        es("File not found: " + fileName)
        # 10/6/02: Set the file's name if it doesn't exist.
        fileName = ensure_extension(fileName, ".leo")
        frame1.mFileName = fileName
        frame1.title = fileName
        frame1.top.title(fileName)
        frame1.commands.redraw() # Bug fix: 12/12/02
        frame = frame1
    init_sherlock(args)
    clear_stats()
    issueHookWarning()
    # Write any queued output generated before a log existed.
    app.writeWaitingLog() # 2/16/03
    c = frame.commands ; v = c.currentVnode() # 2/8/03
    handleLeoHook("start2",c=c,v=v,fileName=fileName)
    
    from twisted.internet import reactor	
    reactor.run()
    



</t>
<t tx="rodrigob.121403173614.226">if 0: # not yet
    fullname = r"c:\prog\LeoPy\Icons\box05.GIF"
    image = Tkinter.PhotoImage(file=fullname)
    trace(`image`)
    image = Tkinter.BitmapImage(image)
    trace(`image`)
    image = Tkinter.BitmapImage("stop")
    trace(`image`)
    root.iconbitmap(image)</t>
<t tx="rodrigob.121403173614.227">def run(*args):

    # Create a hidden main window: this window never becomes visible!
    root = Tkinter.Tk()
    
    
    # the first thing that we need to do is to install us in the Tkinter loop.
    from twisted.internet import tksupport
    tksupport.install(root)	# Install the Reactor support


    &lt;&lt; set the icon image &gt;&gt;
    root.title("Leo Main Window")
    root.withdraw()
    # Initialize application globals
    app = leoApp.LeoApp(root)
    setApp(app)
    if not app.finishCreate(): # do this after gApp exists.
        root.destroy()
        return
    handleLeoHook("start1")
    # Create the first Leo window
    frame = leoFrame.LeoFrame()
    frame.top.deiconify() # 7/19/02
    frame.commands.redraw() # 9/1/02
    frame.startupWindow = true
    init_sherlock(args)
    issueHookWarning()
    # Write any queued output generated before a log existed.
    app.writeWaitingLog() # 2/16/03
    handleLeoHook("start2")
    

    from twisted.internet import reactor	
    reactor.run()
    
</t>
<t tx="rodrigob.121403173614.228">if 0: # not yet
    fullname = r"c:\prog\LeoPy\Icons\box05.GIF"
    image = Tkinter.PhotoImage(file=fullname)
    trace(`image`)
    image = Tkinter.BitmapImage(image)
    trace(`image`)
    image = Tkinter.BitmapImage("stop")
    trace(`image`)
    root.iconbitmap(image)</t>
<t tx="rodrigob.121403173614.229">def profile ():

    import profile, pstats
    
    name = "c:/prog/test/leoProfile.txt"
    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('cum','file','name')
    p.print_stats()</t>
<t tx="rodrigob.121403173614.230">@first #!/usr/bin/env python2.2

&lt;&lt;docs&gt;&gt;

import types


dbg = 0 # debug level ;p
        
@others


if __name__ == "__main__":

    Tests()
</t>
<t tx="rodrigob.121403173614.231">@others</t>
<t tx="rodrigob.121403173614.232">"""
This code correspond to an implementation of a Concurrent Editable Text buffer.

The code is strictly based on the works of Chengzheng Sun.

Actually all the function were written in order to follow as much as possible the notation introduced in his papers. So most of the code is procedure oriented and not strictly pythonic.

Search at citeseer for the files:

    operational_transformation_issues_algorithms_achievements.djvu
    sun98achieving.pdf (&lt;- the must)
    sun97generic.pdf (citeseer.nec.jp.com/sun97generic.htm)
    sun98operational.pdf
    sun98reversible.pdf

You need this documents to understand the code.

This file provide a unit test that execute an instance of the example proposed in the reference papers.

There is also a class named ConcurrentEditableServer that try to implement a 'star' configuration (one server &lt;-&gt; N clients) for the comunications.

I recomend using Leo to explore the code. http://leo.sf.net

Released under GNU GPL. http://www.gnu.org

Rodrigo Benenson. 2003. LeoN project. 

rodrigob at elo dot utfsm dot cl
"""
</t>
<t tx="rodrigob.121403173614.233">@
release version 0.0.1 (major, minor, release)

this version is not supposed to be error prone, but it is good code base.
-------------------------------------------------------------------------

25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
         Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.

Todo

- Find a good TestConcurrentEditable2 to test LostInformation cases

- LI is absolutelly not verified
- Find the Recover_LI specifications.
- Find a better way to quit the ambiguities on the 'if else {}' operation pertenence. (save_RA, save_LI conditions ?)

- collect garbage do not work anymore exactly like in the example. (is this a problem ?)

- Implement ConcurrentEditableServer
- Implement the  client-server tests

- Debug.
@c
</t>
<t tx="rodrigob.121403173614.234">@
Big picture
-----------

There is a concurrent editable object that receive commands  (operations to realize) associated with the State Vector of the emisor.

The received command are 'received and delayed to preserve causality' or 'executed'.

When executed an undo/transform-do/transform-redo scheme is used.

The transformation of commands (operational transforms) is realized by the GOT algorithm.

The GOT algorithm use two application specific transformation functions IT, ET (inclusion and exclusion transform, respectively).

Tadaaa...
@c
</t>
<t tx="rodrigob.121403173614.235">@
so what? -&gt; Why should you care about this code?

If you want to implement a collaborative text editing software.
You will need to care about three aspects:
    - network layer
    - editor user interface
    - core logic for collaborative editing

The python implementation allow a full cross platform usage and a very rapid deployment; considering that there already exist solutions for the network layer (Twisted) and tools to create easilly user interfaces (Tkinter, wxWindows).

I will enjoy to know about anyone using this code, so please feel free to mail me: &lt;rodrigob at elo dot utfsm dot cl&gt;.

This code is part of the development of LeoN, the Collaborative Leo plugin. http://leo.sf.net
@c
</t>
<t tx="rodrigob.121403173614.236">@
Explain why there are necessary and which are they differences relative to the normal ConcurrentEditable.

- advantages
- generate op
- recieve
- expand / contract timestamp
- distributed garbage collection

@c
</t>
<t tx="rodrigob.121403173614.237"></t>
<t tx="rodrigob.121403173614.238">class ConcurrentEditable:
    """
    This is the core class.
    It instanciate a Site that contain an editable text.
    Will receive and generate operations.
    The implementation is focused on simplicity and paper similarities.
    """
    
    def __init__(self, site_index, num_of_sites):
        """
        if site_index == None then the site is and Observer
        """
                
        self.site_index   = site_index
        self.state_vector = [0] * num_of_sites
                
        self.state_vector_table   = [[0]* num_of_sites]* num_of_sites # required by the garbage collector (SVT)
        self.minimum_state_vector = [0]*num_of_sites # required by the garbage collector (MSV)

        if self.site_index:
            self.state_vector_table [self.site_index] = self.state_vector # link with local state_vector
  
        self.HB = [] # history buffer
        self.delayed_operations = [] 

        self.text_buffer = ""
        
        return
        
    def get_text(self):
        """
        """
        
        return self.text_buffer


    @others
    


</t>
<t tx="rodrigob.121403173614.239">
def receive_operation(self, t_op, *args, **kw):
    """
    can receive operations receiving an Operation object, or being called as : (type, pos, data, {extra args}) 
    receive an operation to execute
    check if it is causally ready
    if not delay it
    else execute it
    if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
    ---
    The workflow is receive-&gt;apply-&gt;execute
    """

    if not isinstance(t_op, Operation):
        try:
            assert len(args) == 2
            t_op = Operation(t_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(t_op, args, kw)
            
    # receive an operation to execute
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; receiving %s"%(self.site_index, self.state_vector, self.get_text(), t_op)

    
    if is_causally_ready(t_op, self): 		# check if it is causally ready
        self.apply(t_op) # execute it (apply to local buffer)
            
        # if executed check the delayed buffer to check for operation that now can be operated
        # (and so on until no operation is executable)			
        
        while 1: # uhhh, dangerous
            for tt_op in self.delayed_operations:
                if is_causally_ready(tt_op, self): 
                    self.apply(tt_op) 
                    self.delayed_operations.remove(tt_op)
                    break # break the 'for'; go back to 'while 1'
            break # end of while 1

    else: # if not delay it
        self.delayed_operations.append(t_op)
    
    if dbg &gt;=1:
        print "Site %s; HB %s"%(self.site_index, self.HB)
        print "Site %s;%s; '%s'; delayed_ops: %s\n"%(self.site_index, self.state_vector, self.get_text(), self.delayed_operations)

            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.240">def apply(self, Onew):
    """
    Algorithm 3: The undo/transform-do/transform-redo scheme (sun98generic)
    
    Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
    
    1. Undo operations in HB from right to left until an operation EOm is found such that EOm =&gt; Onew .
    2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
    3. Transform each operation EOm+i in HB[m+1,n] into the new execution form EO'm+i as follows:
        - EO'm+1 := IT (EOm+1, EOnew ).
        - For 2 &lt;= i &lt;= (n - m),
            (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
            (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
        Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
    
    After the execution of the above steps, the contents of the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    ---
    This function manage the History Buffer and update the State Vector Table.
    """
            
    assert T(Onew) in ["Insert", "Delete"], "Invalid operation request."
    
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; applying %s"%(self.site_index, self.state_vector, self.get_text(), Onew)


    HB = self.HB

    # 1.
    m = 0 # manage the case HB == []
    undoed = []
    for m in range(len(HB) -1, 0 -1, -1):	 # from right to left
        EOm = HB[m]
        #print "check_total_ordering(%s, %s) =&gt; %i"%(EOm, Onew, check_total_ordering(EOm, Onew)) # just for debugging
        if not check_total_ordering(EOm, Onew):
            self.undo(EOm)
            # operations do should not be erased from HB, because they will later be transformed !
            undoed.append(EOm)
        else:
            break
        
    if HB and len(undoed) == len(HB):
        if dbg&gt;=2:
            print "No previous op found !"
        m = -1 # to indicate that no previous op was found

    # 2.
    EOnew = GOT( Onew, HB[:m+1]) # pass Onew and HB = [EO1, EO2, ..., EOm ]
    self.execute(EOnew)
    # EOnew will be inserted after step 3 to follow better the paper notation.
    if dbg&gt;=2:
        print "m %i; [EO1, ..., EOm ] %s; HB[m+1:] %s"%(m,  HB[:m+1],  HB[m+1:])

    
    # 3.
    if undoed: # if there was an undo, then redo
        if dbg&gt;=1:
            print "Site %s; '%s'; undoed %s; executed %s;"%(self.site_index, self.get_text(), undoed, EOnew) # just for debugging
        EOoL = [] # EO'm+1 List

        EOoL.append( IT( HB[m+1], EOnew ) ) 
        for i in range(1, len(undoed)):  # python indexes start from 'zero' (in the paper they start from 'one')
            TO = LET( HB[m+1+i], reverse(HB[m+1: m+i +1])) # paper [m+1,m+i - 1] -&gt; python [m+1:m+i +1]
            EOoL.append( LIT( TO, [EOnew] + EOoL) )

        #print "m: %i; len(EOoL) %i;EOoL %s"%(m, len(EOoL), EOoL) # just for debugging
        for i in range(len(EOoL)):			
            t_op = EOoL[i]
            self.execute(t_op)
            HB[m+1+i] = t_op # python indexes start from 'zero'


    # After the execution of the above steps [...] HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    HB.insert(m + 1, EOnew) # insert into the HB, just after EOm
        
        
    # Update local State vector
    t_index = Onew["source_site"]
    assert t_index &lt; len(self.state_vector), "Received an operation from a source_site outside the state_vector range"
    self.state_vector[t_index] += 1

    if EOnew["source_site"] != self.site_index: # local SVT is linked to the local SV
        self.state_vector_table[EOnew["source_site"]] = list(EOnew["timestamp"]) # update state_vector_table (via a list copy)

    if (len(HB) % 10) == 0: # call the garbage collector (over a dummy periodic condition)
        self.collect_garbage()

    return
</t>
<t tx="rodrigob.121403173614.241">def execute(self, EO, splitted_part=0):
    """
    Modify the text buffer.
    The lost information is stored into the operators for future undos.
    """
    
    if EO.get("is_splitted"):
        self.execute(EO["splitted_head"], splitted_part=1)
        self.execute(EO["splitted_tail"], splitted_part=1)
        return
        
    startpos = P(EO)
    data     = EO["data"]
    
    if T(EO) == "Insert":
        t_list = list(self.text_buffer)
        t_list.insert(startpos, data)	
        self.text_buffer = ''.join(t_list)
        
    elif T(EO) == "Delete":
        length = data
        t_text = self.text_buffer
        EO["deleted_text"] = t_text[startpos:(startpos+length)]
        self.text_buffer = ''.join(t_text[:startpos] + t_text[(startpos+length):])	
        
    else:
        raise " Tried to executed an Unmanaged Operation type"
        
    return
    
redo = execute # alias</t>
<t tx="rodrigob.121403173614.242">def undo(self, EO):
    """
    Undo an operation. Return the text to his previous state.
    The undo operation supose that EO is the last operation executed over the buffer.
    """
    
    if EO.get("is_splitted"):
        self.undo(EO["splitted_head"])
        self.undo(EO["splitted_tail"])
        return

    if T(EO) == "Delete":
        assert EO.has_key("deleted_text"), "Undoable operation (no undo info stored)"
        self.execute( op("Insert", P(EO), EO["deleted_text"]) ) # create the undo operation and execute it
        
    elif T(EO) == "Insert":
        self.execute( op("Delete", P(EO), len(S(EO)) ) ) # create the undo operation and execute it
        
    else:
        raise "Trying to undo an Unmanaged Operation."
    
    
    return

</t>
<t tx="rodrigob.121403173614.243">def collect_garbage(self):
    """
    Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
    Scan HB from left to right. Let EO be the current operation under inspection.
    Suppose that EO was generated at site i and timestamped by SVEO.
        (1) If SVEO [i] &lt;= MSVk[i], then EO is removed from HB and continue scanning.
        (2) Otherwise stop scanning and return.
        
    (The garbage collection procedure can be invoked periodically, or after processing each remote operation/message, or when the number of buffered operations in HB goes beyond a preset threshold value.)
    """
    # reference asignations (local aliases)
    HB  = self.HB 
    SVT = self.state_vector_table
    MSV = self.minimum_state_vector
    
    # compute the MSV
    for i in range(len(MSV)):
        MSV[i] = min( [ sv[i] for sv in SVT ] )
    
    if dbg &gt;=1:
        print "Site %s; MSV %s; SVT %s;"%(self.site_index, MSV, SVT)
        
    # collect the garbage
    for EO in HB:
        i    = EO["source_site"]
        SVEO = EO["timestamp"]
        
        condition = reduce(lambda x,y: x+y, [ SVEO[i] &lt;= MSV[i] for i in range(len(SVEO))]) == len(SVEO) # bizare but it works
        
        if condition:
            HB.remove(EO)
            if dbg&gt;=1:
                print "Site %s; removing %s"%(self.site_index, EO)
        else:
            break
            
            
    return


def update_SVT(self, site_index, state_vector):
    """
    update_StateVectorTable
    
    sun98achievings.pdf, page 19 paragraph 2.
    If one site happens to be silent for an unusually long period of time, other sites will not know what its state is [a 'mostly observer' site]. Therefore, it is required for a site to broadcast a short state message containing its state vector when it has not generated an operation for a certain period of time and/or after executing a certain number of remote operations. Upon receiving a state message from a remote site r, site k simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
    ---
    This function is used as a remote call to broadcast the state message.
    """
    
    self.state_vector_table[site_index] = state_vector
    
    return</t>
<t tx="rodrigob.121403173614.244">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    t_SV = list(self.state_vector) # copy the list
    t_SV[self.site_index] += 1
    
    t_op = Operation(type, pos, data, t_SV, self.site_index)
    
    for k in kws.keys():
        t_op[k] = kws[k]
        
    if dbg&gt;=1:
        print "Site %s; generating %s"%(self.site_index, t_op)
    
    self.receive_op(t_op)
    
    return t_op

def gen_op(self, type, pos, data, **kws):
    """
    Alias of generate_operation.
    """
    return self.generate_operation(type, pos, data, **kws)
    
    
def gen_Op(self, type, data, pos, **kws):
    """
    Alias with another parameters order.
    """
    
    return self.gen_op(type, pos, data, **kws)
</t>
<t tx="rodrigob.121403173614.245">@
Function defined over the operation that return boolean values
@c
</t>
<t tx="rodrigob.121403173614.246">
def is_causally_ready(t_O, t_site):
    """
    Definition 5: Conditions for executing remote operations

    Let O be an operation generated at site s and timestamped by SVo . O is causally-ready for execution at site d (d != s) with a state vector SVd only if the following conditions are satisfied:
        1. SVo [s] = SVd [s] + 1, and
        2. SVo [i] &lt;= SVd [i], for all i in {0,1, ..., N - 1} and i != s.
    """
    
    SVd = t_site.state_vector
    SVo = t_O["timestamp"]
    s   = t_O["source_site"]
    
    assert len(SVd) == len(SVo) 
    assert type(s) == types.IntType, "The operation has no source site (%s)"%(t_O)
    
    # 1.
    condition1 = ( SVo[s] == SVd[s] + 1 )
    
    #2.
    condition2 = 1
    for i in range(len(SVd)):
        if i == s: continue
        condition2 = condition2 and (SVo[i] &lt;= SVd[i])
    
    
    return condition1 and condition2
</t>
<t tx="rodrigob.121403173614.247">
def check_total_ordering(Oa, Ob):
    """
    Check if Oa =&gt; Ob.
    Definition 6: Total ordering relation "=&gt;"
    
    Given two operations Oa and Ob, generated at sites i and j and timestamped by SVOa and SVOb, respectively, then Oa =&gt; O b, iff:
        1. sum(SVOa) &lt; sum(SVOb), or
        2. i &lt; j when sum(SVOa) = sum(SVOb),
    
    where sum(SV) = $\sum_{i=0}^{N-1} SV[i]$.	
    """
    
    sum = lambda t_list: reduce(lambda x,y: x+y, t_list)
    
    SVOa = Oa["timestamp"]
    SVOb = Ob["timestamp"]
    
    assert SVOa and SVOb, "can not check operations without timestamp. (Oa:%s; Ob:%s)"%(Oa, Ob)
    
    # 1.
    condition1 = sum(SVOa) &lt; sum(SVOb)
    
    #2.
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    condition2 = (sum(SVOa) == sum(SVOb)) and (i &lt; j)
        
    return condition1 or condition2
</t>
<t tx="rodrigob.121403173614.248">@
Definition 1: Causal ordering relation "-&gt;"

Given two operations Oa and Ob , generated at sites i and j, then Oa -&gt; Ob , iff:
    1. i = j and the generation of Oa happened before the generation of Ob , or
    2. i != j and the execution of Oa at site j happened before the generation of Ob , or
    3. there exists an operation Ox, such that Oa -&gt; Ox and Ox -&gt; Ob.

Definition 2: Dependent and independent operations

Given any two operations Oa and Ob.
    1. Ob is said to be dependent on Oa iff Oa -&gt; Ob.
    2. Oa and Ob are said to be independent (or concurrent) iff neither Oa -&gt; Ob , nor Ob -&gt; Oa , which is expressed as Oa || Ob.

(nor == not or; 0,0 =&gt; 1 , 0 else)

@c

def are_dependent(Oa,Ob):
    """
    Implement a less than strict check. Will return true if (Oa-&gt;Ob) or if there is a Ox such as (Oa-&gt;Ox and Ox-&gt;Ob)
    
    After reading in detail the papers I propose:
    Oa -&gt; Ob iff :
        if i==j: return SVoa[i] &lt; SVob[i]
        else:    return SVoa[i] &lt;= SVob[i]
    """
    
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    
    if i == j:
        return Oa["timestamp"][i] &lt;  Ob["timestamp"][i]
    else:
        return Oa["timestamp"][i] &lt;= Ob["timestamp"][i]
    
    return
    

def are_concurrent(Oa,Ob):
    """
    Check if both operations are independent (or concurrent)
    
    return Oa-&gt;Ob nor Ob-&gt;Oa
    (nor == not or; 0,0 =&gt; 1 , 0 else)
    """	
    return not (are_dependent(Oa,Ob) or are_dependent(Ob,Oa) )
    
    
are_independent = are_concurrent # just an alias
</t>
<t tx="rodrigob.121403173614.249">
def GOT( Onew, HB):
    """ 
    GOT: Generic Operation Transform
    Algorithm 2: The GOT control scheme (sun98generic)

    Given a new causally-ready operation Onew , and HB = [EO1 , EO2, ..., EOm ]. The following steps are executed to obtain EOnew :
    
    1. Scanning the HB from left to right to find the first operation EOk such that EOk || Onew (EOk and Onew are concurrent (or independent)). If no such an operation EOk is found, then EOnew := Onew.
    
    2. Otherwise, search the range of HB[k+1,m] to find all operations which are causally preceding Onew, and let EOL denote these operations. If EOL = [ ], then EOnew := LIT (Onew , HB[k,m]).
    
    3. Otherwise, suppose EOL = [EOc1, ..., EOcr ], the following steps are executed:
        (a) Get EOL' = [EO'c1, ..., EO'cr ] as follows:
            i. EO'c1 := LET (EOc1, reverse(HB[k, c1 - 1]) ):
            ii. For 2 &lt;= i &lt;= r,
                TO := LET (EOci , reverse(HB[k, ci - 1]) );
                EO'ci := LIT (TO, [EO'c1, ..., EO'ci-1]).
        (b) O'new := LET (Onew, reverse(EOL') ).
        (c) EOnew := LIT (O'new, HB[k,m]).
    """
    
    EOnew = Onew # the default result
    
    for k in range(len(HB)):
        EOk = HB[k]
        if are_concurrent(EOk, Onew): 
            EOL = HB[k+1:]; c1 = k+1 
            if EOL == []:
                EOnew = LIT(Onew, HB[k:])
            else:
                # (a) i.
                r = len(EOL) 
                
                EOLl = range(r) # EOLl &lt;=&gt; EOL'
                #print "GOT (a) i.; r %s; (k,c1 - 1) %s; len(HB) %s"%(r, (k,c1 - 1), len(HB)) # just for debugging
                
                EOLl[0] = LET(EOL[0], reverse(HB[k:c1 - 1 +1])) # +1 because in paper notation ranges are incluse, incluse ('[]'); while python they are incluse, exclusive ('[)')
                
                # (a) ii.
                for i in range(1,r):
                    TO = LET(EOL[i], reverse(HB[k: c1 + i - 1 + 1]))
                    EOLl[i] = LIT(TO, EOLl[1:i-1+1])
                
                # (b)
                Oonew = LET(Onew, reverse(EOLl))
                
                # (c)
                EOnew = LIT(Oonew, HB[k:])
            
    return EOnew</t>
<t tx="rodrigob.121403173614.250">def LIT(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LIT(IT(O, OL[0]), OL[1:])
    
    return Oo
    
def LET(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LET(ET(O, OL[0]), OL[1:])
    
    return Oo
    

def reverse(in_list):
    """
    Helper function used to have a compact notation.
    """
    
    t_list = list(in_list) # create a copy
    t_list.reverse() # in place operator
    
    return t_list</t>
<t tx="rodrigob.121403173614.251">
def IT (Oa, Ob):
    """
    Inclusion Transform.
    Return a transformed Oa, named Ooa, such that the impact of the independent operation Ob (against Oa) is efectively included into Oa.
    Also define the timestamp of the virtual operation.
    """

    if Check_RA(Oa):
        #print "Check_BO(\n\t%s, \n\t%s \n)\t\t=&gt; %s"%(Oa, Ob, Check_BO(Oa, Ob)) # just for debugging
        if Check_BO(Oa, Ob):
             Ooa = Convert_AA(Oa, Ob)
        else:
             Ooa = Oa 
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
         Ooa = IT_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = IT_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = IT_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete"
        Ooa = IT_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:	
        print "IT(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
        
    return Ooa


def IT_II(Oa, Ob):

    if P (Oa) &lt; P (Ob):
        Ooa = Oa
    else:
        Ooa = Op( "Insert", S(Oa), P(Oa) + L(Ob) )
        
    return Ooa


def IT_ID(Oa, Ob):

    if P(Oa) &lt;= P(Ob):
        Ooa = Oa 
    elif P(Oa) &gt; ( P(Ob) + L(Ob) ):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Ob) )
        
        Save_LI(Ooa, Oa, Ob )
        
    return Ooa

def IT_DI(Oa, Ob):

    if P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= P(Ob):
        Ooa = Op( "Delete",  L(Oa), P(Oa) + L(Ob) )
    else: 
        Ooa = Splitted( 
                        Op( "Delete", P(Ob) - P(Oa)          , P(Oa)         ),
                        Op( "Delete", L(Oa) - (P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

def IT_DD(Oa, Ob):

    if P (Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &gt;= P(Oa) and (P(Oa) + L(Oa)) &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", 0, P(Oa) )
        elif P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", P(Oa) + L(Oa) - (P(Ob)+ L(Ob)), P (Ob) )
        elif P(Ob) &gt; P(Oa) and (P(Ob) + L(Ob)) &gt;= (P(Oa) + L(Oa)):
            Ooa = Op( "Delete", P(Ob) - P (Oa), P(Oa) )
        else:
            Ooa = Op( "Delete", L(Oa) - L(Ob), P(Oa) )
            
        Save_LI(Ooa, Oa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



</t>
<t tx="rodrigob.121403173614.252">def ET(Oa, Ob):
    """
    Exclusion Transform.
    Transform Oa against its causally preceding operation Ob to produce Ooa in such a way that Ob's impact on Oa is excluded.
    Also define the timestamp of the virtual operation.
    """
    
    if Check_RA(Oa):
        Ooa = Oa
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
        Ooa = ET_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = ET_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = ET_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete":
        Ooa = ET_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:		
        print "ET(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
    
    return Ooa

def ET_II(Oa, Ob):

    if P(Oa) &lt;= P(Ob) :
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Oa) - P(Ob) )
        Save_RA(Ooa, Ob)
        
    return Ooa

def ET_ID(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Oa) &lt;= P(Ob):
        Ooa= Oa
    else:
        Ooa= Op( "Insert", S(Oa), P(Oa) + L(Ob) )

    return Ooa
    
    
def ET_DI(Oa, Ob):

    if(P(Oa) + L(Oa)) &lt;= P(Ob):
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa))  &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", L(Oa), P(Oa) - P(Ob) )
        elif P(Ob) &lt;= P(Oa) and ((P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob))):
            Ooa = Splitted ( Op( "Delete",  P(Ob) + L(Ob) - P(Oa)         ,(P(Oa) - P(Ob)) ),
                                         Op( "Delete", (P(Oa) + L(Oa))-(P(Ob) + L(Ob)), P(Ob)          ) )
        elif P(Oa) &lt; P(Ob) and ((P(Ob) + L(Ob)) &lt;= (P(Oa) + L(Oa))):
            Ooa = Splitted( Op( "Delete", L(Ob)        , 0     ), 
                            Op( "Delete", L(Oa) - L(Ob), P(Oa) ) )
        else:
            Ooa = Splitted( Op( "Delete", P(Oa) + L(Oa) - P(Ob), 0     ), 
                            Op( "Delete", P(Ob) - P(Oa)        , P(Oa) ) )
        
        Save_RA(Ooa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



def ET_DD(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa
    elif P(Oa) &gt;= P(Ob) :
        Ooa = Op( "Delete", L(Oa), P(Oa) + L(Ob))
    else :
        Ooa = Splitted( Op( "Delete", P(Ob) - P(Oa)         , P(Oa)         ),
                        Op( "Delete", L(Oa) -(P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

</t>
<t tx="rodrigob.121403173614.253">class Operation(dict):
    """
    simple object that encapsulate the information and methods related to the operations.
    it is a dictionary with extra methods.
    """
    
    def __init__(self, type=None, pos=None, data=None, timestamp=None, source_site=None, **kws):
        
        d = self
        
        d["type"] = str(type)
        d["pos"]  = pos
        d["data"] = data # text or len
            
        d["timestamp"]   = timestamp
        d["source_site"] = source_site
        
        for k in kws.keys():
            d[k] = kws[k]
                    
        return

    def __eq__(self, other): 
        """
        The papers do not explain how to manage the TimeStamp of the operations during transforms and do not explain which operations are considered to be equivalents.
        Studying in detail the sequence of transformations that the example generate:
            LIT(ET(O4, ET(EO2, EO1)), [EO1, EO2])
        I deduce that the first approach of using Operations class instances is wrong. Doing that Transformation mutate the operators passed is wrong too.
        If during transform the timestamp are preserved then timestamp and source_site are the unique identifiers of a operation. Then IT(EO, EOx) == ET(EO, EOx) == EO; this is not intuitive but it works.
        ----
        x==y calls x.__eq__(y)
        """
        
        assert isinstance(other, Operation), "Only operations instances can be compared"
        
        return (self["source_site"] == other["source_site"]) and (self["timestamp"] == other["timestamp"])

    def __repr__(self):
        """
        """
        return "%s"%(self)
        
    def __str__(self):
        """
        """
        
        t_keys = filter(lambda x: x not in ["type", "pos", "data", "source_site", "timestamp"], self.keys())
        
        t_string = ""
        
        if self.has_key("source_site") and self.get("timestamp") :
            t_string += "from S%s%s "%(self["source_site"], self["timestamp"])
            
        if type(self["data"]) in types.StringTypes:
            t_data = "'%s'"%(self["data"])
        else:
            t_data = self["data"]
            
        t_string += "%s@%s:%s"%(self["type"], self["pos"], t_data)
         
        for k in t_keys:
                t_string += ", %s:'%s'"%(k, self[k])
            
        return "{%s}"%t_string
        
    def set_timestamp(self, t_SV):
        """
        Save a state vector as the timestamp.
        """
        
        self["timestamp"] = t_SV
        return
        
    def get_timestamp(self):
        """
        return the state vector used as the timestamp.
        """
        return self.get("timestamp")
    
        
# end of class Operation

@
Dummy function to shortcut the code.
@c

def Op(type, data, pos): # this one has a diferent parameters order
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)
    
def op(type, pos, data):
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)


@
Simple function used in the algorithm (enhance readability and paper notation matching)
@c

def T(O):
    """
    Return the type of operation ("Insert" or "Delete")
    """
    return O["type"]
        
    
def P(O):
    """
    Return the position where the operation is executed.
    """
    return O["pos"]


def L(O):
    """
    Return length of the deletion operation.
    For safness if the operation is no a deletion it return the length of the inserted text. (stricly it should raise an error...)
    """
    
    data = O["data"] # speed-up
    assert data != None, "Operation has no data! (%s in %s)"%(data, O)
    
    if type(data) == types.IntType:
        return data
    else:
        return len(data)


def S(O):
    """
    Return the string that the insert operation is trying to insert.
    """
    
    assert type(O["data"]) in types.StringTypes, "S(O) is only valid for Insertion operation."
        
    return O["data"]
    
</t>
<t tx="rodrigob.121403173614.254">
def Splitted(O1, O2):
    """
    Return an operation that is splitted. (this should considered in function 'execute' and 'undo')
    """
    
    assert T(O1) == T(O2), "Splitted operations are of different types, this is not sane."
    assert not (O1.get("is_splitted") or O1.get("is_splitted") ), "Recursive splitted operation not yet supported" 
        
    Oo = Operation(T(O1))
    Oo["is_splitted"] = 1
    Oo["splitted_head"] = O1
    Oo["splitted_tail"] = O2
    
    
    if P(O1) &lt; P(O2):
        Oo["pos"] =  P(O1)
        Oo["data"] =  ( P(O2) + L(O2) ) - P(O1)
    elif P(O1) &gt; P(O2):
        Oo["pos"] = P(O2)
        Oo["data"] = ( P(O1) + L(O1) ) - P(O2)
    else:
        raise "Weird split P(O1) == P(O2) (%s,%s)"%(O1, O2)
        
    return Oo



</t>
<t tx="rodrigob.121403173614.255">@
LI refers to "Lost Information".
@c
        
    
def Check_LI(Oa, Ob):
    """
    Ob was involved in a information lossing operation that afected Oa ?
    """
    
    return 	Oaa.get("LI_reference_op") == Ob
    
    
def Save_LI(Oaa, Oa, Ob):
    """
    Store in Oaa the information related to the paremeters of Oa and the reference to Ob.
    
    One operation can only store one and only one information lose.
    """
    
    copy_Oa = op(Oa["type"], Oa["pos"], Oa["data"] )
    
    Oaa["lost_information"]     = copy_Oa
    Oaa["LI_reference_op"]      = Ob
    
    return


def Recover_LI(Oa):
    """
    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DID NOT FOUND SPECIFICATION (this could cause horrible errors)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    """
    
    return 	Oa["lost_information"]
</t>
<t tx="rodrigob.121403173614.256">    
def Check_RA(Oa):
    """
    Is Oa relatively addressed ?
    """
    
    return Oa.has_key("relatively_addressed") and Oa["relatively_addressed"]
    
    
def Save_RA(Oa, Ob):
    """
    Stores the information to mark Oa as having a relative address to over Ob.
    """
    
    #print "called Save_RA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oa["relatively_addressed"] = 1
    Oa["base_operation"] = Ob
    Oa["delta_pos"] = P(Oa) - P(Ob) # Abis = P(Obbis) + A.delta_pos
    
    return
    
def Check_BO(Oa, Ob):
    """
    Ob is the base operation of Oa ? (in the relative address context)
    """
    
    #Ox = Oa.get("base_operation")
    #return (Ox["source_site"] == Ob["source_site"]) and (Ox["timestamp"] == Ob["timestamp"])
    
    return Ob == Oa.get("base_operation") # look at the definition of __eq__ in the Operation class
    

def Convert_AA(Oa, Ob):
    """
    Obtain Oaa, which is an absolute address operation based on Oa, over the relative position of Ob.
    """
    
    assert Check_BO(Oa,Ob), "Convert_AA: Ob is not the base_operation of Oa"
    
    #print "called Convert_AA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oaa = op( Oa["type"],	Oa["delta_pos"] + Ob["pos"], Oa["data"] )
    
    return Oaa

</t>
<t tx="rodrigob.121403173614.257"></t>
<t tx="rodrigob.121403173614.258">class ConcurrentEditableServer(ConcurrentEditable):
    """
    Manage the request from different client, giving them the ilussion that there are only two sites. Here and There.
    ---
    This is usefull because:
        - it reduce the bandwith usage of the client. 
        - the packet size do not depend of the number of sites. 
        - the logic for client insertion is not distributed
    ---
    The server receive an operation, transform it and apply it. Send it show this new operation executed as if it was a locally executed operation and send it to all the users that are hearing it.	
    The sequence is:
        - recieve an operation from a client
        - transform to extended representation
        - receive the operation internarly
        - send the applied operation to the intersed clients
    ---
    """
    
    def __init__(self,):
        """
        """
        # init the internal ConcurrentEditable
        
        ConcurrentEditable.__init__(self, None, 0) # (self, site_index, num_of_sites)
        
        self.connected_sites = {} # the mapping between the connected sites and they site_index
        self.indexed_sites   = {} # the reverse map of connected_sites
        
        return
        
        
    @others
    
</t>
<t tx="rodrigob.121403173614.259">def add_client(self, client_perspective):
    """
    Register the client to the clients list. 
    Assign a client index. 
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).
    """

    if dbg&gt;=1:
        print "Adding client to server."
        print "Server HB %s"%self.HB

            
    # register the client
    if client_perspective in 	self.connected_sites.keys():
        raise "Client already connected, addition rejected."
        return
    
    # assign a site index
    site_index = len(self.state_vector) # a new entry at the end of the list
    self.connected_sites[client_perspective] = site_index 
    self.indexed_sites[site_index] = client_perspective
    
    # expand the vectors and matrices
    self.state_vector.extend(extra)
    
    for t_vector in self.state_vector_table:
        if t_vector != self.state_vector:
            t_vector.extend(extra)
        
    self.state_vector_table.append([0]*len(self.state_vector))
    self.minimum_state_vector.extend(extra)

    #print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
    #print "Server HB %s" % self.HB # just for debugging
    
    assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)

    # expand the operations timestamp in the HB
    for t_op in self.HB:
        t_op["timestamp"].extend(extra)
        
        if t_op.get("base_operation"): # RA: relative address
            t_op["base_operation"]["timestamp"].extend(extra)
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
            t_op["splitted_head"]["timestamp"].extend(extra)			
            t_op["splitted_tail"]["timestamp"].extend(extra)			
            
        if t_op.get("lost_information"): # LI: lost information
            t_op["lost_information"].get("timestamp", []).extend(extra)
            t_op["LI_reference_op" ].get("timestamp", []).extend(extra)
    

    # obtain the base text of the actual state		
    for t_op in reverse(self.HB):
        self.undo(t_op)
    
    base_text = self.get_text() # base text is the text created by the erased operations
    
    for t_op in self.HB:
        self.redo(t_op)
    
    # put up to date the state of the new client
    self.send_text(site_index, base_text) 
    
    i = 0
    for t_Op in self.HB: # send the operations in the HB
        i+=1
         
        # convert the timestamp to the compact form and send.
        t_op = Operation(**t_Op) # copy
        t_op["source_site"] = 0 	# set the source_site as the Server side (site_index == 0)
    
        t_op["timestamp"] = [i, 0]

        self.send_operation(site_index, t_op) # send it	# compose the history buffer
        
    
    if dbg&gt;=1:
        print "Now we have %s clients connected."%(len(self.connected_sites))
        print "Server HB %s"%self.HB
        print
            
    return
    

        
def del_client(self, client_perspective):
    """
    The inverse of add_client.
    """
    
    # delete the client
    i = self.connected_sites[client_perspective]
    
    del self.indexed_sites[self.connected_sites[client_perspective]]
    del self.connected_sites[client_perspective]
    

    # update the site_index mapping ----
        
    # shrink the vectors and matrices
    shrink = lambda x: hasattr(x, "__delslice__") and x.__delslice__(i, i+1) # delete the 'i'th item
    
    shrink(self.state_vector)
    
    for t_vector in self.state_vector_table:
        shrink(t_vector)
        
    shrink(self.state_vector_table)
    shrink(self.minimum_state_vector)

    # shrink the operations timestamp in the HB
    for t_op in self.HB:
        shrink(t_op["timestamp"])
        
        if t_op.get("base_operation"): # RA: relative address
            shrink(t_op["base_operation"]["timestamp"])
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail"): # Splitted
            shrink(t_op["splitted_head"]["timestamp"])			
            shrink(t_op["splitted_tail"]["timestamp"])			
            
        if t_op.get("lost_information"): # LI: lost information
            try:
                shrink(t_op["lost_information"].get("timestamp"))
            except:
                pass
            try:
                shrink(t_op["LI_reference_op" ].get("timestamp"))
            except:
                pass
                
    
    return
        

</t>
<t tx="rodrigob.121403173614.260">
def receive_operation(self, in_op, *args, **kw):
    """
    this function parse the input state vectors to create the desired ilusition (only two sites interacting)
    """

    # obtain the input operation
    if not isinstance(in_op, Operation):
        try:
            assert len(args) == 2
            t_op = Operation(in_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(in_op, args, kw)
    else:
        t_op =	Operation(**in_op) # copy the operation 
    
    # translate it to the local representation ----
    t_op["source_site"] = self.connected_sites[t_op["source_site"]] # transform a reference to a site_index	
    
    if dbg &gt;=1:
        print "Server receiving op %s"%(t_op)
        
    t_op["timestamp"]   = self.convert_timestamp( t_op["source_site"], t_op["timestamp"] )	# convert timestamp from compact to extended version
    


    if dbg &gt;=1:
        print "Server applying op %s"%(t_op)
    
    # ---
    
    ConcurrentEditable.receive_operation(self, t_op) # apply localy
            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.261">def apply(self, Onew):
    """
    Apply locally and send to all the other users.
    Need to convert an expanded timestamp to his reduced representation (revert back to a reduced state).
    """
    
    ConcurrentEditable.apply(self, Onew) # apply localy
    
    # copy operation
    #t_op = Operation(Onew["type"], Onew["pos"], Onew["data"])
    
    # &gt;&gt;&gt;&gt;&gt; ADD CODE HERE manage the non-trivial cases (RA, LI) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    
    t_op = Operation(**Onew) # copy

    t_op["source_site"] = 0 	# set the source_site as the Server side (site_index == 0)
    
    t_sv  = list(Onew["timestamp"]) # temp state vector
    t_sum = reduce(lambda x,y: x+y, t_sv)
    
    # revert and send
    for t_index in range(len(t_sv)):
        if t_index == Onew["source_site"]: continue # do not send back to the emisor
            
        # set the reduced state vector [Server, Site_x] == [ Sum other sites, Site]
        t_op["timestamp"] = [t_sum - t_sv[t_index], t_sv[t_index] ]
        
        self.send_operation(t_index, t_op) # send it

    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ADD CODE HERE to triger the distributed garbage collector when required &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    
    return 


</t>
<t tx="rodrigob.121403173614.262">def convert_timestamp(self, site_index, timestamp ):
    """
    Convert a reduced time stamp of an operation received from a client to his expanded version.
    

    &gt;&gt;&gt;Explain finak algorithm HERE&lt;&lt;&lt;&lt;
    
    When found it we update the local State Vector Table. (used for garbage collection)
    ---
    the inverse operation, 'revert' is very simple, you can found it inline the 'apply' method.
    """

    if dbg&gt;=1:
        print "Server; %s; HB %s"%(self.state_vector, self.HB)
        
    HB = self.HB
                
    sum = lambda z: reduce(lambda x,y: x + y, z)

    # copy the timestamps	
    t_state_vector = list(self.state_vector) # copy it	
    t_timestamp = list(timestamp) # copy it
    t_timestamp[1] -= 1 # the client has sent a new operation, so his timestamp side is increased.
        
    print "timestamp %s t_timestamp %s t_state_vector %s"%(timestamp, t_timestamp, t_state_vector)

        
    result = None
    for k in range(len(HB) -1, 0 -1, -1): # for all HB from right to left
        
        t_sv = t_state_vector
        t_sv = [sum(t_sv) - t_sv[site_index], t_sv[site_index] ] # this is algorithm used to revert
        
        print "Comparing %s %s"%(t_sv, t_timestamp)
        
        if  t_sv == t_timestamp:
            result = list(t_state_vector) # copy it
            result[site_index] += 1 # the client has sent a new operation, so his timestamp side is increased.
            break
        
        # the local HB use a full length timestamps (len(HB[k]["timestamp"])== num_connected_sites)
        t_state_vector[HB[k]["source_site"]] -=1 # state vector going backward in the time

    
    if dbg&gt;=1 and not result: print "Timestamp  S%i%s looks as first time timestamp"%(site_index, timestamp)
    
    if result == None and sum(timestamp): # this should correspond to a first edit message
        t_sv = [0] * len(self.state_vector)
        t_sv[site_index] = 1
        result = t_sv 
    
    if not result:
        raise "Could not convert the timestamp S%i %s (from compact to expanded version) (HB %s)"%(site_index, timestamp, HB)

    if dbg&gt;=1:
        print "Converting_timestamp S%i%s =&gt; %s; server HB %s"%(site_index, timestamp, result, HB)
    
    return result
    
    
</t>
<t tx="rodrigob.121403173614.263">
def send_operation(self, site_index, t_op):
    """
    This function is called by apply.
    This method should be overwritten for real network transmision. 
    Test implementation is presented here.
    """
    
    if dbg &gt;= 1:
        print "send_op; connected_sites %s to send to %s %s"%(self.connected_sites, site_index, t_op)
        global sent_test_operations
        sent_test_operations.append(t_op)
            
    else:
        raise "This method should be overwritten to send the object over the network"
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].receive_op(t_op) 
        
    return</t>
<t tx="rodrigob.121403173614.264">def send_text(self, site_index, new_text):
    """
    This method should be overwritten for a networked implementation.
    Here only code for testing.
    """
    
    if dbg &gt;= 1:
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].set_text(new_text) 
    else:
        raise "This method should be overwritten to send the object over the network"
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].set_text(new_text) 		
    
    return</t>
<t tx="rodrigob.121403173614.265">class ConcurrentEditableClient(ConcurrentEditable):
    """
    Just a normal ConcurrentEditable but with a special garbage collector, because the Server can send operations from the past (normal client are suposed to do not do that). So the Client garbage collector is triggered by the Server.
    """
    
    def __init__(self,):
        """
        """
        # init the internal ConcurrentEditable
        
        ConcurrentEditable.__init__(self, 1, 2) # the clients has site_index 1, thus state_vector == [server, client]
        
        return
        
    @others</t>
<t tx="rodrigob.121403173614.266">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    # create and apply
    t_op = ConcurrentEditable.generate_operation(self, type, pos, data, **kws)

    # overwrite source_site to give a reference (instead of a dummy number)
    ret_op = Operation(**t_op) # copy the operation
    ret_op["source_site"] = self
    
    return ret_op
</t>
<t tx="rodrigob.121403173614.267">def set_text(self, new_text):
    """
    Blindly overwrite the text of this site.
    """
    
    self.text_buffer = new_text
    
    return</t>
<t tx="rodrigob.121403173614.268">def collect_garbage(self):
    """
    Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
    Scan HB from left to right. Let EO be the current operation under inspection.
    Suppose that EO was generated at site i and timestamped by SVEO.
        (1) If SVEO [i] &lt;= MSVk[i], then EO is removed from HB and continue scanning.
        (2) Otherwise stop scanning and return.
        
    (The garbage collection procedure can be invoked periodically, or after processing each remote operation/message, or when the number of buffered operations in HB goes beyond a preset threshold value.)
    """
    # reference asignations (local aliases)
    HB  = self.HB 
    SVT = self.state_vector_table
    MSV = self.minimum_state_vector
    
    # compute the MSV
    for i in range(len(MSV)):
        MSV[i] = min( [ sv[i] for sv in SVT ] )
    
    if dbg &gt;=1:
        print "Site %s; MSV %s; SVT %s;"%(self.site_index, MSV, SVT)
        
    # collect the garbage
    for EO in HB:
        i    = EO["source_site"]
        SVEO = EO["timestamp"]
        
        condition = reduce(lambda x,y: x+y, [ SVEO[i] &lt;= MSV[i] for i in range(len(SVEO))]) == len(SVEO) # bizare but it works
        
        if condition:
            HB.remove(EO)
            if dbg&gt;=1:
                print "Site %s; removing %s"%(self.site_index, EO)
        else:
            break
            
            
    return


def update_SVT(self, site_index, state_vector):
    """
    update_StateVectorTable
    
    sun98achievings.pdf, page 19 paragraph 2.
    If one site happens to be silent for an unusually long period of time, other sites will not know what its state is [a 'mostly observer' site]. Therefore, it is required for a site to broadcast a short state message containing its state vector when it has not generated an operation for a certain period of time and/or after executing a certain number of remote operations. Upon receiving a state message from a remote site r, site k simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
    ---
    This function is used as a remote call to broadcast the state message.
    """
    
    self.state_vector_table[site_index] = state_vector
    
    return</t>
<t tx="rodrigob.121403173614.269">@
The unit tests for concurrent editions.
@c


def Tests():
    """
    run the tests
    """
    
    global dbg
    dbg = 0
    
    if 0: # hand made unittest 
        print "Starting tests"
        TestConcurrentEditable1()
        print "-"	* 30
        TestConcurrentEditable2()
        print "-"	* 30	
        TestConcurrentEditableServer()
        print "end of tests"
        return



    import unittest
    

    TestSuite = unittest.TestSuite()
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable1))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable2))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditableServer))
    
    unittest.TextTestRunner().run(TestSuite)
    
    return</t>
<t tx="rodrigob.121403173614.270">
def TestConcurrentEditable1():
    """
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Delete 1 2
        - O4 Insert 2 "c"
    So the final result should be "ABCcD" in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable1 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test the alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4") 
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    

    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.271">
def TestConcurrentEditable2():
    """
    Second test is similar to Test1 but with other operations. Try to test other code areas (i.e. Lost Information cases)
    
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Insert 5 "c"
        - O4 Delete 0 3
    So the final result should be ABCc in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable2 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCc" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCc', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.272">
def TestConcurrentEditableServer():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a Star network; with one central server and three clients connecting to it.
    """

    global dbg
    dbg = 1 # ;P
    
    print "-"*15
    print "Read docstring of TestConcurrentEditableServer for more info about this test.\n"
    
    # creates server
    server = ConcurrentEditableServer()
    
    # connect site 0 and 1
    site0 = ConcurrentEditableClient()
    site1 = ConcurrentEditableClient()
    
    server.add_client(site0)
    server.add_client(site1)
    
    global sent_test_operations; 	sent_test_operations = [] # used for delaying the transmissions in the test
    
    # start editions
    # Apply the operations in each site (following the order of the picture)
    print "Site0"; O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1", gen_site="0") # generate and apply locally the operation
    print "Site1"; O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2", gen_site="1") # test the alias

    # O*_toS* is an operation that was sent by the server to the client. This object is delayed to simulate delays in the transmissions lines.
    # the order of reception of commands is similar of the TestConcurrentEditable1
    server.receive_op(O2); [O2_toS0] = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    server.receive_op(O1);	[O1_toS1] = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    
    # connect site 2 (to test connection during sessions)
    site2 = ConcurrentEditableClient()	
        
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
    
    server.add_client(site2)
    for t_op in sent_test_operations:
        site2.receive_op(t_op)

    sent_test_operations = []
    
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
        
    # continue editions
    print "Site1"; site1.receive_op(O1_toS1) # receive delayed operations sent by the server
    print "Site0"; site0.receive_op(O2_toS0)
    print "Site2"; O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4", gen_site="2") 
    server.receive_op(O4); O4_toS0, O4_toS1 = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    print "Site0"; site0.receive_op(O4_toS0)
    print "Site1"; O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3", gen_site="1")
    server.receive_op(O3);	print "sent_test_operations %s\n"%sent_test_operations; O3_toS0, O3_toS2 = sent_test_operations; sent_test_operations = []	
    print "Site2"; site2.receive_op(O3_toS2)
    print "Site1"; site1.receive_op(O4_toS1)
    #print "Site2"; site2.receive_op(O1_toS2) # this op should be sent when site2 connect itself to the server.
    
    # Original sequence------------------
    #O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    #O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    #site2.receive_op(O2)
    #site1.receive_op(O1)
    #site0.receive_op(O2)
    #O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    #site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    #O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    #site2.receive_op(O3)
    #site0.receive_op(O3)
    #site1.receive_op(O4)			
    #site2.receive_op(O1)
    # ------------------
    
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
        
    # --------
    
    # disconnect
    if dbg&gt;=1: print "Disconnecting the three sites."
    server.del_client(site0)	
    server.del_client(site1)	
    server.del_client(site2)	
    # --------------
        
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [server, site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success

    return 1



</t>
<t tx="rodrigob.121403173614.273">@first #!/usr/bin/env python2.2

&lt;&lt;docs&gt;&gt;

import types


dbg = 0 # debug level ;p
        
@others


if __name__ == "__main__":

    Tests()
</t>
<t tx="rodrigob.121403173614.274">@others</t>
<t tx="rodrigob.121403173614.275">"""
This code correspond to an implementation of a Concurrent Editable Text buffer.

The code is strictly based on the works of Chengzheng Sun.

Actually all the function were written in order to follow as much as possible the notation introduced in his papers. So most of the code is procedure oriented and not strictly pythonic.

Search at citeseer for the files:

    operational_transformation_issues_algorithms_achievements.djvu
    sun98achieving.pdf (&lt;- the must)
    sun97generic.pdf (citeseer.nec.jp.com/sun97generic.htm)
    sun98operational.pdf
    sun98reversible.pdf

You need this documents to understand the code.

This file provide a unit test that execute an instance of the example proposed in the reference papers.

There is also a class named ConcurrentEditableServer that try to implement a 'star' configuration (one server &lt;-&gt; N clients) for the comunications.

I recomend using Leo to explore the code. http://leo.sf.net

Released under GNU GPL. http://www.gnu.org

Rodrigo Benenson. 2003. LeoN project. 

rodrigob at elo dot utfsm dot cl
"""
</t>
<t tx="rodrigob.121403173614.276">@
release version 0.0.1 (major, minor, release)

this version is not supposed to be error prone, but it is good code base.
-------------------------------------------------------------------------

25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
         Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.

Todo

- Find a good TestConcurrentEditable2 to test LostInformation cases

- LI is absolutelly not verified
- Find the Recover_LI specifications.
- Find a better way to quit the ambiguities on the 'if else {}' operation pertenence. (save_RA, save_LI conditions ?)

- collect garbage do not work anymore exactly like in the example. (is this a problem ?)

- Implement ConcurrentEditableServer
- Implement the  client-server tests

- Debug.
@c
</t>
<t tx="rodrigob.121403173614.277">@
Big picture
-----------

There is a concurrent editable object that receive commands  (operations to realize) associated with the State Vector of the emisor.

The received command are 'received and delayed to preserve causality' or 'executed'.

When executed an undo/transform-do/transform-redo scheme is used.

The transformation of commands (operational transforms) is realized by the GOT algorithm.

The GOT algorithm use two application specific transformation functions IT, ET (inclusion and exclusion transform, respectively).

Tadaaa...
@c
</t>
<t tx="rodrigob.121403173614.278">@
so what? -&gt; Why should you care about this code?

If you want to implement a collaborative text editing software.
You will need to care about three aspects:
    - network layer
    - editor user interface
    - core logic for collaborative editing

The python implementation allow a full cross platform usage and a very rapid deployment; considering that there already exist solutions for the network layer (Twisted) and tools to create easilly user interfaces (Tkinter, wxWindows).

I will enjoy to know about anyone using this code, so please feel free to mail me: &lt;rodrigob at elo dot utfsm dot cl&gt;.

This code is part of the development of LeoN, the Collaborative Leo plugin. http://leo.sf.net
@c
</t>
<t tx="rodrigob.121403173614.279">@

The topology suposed in the Chengzheng Sun works is an all-to-all clients connection. This assumption is theoritically correct, in internet (for example) it is supposed that every computer is able to send messages to any other one (under the restriction of the network security configurations).

Otherwise this figure is not appropiate for a real implementation because it require that every client use his bandwith to talk with every other ones and, more important, it require a distributed logic for login and logout to and ongoing session.
A distributed logic is complex and will tend to make the implementation error prone and not very responsive when login/logout. So a smart decision between the tradeoffs is required.

Tradeoffs:
    - logic complexity
    - speed of connection and disconnection
    - memory usage
    - cpu usage
    - bandwidth usage
    - implementation complexity
    - similarity to original paper

My original idea was to create an abstraction layer that will hide the existence of the other clients. Each site should be only aware of it own and the server. This was an ideal solution: all the logic complexity is situated on the server, the connection/disconnection is managed by exclusively by the server, the bandwith usage to not grow as more clients connect, the memory usage and cpu on the clients is minimized. The only problem: it cannot be done. It tooks be 2 week of work and fight with the implementation to obtain the necessary indepth to understand that such abstraction could not be done without modifying the algorithm, and this is a too dangerous attempt.

So another tradeoff equilibrium has to be found.
Without an abstraction layer every client has to be aware of each others. This make necessary an acknoledgement of every client when a connection or disconnection occurs. Doing this in a distributed scenario where already marked packets are travelling in an unknown order is complex and will tend to provide solutions that blocks the comunication before completion the connection process. Also the logic involved in client references addition and deletion is not minor and would attack the responsiveness of the clients during that process. So after various days of medition I think that I have found a good tradeoff.

To manage in a better way the bandwith we keep a Client-Server topology, where the Server acts as a mere repeater to send the received operation to every connected client.
Then the key idea is "to do not decrease the state_vectors". Doing this could be look stupid in a first perspective. But after thinking it a while you maybe will be able to understand how such a barbarity can become a good idea. 
As the state_vectors do not decreases then there are only two cases: the state_vector is increased, a client replace an already disconnected one.
Both case as extremelly simples in logic cost and are robust to distributed awardness. Using the key idea the conection/disconection logic is centralized in the server and is very fast because it do not require an acknoledge signal from the rest of the clients.


If client receive an operation with a timestamp (reference state_vector) bigger than it own it will make grow all his references. 
If the server recieve a new client it check for previously liberated client indexes and assign it, else it make grow all his timestamps. If a client disconnect it simply erase his reference in repeatear function.

As you can see every thing become simple and robust. Maybe the bandwith usage is suboptimal, but in most usage cases the wasting marges should be reasonable.


@c
</t>
<t tx="rodrigob.121403173614.280">@
Base implementation of the paper concepts. This code do not worry about comunication methods.
@c
</t>
<t tx="rodrigob.121403173614.281">class ConcurrentEditable:
    """
    This is the core class.
    It instanciate a Site that contain an editable text.
    Will receive and generate operations.
    The implementation is focused on simplicity and paper similarities.
    """
    
    def __init__(self, site_index, num_of_sites):
        """
        if site_index == None then the site is and Observer
        """
                
        self.site_index   = site_index
        self.state_vector = [0] * num_of_sites
                
        self.state_vector_table   = [[0]* num_of_sites]* num_of_sites # required by the garbage collector (SVT)
        self.minimum_state_vector = [0]*num_of_sites # required by the garbage collector (MSV)

        if self.site_index:
            self.state_vector_table [self.site_index] = self.state_vector # link with local state_vector
  
        self.HB = [] # history buffer
        self.delayed_operations = [] 

        self.text_buffer = ""
        
        return
        
    def get_text(self):
        """
        """
        
        return self.text_buffer


    @others
    


</t>
<t tx="rodrigob.121403173614.282">
def receive_operation(self, t_op, *args, **kw):
    """
    can receive operations receiving an Operation object, or being called as : (type, pos, data, {extra args}) 
    receive an operation to execute
    check if it is causally ready
    if not delay it
    else execute it
    if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
    ---
    The workflow is receive-&gt;apply-&gt;execute
    """

    if not isinstance(t_op, Operation):
        try:
            assert len(args) == 2
            t_op = Operation(t_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(t_op, args, kw)
            
    # receive an operation to execute
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; receiving %s"%(self.site_index, self.state_vector, self.get_text(), t_op)

    
    if is_causally_ready(t_op, self): 		# check if it is causally ready
        self.apply(t_op) # execute it (apply to local buffer)
            
        # if executed check the delayed buffer to check for operation that now can be operated
        # (and so on until no operation is executable)			
        
        while 1: # uhhh, dangerous
            for tt_op in self.delayed_operations:
                if is_causally_ready(tt_op, self): 
                    self.apply(tt_op) 
                    self.delayed_operations.remove(tt_op)
                    break # break the 'for'; go back to 'while 1'
            break # end of while 1

    else: # if not delay it
        self.delayed_operations.append(t_op)
    
    if dbg &gt;=1:
        print "Site %s; HB %s"%(self.site_index, self.HB)
        print "Site %s;%s; '%s'; delayed_ops: %s\n"%(self.site_index, self.state_vector, self.get_text(), self.delayed_operations)

            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.283">def apply(self, Onew):
    """
    Algorithm 3: The undo/transform-do/transform-redo scheme (sun98generic)
    
    Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
    
    1. Undo operations in HB from right to left until an operation EOm is found such that EOm =&gt; Onew .
    2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
    3. Transform each operation EOm+i in HB[m+1,n] into the new execution form EO'm+i as follows:
        - EO'm+1 := IT (EOm+1, EOnew ).
        - For 2 &lt;= i &lt;= (n - m),
            (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
            (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
        Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
    
    After the execution of the above steps, the contents of the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    ---
    This function manage the History Buffer and update the State Vector Table.
    """
            
    assert T(Onew) in ["Insert", "Delete"], "Invalid operation request."
    
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; applying %s"%(self.site_index, self.state_vector, self.get_text(), Onew)


    HB = self.HB

    # 1.
    m = 0 # manage the case HB == []
    undoed = []
    for m in range(len(HB) -1, 0 -1, -1):	 # from right to left
        EOm = HB[m]
        #print "check_total_ordering(%s, %s) =&gt; %i"%(EOm, Onew, check_total_ordering(EOm, Onew)) # just for debugging
        if not check_total_ordering(EOm, Onew):
            self.undo(EOm)
            # operations do should not be erased from HB, because they will later be transformed !
            undoed.append(EOm)
        else:
            break
        
    if HB and len(undoed) == len(HB):
        if dbg&gt;=2:
            print "No previous op found !"
        m = -1 # to indicate that no previous op was found

    # 2.
    EOnew = GOT( Onew, HB[:m+1]) # pass Onew and HB = [EO1, EO2, ..., EOm ]
    self.execute(EOnew)
    # EOnew will be inserted after step 3 to follow better the paper notation.
    if dbg&gt;=2:
        print "m %i; [EO1, ..., EOm ] %s; HB[m+1:] %s"%(m,  HB[:m+1],  HB[m+1:])

    
    # 3.
    if undoed: # if there was an undo, then redo
        if dbg&gt;=1:
            print "Site %s; '%s'; undoed %s; executed %s;"%(self.site_index, self.get_text(), undoed, EOnew) # just for debugging
        EOoL = [] # EO'm+1 List

        EOoL.append( IT( HB[m+1], EOnew ) ) 
        for i in range(1, len(undoed)):  # python indexes start from 'zero' (in the paper they start from 'one')
            TO = LET( HB[m+1+i], reverse(HB[m+1: m+i +1])) # paper [m+1,m+i - 1] -&gt; python [m+1:m+i +1]
            EOoL.append( LIT( TO, [EOnew] + EOoL) )

        #print "m: %i; len(EOoL) %i;EOoL %s"%(m, len(EOoL), EOoL) # just for debugging
        for i in range(len(EOoL)):			
            t_op = EOoL[i]
            self.execute(t_op)
            HB[m+1+i] = t_op # python indexes start from 'zero'


    # After the execution of the above steps [...] HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    HB.insert(m + 1, EOnew) # insert into the HB, just after EOm
        
        
    # Update local State vector
    t_index = Onew["source_site"]
    assert t_index &lt; len(self.state_vector), "Received an operation from a source_site outside the state_vector range"
    self.state_vector[t_index] += 1

    if EOnew["source_site"] != self.site_index: # local SVT is linked to the local SV
        self.state_vector_table[EOnew["source_site"]] = list(EOnew["timestamp"]) # update state_vector_table (via a list copy)

    if (len(HB) % 10) == 0: # call the garbage collector (over a dummy periodic condition)
        self.collect_garbage()

    return
</t>
<t tx="rodrigob.121403173614.284">def execute(self, EO, splitted_part=0):
    """
    Modify the text buffer.
    The lost information is stored into the operators for future undos.
    """
    
    if EO.get("is_splitted"):
        self.execute(EO["splitted_head"], splitted_part=1)
        self.execute(EO["splitted_tail"], splitted_part=1)
        return
        
    startpos = P(EO)
    data     = EO["data"]
    
    if T(EO) == "Insert":
        t_list = list(self.text_buffer)
        t_list.insert(startpos, data)	
        self.text_buffer = ''.join(t_list)
        
    elif T(EO) == "Delete":
        length = data
        t_text = self.text_buffer
        EO["deleted_text"] = t_text[startpos:(startpos+length)]
        self.text_buffer = ''.join(t_text[:startpos] + t_text[(startpos+length):])	
        
    else:
        raise " Tried to executed an Unmanaged Operation type"
        
    return
    
redo = execute # alias</t>
<t tx="rodrigob.121403173614.285">def undo(self, EO):
    """
    Undo an operation. Return the text to his previous state.
    The undo operation supose that EO is the last operation executed over the buffer.
    """
    
    if EO.get("is_splitted"):
        self.undo(EO["splitted_head"])
        self.undo(EO["splitted_tail"])
        return

    if T(EO) == "Delete":
        assert EO.has_key("deleted_text"), "Undoable operation (no undo info stored)"
        self.execute( op("Insert", P(EO), EO["deleted_text"]) ) # create the undo operation and execute it
        
    elif T(EO) == "Insert":
        self.execute( op("Delete", P(EO), len(S(EO)) ) ) # create the undo operation and execute it
        
    else:
        raise "Trying to undo an Unmanaged Operation."
    
    
    return

</t>
<t tx="rodrigob.121403173614.286">def collect_garbage(self):
    """
    Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
    Scan HB from left to right. Let EO be the current operation under inspection.
    Suppose that EO was generated at site i and timestamped by SVEO.
        (1) If SVEO [i] &lt;= MSVk[i], then EO is removed from HB and continue scanning.
        (2) Otherwise stop scanning and return.
        
    (The garbage collection procedure can be invoked periodically, or after processing each remote operation/message, or when the number of buffered operations in HB goes beyond a preset threshold value.)
    """
    # reference asignations (local aliases)
    HB  = self.HB 
    SVT = self.state_vector_table
    MSV = self.minimum_state_vector
    
    # compute the MSV
    for i in range(len(MSV)):
        MSV[i] = min( [ sv[i] for sv in SVT ] )
    
    if dbg &gt;=1:
        print "Site %s; MSV %s; SVT %s;"%(self.site_index, MSV, SVT)
        
    # collect the garbage
    for EO in HB:
        i    = EO["source_site"]
        SVEO = EO["timestamp"]
        
        condition = reduce(lambda x,y: x+y, [ SVEO[i] &lt;= MSV[i] for i in range(len(SVEO))]) == len(SVEO) # bizare but it works
        
        if condition:
            HB.remove(EO)
            if dbg&gt;=1:
                print "Site %s; removing %s"%(self.site_index, EO)
        else:
            break
            
            
    return


def update_SVT(self, site_index, state_vector):
    """
    update_StateVectorTable
    
    sun98achievings.pdf, page 19 paragraph 2.
    If one site happens to be silent for an unusually long period of time, other sites will not know what its state is [a 'mostly observer' site]. Therefore, it is required for a site to broadcast a short state message containing its state vector when it has not generated an operation for a certain period of time and/or after executing a certain number of remote operations. Upon receiving a state message from a remote site r, site k simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
    ---
    This function is used as a remote call to broadcast the state message.
    """
    
    self.state_vector_table[site_index] = state_vector
    
    return</t>
<t tx="rodrigob.121403173614.287">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    t_SV = list(self.state_vector) # copy the list
    t_SV[self.site_index] += 1
    
    t_op = Operation(type, pos, data, t_SV, self.site_index)
    
    for k in kws.keys():
        t_op[k] = kws[k]
        
    if dbg&gt;=1:
        print "Site %s; generating %s"%(self.site_index, t_op)
    
    self.receive_op(t_op)
    
    return t_op

def gen_op(self, type, pos, data, **kws):
    """
    Alias of generate_operation.
    """
    return self.generate_operation(type, pos, data, **kws)
    
    
def gen_Op(self, type, data, pos, **kws):
    """
    Alias with another parameters order.
    """
    
    return self.gen_op(type, pos, data, **kws)
</t>
<t tx="rodrigob.121403173614.288">@
Function defined over the operation that return boolean values
@c
</t>
<t tx="rodrigob.121403173614.289">
def is_causally_ready(t_O, t_site):
    """
    Definition 5: Conditions for executing remote operations

    Let O be an operation generated at site s and timestamped by SVo . O is causally-ready for execution at site d (d != s) with a state vector SVd only if the following conditions are satisfied:
        1. SVo [s] = SVd [s] + 1, and
        2. SVo [i] &lt;= SVd [i], for all i in {0,1, ..., N - 1} and i != s.
    """
    
    SVd = t_site.state_vector
    SVo = t_O["timestamp"]
    s   = t_O["source_site"]
    
    assert len(SVd) == len(SVo) 
    assert type(s) == types.IntType, "The operation has no source site (%s)"%(t_O)
    
    # 1.
    condition1 = ( SVo[s] == SVd[s] + 1 )
    
    #2.
    condition2 = 1
    for i in range(len(SVd)):
        if i == s: continue
        condition2 = condition2 and (SVo[i] &lt;= SVd[i])
    
    
    return condition1 and condition2
</t>
<t tx="rodrigob.121403173614.290">
def check_total_ordering(Oa, Ob):
    """
    Check if Oa =&gt; Ob.
    Definition 6: Total ordering relation "=&gt;"
    
    Given two operations Oa and Ob, generated at sites i and j and timestamped by SVOa and SVOb, respectively, then Oa =&gt; O b, iff:
        1. sum(SVOa) &lt; sum(SVOb), or
        2. i &lt; j when sum(SVOa) = sum(SVOb),
    
    where sum(SV) = $\sum_{i=0}^{N-1} SV[i]$.	
    """
    
    sum = lambda t_list: reduce(lambda x,y: x+y, t_list)
    
    SVOa = Oa["timestamp"]
    SVOb = Ob["timestamp"]
    
    assert SVOa and SVOb, "can not check operations without timestamp. (Oa:%s; Ob:%s)"%(Oa, Ob)
    
    # 1.
    condition1 = sum(SVOa) &lt; sum(SVOb)
    
    #2.
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    condition2 = (sum(SVOa) == sum(SVOb)) and (i &lt; j)
        
    return condition1 or condition2
</t>
<t tx="rodrigob.121403173614.291">@
Definition 1: Causal ordering relation "-&gt;"

Given two operations Oa and Ob , generated at sites i and j, then Oa -&gt; Ob , iff:
    1. i = j and the generation of Oa happened before the generation of Ob , or
    2. i != j and the execution of Oa at site j happened before the generation of Ob , or
    3. there exists an operation Ox, such that Oa -&gt; Ox and Ox -&gt; Ob.

Definition 2: Dependent and independent operations

Given any two operations Oa and Ob.
    1. Ob is said to be dependent on Oa iff Oa -&gt; Ob.
    2. Oa and Ob are said to be independent (or concurrent) iff neither Oa -&gt; Ob , nor Ob -&gt; Oa , which is expressed as Oa || Ob.

(nor == not or; 0,0 =&gt; 1 , 0 else)

@c

def are_dependent(Oa,Ob):
    """
    Implement a less than strict check. Will return true if (Oa-&gt;Ob) or if there is a Ox such as (Oa-&gt;Ox and Ox-&gt;Ob)
    
    After reading in detail the papers I propose:
    Oa -&gt; Ob iff :
        if i==j: return SVoa[i] &lt; SVob[i]
        else:    return SVoa[i] &lt;= SVob[i]
    """
    
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    
    if i == j:
        return Oa["timestamp"][i] &lt;  Ob["timestamp"][i]
    else:
        return Oa["timestamp"][i] &lt;= Ob["timestamp"][i]
    
    return
    

def are_concurrent(Oa,Ob):
    """
    Check if both operations are independent (or concurrent)
    
    return Oa-&gt;Ob nor Ob-&gt;Oa
    (nor == not or; 0,0 =&gt; 1 , 0 else)
    """	
    return not (are_dependent(Oa,Ob) or are_dependent(Ob,Oa) )
    
    
are_independent = are_concurrent # just an alias
</t>
<t tx="rodrigob.121403173614.292">
def GOT( Onew, HB):
    """ 
    GOT: Generic Operation Transform
    Algorithm 2: The GOT control scheme (sun98generic)

    Given a new causally-ready operation Onew , and HB = [EO1 , EO2, ..., EOm ]. The following steps are executed to obtain EOnew :
    
    1. Scanning the HB from left to right to find the first operation EOk such that EOk || Onew (EOk and Onew are concurrent (or independent)). If no such an operation EOk is found, then EOnew := Onew.
    
    2. Otherwise, search the range of HB[k+1,m] to find all operations which are causally preceding Onew, and let EOL denote these operations. If EOL = [ ], then EOnew := LIT (Onew , HB[k,m]).
    
    3. Otherwise, suppose EOL = [EOc1, ..., EOcr ], the following steps are executed:
        (a) Get EOL' = [EO'c1, ..., EO'cr ] as follows:
            i. EO'c1 := LET (EOc1, reverse(HB[k, c1 - 1]) ):
            ii. For 2 &lt;= i &lt;= r,
                TO := LET (EOci , reverse(HB[k, ci - 1]) );
                EO'ci := LIT (TO, [EO'c1, ..., EO'ci-1]).
        (b) O'new := LET (Onew, reverse(EOL') ).
        (c) EOnew := LIT (O'new, HB[k,m]).
    """
    
    EOnew = Onew # the default result
    
    for k in range(len(HB)):
        EOk = HB[k]
        if are_concurrent(EOk, Onew): 
            EOL = HB[k+1:]; c1 = k+1 
            if EOL == []:
                EOnew = LIT(Onew, HB[k:])
            else:
                # (a) i.
                r = len(EOL) 
                
                EOLl = range(r) # EOLl &lt;=&gt; EOL'
                #print "GOT (a) i.; r %s; (k,c1 - 1) %s; len(HB) %s"%(r, (k,c1 - 1), len(HB)) # just for debugging
                
                EOLl[0] = LET(EOL[0], reverse(HB[k:c1 - 1 +1])) # +1 because in paper notation ranges are incluse, incluse ('[]'); while python they are incluse, exclusive ('[)')
                
                # (a) ii.
                for i in range(1,r):
                    TO = LET(EOL[i], reverse(HB[k: c1 + i - 1 + 1]))
                    EOLl[i] = LIT(TO, EOLl[1:i-1+1])
                
                # (b)
                Oonew = LET(Onew, reverse(EOLl))
                
                # (c)
                EOnew = LIT(Oonew, HB[k:])
            
    return EOnew</t>
<t tx="rodrigob.121403173614.293">def LIT(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LIT(IT(O, OL[0]), OL[1:])
    
    return Oo
    
def LET(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LET(ET(O, OL[0]), OL[1:])
    
    return Oo
    

def reverse(in_list):
    """
    Helper function used to have a compact notation.
    """
    
    t_list = list(in_list) # create a copy
    t_list.reverse() # in place operator
    
    return t_list</t>
<t tx="rodrigob.121403173614.294">
def IT (Oa, Ob):
    """
    Inclusion Transform.
    Return a transformed Oa, named Ooa, such that the impact of the independent operation Ob (against Oa) is efectively included into Oa.
    Also define the timestamp of the virtual operation.
    """

    if Check_RA(Oa):
        #print "Check_BO(\n\t%s, \n\t%s \n)\t\t=&gt; %s"%(Oa, Ob, Check_BO(Oa, Ob)) # just for debugging
        if Check_BO(Oa, Ob):
             Ooa = Convert_AA(Oa, Ob)
        else:
             Ooa = Oa 
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
         Ooa = IT_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = IT_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = IT_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete"
        Ooa = IT_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:	
        print "IT(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
        
    return Ooa


def IT_II(Oa, Ob):

    if P (Oa) &lt; P (Ob):
        Ooa = Oa
    else:
        Ooa = Op( "Insert", S(Oa), P(Oa) + L(Ob) )
        
    return Ooa


def IT_ID(Oa, Ob):

    if P(Oa) &lt;= P(Ob):
        Ooa = Oa 
    elif P(Oa) &gt; ( P(Ob) + L(Ob) ):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Ob) )
        
        Save_LI(Ooa, Oa, Ob )
        
    return Ooa

def IT_DI(Oa, Ob):

    if P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= P(Ob):
        Ooa = Op( "Delete",  L(Oa), P(Oa) + L(Ob) )
    else: 
        Ooa = Splitted( 
                        Op( "Delete", P(Ob) - P(Oa)          , P(Oa)         ),
                        Op( "Delete", L(Oa) - (P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

def IT_DD(Oa, Ob):

    if P (Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &gt;= P(Oa) and (P(Oa) + L(Oa)) &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", 0, P(Oa) )
        elif P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", P(Oa) + L(Oa) - (P(Ob)+ L(Ob)), P (Ob) )
        elif P(Ob) &gt; P(Oa) and (P(Ob) + L(Ob)) &gt;= (P(Oa) + L(Oa)):
            Ooa = Op( "Delete", P(Ob) - P (Oa), P(Oa) )
        else:
            Ooa = Op( "Delete", L(Oa) - L(Ob), P(Oa) )
            
        Save_LI(Ooa, Oa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



</t>
<t tx="rodrigob.121403173614.295">def ET(Oa, Ob):
    """
    Exclusion Transform.
    Transform Oa against its causally preceding operation Ob to produce Ooa in such a way that Ob's impact on Oa is excluded.
    Also define the timestamp of the virtual operation.
    """
    
    if Check_RA(Oa):
        Ooa = Oa
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
        Ooa = ET_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = ET_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = ET_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete":
        Ooa = ET_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:		
        print "ET(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
    
    return Ooa

def ET_II(Oa, Ob):

    if P(Oa) &lt;= P(Ob) :
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Oa) - P(Ob) )
        Save_RA(Ooa, Ob)
        
    return Ooa

def ET_ID(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Oa) &lt;= P(Ob):
        Ooa= Oa
    else:
        Ooa= Op( "Insert", S(Oa), P(Oa) + L(Ob) )

    return Ooa
    
    
def ET_DI(Oa, Ob):

    if(P(Oa) + L(Oa)) &lt;= P(Ob):
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa))  &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", L(Oa), P(Oa) - P(Ob) )
        elif P(Ob) &lt;= P(Oa) and ((P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob))):
            Ooa = Splitted ( Op( "Delete",  P(Ob) + L(Ob) - P(Oa)         ,(P(Oa) - P(Ob)) ),
                                         Op( "Delete", (P(Oa) + L(Oa))-(P(Ob) + L(Ob)), P(Ob)          ) )
        elif P(Oa) &lt; P(Ob) and ((P(Ob) + L(Ob)) &lt;= (P(Oa) + L(Oa))):
            Ooa = Splitted( Op( "Delete", L(Ob)        , 0     ), 
                            Op( "Delete", L(Oa) - L(Ob), P(Oa) ) )
        else:
            Ooa = Splitted( Op( "Delete", P(Oa) + L(Oa) - P(Ob), 0     ), 
                            Op( "Delete", P(Ob) - P(Oa)        , P(Oa) ) )
        
        Save_RA(Ooa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



def ET_DD(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa
    elif P(Oa) &gt;= P(Ob) :
        Ooa = Op( "Delete", L(Oa), P(Oa) + L(Ob))
    else :
        Ooa = Splitted( Op( "Delete", P(Ob) - P(Oa)         , P(Oa)         ),
                        Op( "Delete", L(Oa) -(P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

</t>
<t tx="rodrigob.121403173614.296">class Operation(dict):
    """
    simple object that encapsulate the information and methods related to the operations.
    it is a dictionary with extra methods.
    """
    
    def __init__(self, type=None, pos=None, data=None, timestamp=None, source_site=None, **kws):
        
        d = self
        
        d["type"] = str(type)
        d["pos"]  = pos
        d["data"] = data # text or len
            
        d["timestamp"]   = timestamp
        d["source_site"] = source_site
        
        for k in kws.keys():
            d[k] = kws[k]
                    
        return

    def __eq__(self, other): 
        """
        The papers do not explain how to manage the TimeStamp of the operations during transforms and do not explain which operations are considered to be equivalents.
        Studying in detail the sequence of transformations that the example generate:
            LIT(ET(O4, ET(EO2, EO1)), [EO1, EO2])
        I deduce that the first approach of using Operations class instances is wrong. Doing that Transformation mutate the operators passed is wrong too.
        If during transform the timestamp are preserved then timestamp and source_site are the unique identifiers of a operation. Then IT(EO, EOx) == ET(EO, EOx) == EO; this is not intuitive but it works.
        ----
        x==y calls x.__eq__(y)
        """
        
        assert isinstance(other, Operation), "Only operations instances can be compared"
        
        return (self["source_site"] == other["source_site"]) and (self["timestamp"] == other["timestamp"])

    def __repr__(self):
        """
        """
        return "%s"%(self)
        
    def __str__(self):
        """
        """
        
        t_keys = filter(lambda x: x not in ["type", "pos", "data", "source_site", "timestamp"], self.keys())
        
        t_string = ""
        
        if self.has_key("source_site") and self.get("timestamp") :
            t_string += "from S%s%s "%(self["source_site"], self["timestamp"])
            
        if type(self["data"]) in types.StringTypes:
            t_data = "'%s'"%(self["data"])
        else:
            t_data = self["data"]
            
        t_string += "%s@%s:%s"%(self["type"], self["pos"], t_data)
         
        for k in t_keys:
                t_string += ", %s:'%s'"%(k, self[k])
            
        return "{%s}"%t_string
        
    def set_timestamp(self, t_SV):
        """
        Save a state vector as the timestamp.
        """
        
        self["timestamp"] = t_SV
        return
        
    def get_timestamp(self):
        """
        return the state vector used as the timestamp.
        """
        return self.get("timestamp")
    
        
# end of class Operation

@
Dummy function to shortcut the code.
@c

def Op(type, data, pos): # this one has a diferent parameters order
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)
    
def op(type, pos, data):
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)


@
Simple function used in the algorithm (enhance readability and paper notation matching)
@c

def T(O):
    """
    Return the type of operation ("Insert" or "Delete")
    """
    return O["type"]
        
    
def P(O):
    """
    Return the position where the operation is executed.
    """
    return O["pos"]


def L(O):
    """
    Return length of the deletion operation.
    For safness if the operation is no a deletion it return the length of the inserted text. (stricly it should raise an error...)
    """
    
    data = O["data"] # speed-up
    assert data != None, "Operation has no data! (%s in %s)"%(data, O)
    
    if type(data) == types.IntType:
        return data
    else:
        return len(data)


def S(O):
    """
    Return the string that the insert operation is trying to insert.
    """
    
    assert type(O["data"]) in types.StringTypes, "S(O) is only valid for Insertion operation."
        
    return O["data"]
    
</t>
<t tx="rodrigob.121403173614.297">
def Splitted(O1, O2):
    """
    Return an operation that is splitted. (this should considered in function 'execute' and 'undo')
    """
    
    assert T(O1) == T(O2), "Splitted operations are of different types, this is not sane."
    assert not (O1.get("is_splitted") or O1.get("is_splitted") ), "Recursive splitted operation not yet supported" 
        
    Oo = Operation(T(O1))
    Oo["is_splitted"] = 1
    Oo["splitted_head"] = O1
    Oo["splitted_tail"] = O2
    
    
    if P(O1) &lt; P(O2):
        Oo["pos"] =  P(O1)
        Oo["data"] =  ( P(O2) + L(O2) ) - P(O1)
    elif P(O1) &gt; P(O2):
        Oo["pos"] = P(O2)
        Oo["data"] = ( P(O1) + L(O1) ) - P(O2)
    else:
        raise "Weird split P(O1) == P(O2) (%s,%s)"%(O1, O2)
        
    return Oo



</t>
<t tx="rodrigob.121403173614.298">@
LI refers to "Lost Information".
@c
        
    
def Check_LI(Oa, Ob):
    """
    Ob was involved in a information lossing operation that afected Oa ?
    """
    
    return 	Oaa.get("LI_reference_op") == Ob
    
    
def Save_LI(Oaa, Oa, Ob):
    """
    Store in Oaa the information related to the paremeters of Oa and the reference to Ob.
    
    One operation can only store one and only one information lose.
    """
    
    copy_Oa = op(Oa["type"], Oa["pos"], Oa["data"] )
    
    Oaa["lost_information"]     = copy_Oa
    Oaa["LI_reference_op"]      = Ob
    
    return


def Recover_LI(Oa):
    """
    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DID NOT FOUND SPECIFICATION (this could cause horrible errors)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    """
    
    return 	Oa["lost_information"]
</t>
<t tx="rodrigob.121403173614.299">    
def Check_RA(Oa):
    """
    Is Oa relatively addressed ?
    """
    
    return Oa.has_key("relatively_addressed") and Oa["relatively_addressed"]
    
    
def Save_RA(Oa, Ob):
    """
    Stores the information to mark Oa as having a relative address to over Ob.
    """
    
    #print "called Save_RA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oa["relatively_addressed"] = 1
    Oa["base_operation"] = Ob
    Oa["delta_pos"] = P(Oa) - P(Ob) # Abis = P(Obbis) + A.delta_pos
    
    return
    
def Check_BO(Oa, Ob):
    """
    Ob is the base operation of Oa ? (in the relative address context)
    """
    
    #Ox = Oa.get("base_operation")
    #return (Ox["source_site"] == Ob["source_site"]) and (Ox["timestamp"] == Ob["timestamp"])
    
    return Ob == Oa.get("base_operation") # look at the definition of __eq__ in the Operation class
    

def Convert_AA(Oa, Ob):
    """
    Obtain Oaa, which is an absolute address operation based on Oa, over the relative position of Ob.
    """
    
    assert Check_BO(Oa,Ob), "Convert_AA: Ob is not the base_operation of Oa"
    
    #print "called Convert_AA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oaa = op( Oa["type"],	Oa["delta_pos"] + Ob["pos"], Oa["data"] )
    
    return Oaa

</t>
<t tx="rodrigob.121403173614.300">@
I had a first attemp to create a virtual Server-Client only comunication between different clients. But this approach seems to have failed.
So now I'm going to implement a less optimal system, but hundred of times easier.
The idea is very easy.
The clients then the operations to the client and the server send them to all the other clients.
The server is an Observer, applying locally the operations but never generating one.

With this approach the client addition process is slower and a little more complicated. Also the operations packet grow a little as there are more clients connected to a node.
The advantage is that this systems still reducing the bandwith usage of each client and it do not add any special logic to the base case.
@c
</t>
<t tx="rodrigob.121403173614.301">class ConcurrentEditableServer(ConcurrentEditable):
    """
    Simple Observer and operations repeater.
    It manage all the conection/disconnection syncronization problems.
    """
    
    def __init__(self,):
        """
        """
        # init the internal ConcurrentEditable
        
        ConcurrentEditable.__init__(self, None, 0) # (self, site_index, num_of_sites)
        
        self.connected_sites = {} # the mapping between the connected sites and they site_index
        self.indexed_sites   = {} # the reverse map of connected_sites
        
        self.base_text = ""
        return
        
        
    @others
    
</t>
<t tx="rodrigob.121403173614.302">def add_client(self, client_perspective):
    """
    Register the client to the clients list. 
    Assign a client index. 
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).
    Return the tuple (site_index, num_of_sites)
    """

    if dbg&gt;=1:
        print "Adding client to server."
        print "Server HB %s"%self.HB

            
    # register the client
    if client_perspective in 	self.connected_sites.keys():
        raise "Client already connected, addition rejected."
        return
    
    # assign a site index
    site_index = len(self.state_vector) # a new entry at the end of the list
    self.connected_sites[client_perspective] = site_index 
    self.indexed_sites[site_index] = client_perspective
    
    # expand the vectors and matrices
    self.state_vector.extend(extra)
    
    for t_vector in self.state_vector_table:
        if t_vector != self.state_vector:
            t_vector.extend(extra)
        
    self.state_vector_table.append([0]*len(self.state_vector))
    self.minimum_state_vector.extend(extra)

    #print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
    #print "Server HB %s" % self.HB # just for debugging
    
    assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)

    # expand the operations timestamp in the HB
    for t_op in self.HB:
        t_op["timestamp"].extend(extra)
        
        if t_op.get("base_operation"): # RA: relative address
            t_op["base_operation"]["timestamp"].extend(extra)
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
            t_op["splitted_head"]["timestamp"].extend(extra)			
            t_op["splitted_tail"]["timestamp"].extend(extra)			
            
        if t_op.get("lost_information"): # LI: lost information
            t_op["lost_information"].get("timestamp", []).extend(extra)
            t_op["LI_reference_op" ].get("timestamp", []).extend(extra)
    

    # put up to date the state of the new client
    self.send_text(site_index, self.base_text) 
    
    i = 0
    for t_Op in self.HB: # send the operations in the HB
        i+=1
         
        # convert the timestamp to the compact form and send.
        t_op = Operation(**t_Op) # copy
        t_op["source_site"] = 0 	# set the source_site as the Server side (site_index == 0)
    
        t_op["timestamp"] = [i, 0]

        self.send_operation(site_index, t_op) # send it	# compose the history buffer
        
    if dbg&gt;=1:
        print "Now we have %s clients connected."%(len(self.connected_sites))
        print "Server HB %s"%self.HB
        print
            
    return (site_index, len(self.state_vector))
    

        
def del_client(self, client_perspective):
    """
    The inverse of add_client.
    """
    
    # delete the client
    i = self.connected_sites[client_perspective]
    
    del self.indexed_sites[self.connected_sites[client_perspective]]
    del self.connected_sites[client_perspective]
    

    # update the site_index mapping ----
        
    # shrink the vectors and matrices
    shrink = lambda x: hasattr(x, "__delslice__") and x.__delslice__(i, i+1) # delete the 'i'th item
    
    shrink(self.state_vector)
    
    for t_vector in self.state_vector_table:
        shrink(t_vector)
        
    shrink(self.state_vector_table)
    shrink(self.minimum_state_vector)

    # shrink the operations timestamp in the HB
    for t_op in self.HB:
        shrink(t_op["timestamp"])
        
        if t_op.get("base_operation"): # RA: relative address
            shrink(t_op["base_operation"]["timestamp"])
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail"): # Splitted
            shrink(t_op["splitted_head"]["timestamp"])			
            shrink(t_op["splitted_tail"]["timestamp"])			
            
        if t_op.get("lost_information"): # LI: lost information
            try:
                shrink(t_op["lost_information"].get("timestamp"))
            except:
                pass
            try:
                shrink(t_op["LI_reference_op" ].get("timestamp"))
            except:
                pass
                
    if len(self.indexed_sites) == 0: # there are no more clients connected
        # clean up the node
        self.HB = []
        self.base_text = self.get_text()
        #&gt;&gt;&gt;&gt;&gt;&gt;&gt;ADD CODE HERE (what is missing?)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        
    return
        


</t>
<t tx="rodrigob.121403173614.303">def generate_operation(self, type, pos, data, **kws):
    """
    Explicit censure.
    """
    raise "The server is an observer it should never generate an operation.0"
    return
    
</t>
<t tx="rodrigob.121403173614.304">def apply(self, Onew):
    """
    Send to all the other users and Apply locally .
    """
    
    # first send to other users to enhance responsiveness
    for t_index in range(len(self.state_vector)):
        if t_index == Onew["source_site"]: continue # do not send back to the emisor	
        self.send_operation(t_index, Onew) # send it

    
    ConcurrentEditable.apply(self, Onew) # apply localy
    
    return 



</t>
<t tx="rodrigob.121403173614.305">def compute_base_text(self):
    """
    The base text is the text underlying the operations in the history buffer. Could be created from the operation cleaned by the garbage collector or is text that persisted from other sessions.
    """
    for t_op in reverse(self.HB):
        self.undo(t_op)
    
    base_text = self.get_text() # base text is the text created by the erased operations (erased by the garbage collector or when the node was alone)
    
    for t_op in self.HB:
        self.redo(t_op)
    
    return</t>
<t tx="rodrigob.121403173614.306">@
This method have to be overwritten for network transfers support.
@c
</t>
<t tx="rodrigob.121403173614.307">
def send_operation(self, site_index, t_op):
    """
    This function is called by apply.
    This method should be overwritten for real network transmision. 
    Test implementation is presented here.
    """
    
    if dbg &gt;= 1:
        print "send_op; connected_sites %s to send to %s %s"%(self.connected_sites, site_index, t_op)
        global sent_test_operations
        sent_test_operations.append(t_op)
            
    else:
        raise "This method should be overwritten to send the object over the network"
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].receive_op(t_op) 
        
    return</t>
<t tx="rodrigob.121403173614.308">def send_text(self, site_index, new_text):
    """
    This method should be overwritten for a networked implementation.
    Here only code for testing.
    """
    
    if dbg &gt;= 1:
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].set_text(new_text) 
    else:
        raise "This method should be overwritten to send the object over the network"
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].set_text(new_text) 		
    
    return</t>
<t tx="rodrigob.121403173614.309">class ConcurrentEditableClient(ConcurrentEditable):
    """
    Just a normal ConcurrentEditable but with a special garbage collector, because the Server can send operations from the past (normal client are suposed to do not do that). So the Client garbage collector is triggered by the Server.
    """
    
    def __init__(self, server_perspective=None):
        """
        """
        if server_perspective:
            self.connect_to_server(server_perspective)
            
        return
        
    @others
</t>
<t tx="rodrigob.121403173614.310">def connect_to_server(self, server_reference):
    """
    Connect to the server.
    Dummy implementation for testing purpose. This method should be overwritten to manage network methods.
    """
    
    site_index, num_of_sites = server_reference.add_client(self)
    
    # init the internal ConcurrentEditable		
    ConcurrentEditable.__init__(self, site_index, num_of_sites) # site_index, num_of_sites # the clients has site_index 1, thus state_vector == [server, client]
        
    return
</t>
<t tx="rodrigob.121403173614.311">def add_a_client(self, num_of_clients):
    """
    Add one client more
    """
    self.set_num_of_clients(len(self.state_vector)+1)
    return


def set_num_of_clients(self, num_of_clients):
    """
    Adapt the local vector to the num of clients
    
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).
    """

    if dbg&gt;=1:
        print "Adding client to server."
        print "Server HB %s"%self.HB

    assert (num_of_clients - len(self.state_vector)) &gt;= 0
    
    extra = [0]*(num_of_clients - len(self.state_vector))
    if not extra: # nothing to add
        return 
        
    # expand the vectors and matrices
    self.state_vector.extend(extra)
    
    for t_vector in self.state_vector_table:
        if t_vector != self.state_vector:
            t_vector.extend(extra)
        
    self.state_vector_table.append([0]*len(self.state_vector))
    self.minimum_state_vector.extend(extra)

    #print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
    #print "Server HB %s" % self.HB # just for debugging
    
    assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)

    # expand the operations timestamp in the HB
    for t_op in self.HB:
        t_op["timestamp"].extend(extra)
        
        if t_op.get("base_operation"): # RA: relative address
            t_op["base_operation"]["timestamp"].extend(extra)
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
            t_op["splitted_head"]["timestamp"].extend(extra)			
            t_op["splitted_tail"]["timestamp"].extend(extra)			
            
        if t_op.get("lost_information"): # LI: lost information
            t_op["lost_information"].get("timestamp", []).extend(extra)
            t_op["LI_reference_op" ].get("timestamp", []).extend(extra)
    

    # obtain the base text of the actual state		
    for t_op in reverse(self.HB):
        self.undo(t_op)
    
    base_text = self.get_text() # base text is the text created by the erased operations
    
    for t_op in self.HB:
        self.redo(t_op)
    
    # put up to date the state of the new client
    self.send_text(site_index, base_text) 
    
    i = 0
    for t_Op in self.HB: # send the operations in the HB
        i+=1
         
        # convert the timestamp to the compact form and send.
        t_op = Operation(**t_Op) # copy
        t_op["source_site"] = 0 	# set the source_site as the Server side (site_index == 0)
    
        t_op["timestamp"] = [i, 0]

        self.send_operation(site_index, t_op) # send it	# compose the history buffer
        
    
    if dbg&gt;=1:
        print "Now we have %s clients connected."%(len(self.connected_sites))
        print "Server HB %s"%self.HB
        print
            
    return
    

        
def del_client(self, client_index):
    """
    Eliminate the reference in the state_vectors of one specific client that has disconnected.
    """
    
    i = client_index
    
    # update the site_index mapping ----
        
    # shrink the vectors and matrices
    shrink = lambda x: hasattr(x, "__delslice__") and x.__delslice__(i, i+1) # delete the 'i'th item
    
    shrink(self.state_vector)
    
    for t_vector in self.state_vector_table:
        shrink(t_vector)
        
    shrink(self.state_vector_table)
    shrink(self.minimum_state_vector)

    # shrink the operations timestamp in the HB
    for t_op in self.HB:
        shrink(t_op["timestamp"])
        
        if t_op.get("base_operation"): # RA: relative address
            shrink(t_op["base_operation"]["timestamp"])
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail"): # Splitted
            shrink(t_op["splitted_head"]["timestamp"])			
            shrink(t_op["splitted_tail"]["timestamp"])			
            
        if t_op.get("lost_information"): # LI: lost information
            try:
                shrink(t_op["lost_information"].get("timestamp"))
            except:
                pass
            try:
                shrink(t_op["LI_reference_op" ].get("timestamp"))
            except:
                pass
                
    
    return
        

</t>
<t tx="rodrigob.121403173614.312">
def receive_operation(self, in_op, *args, **kw):
    """
    check if the operation timestamp correspond to the local num_of_sites
    """

    timestamp = (isinstance(in_op, Operation) and in_op.get("timestamp") ) or kw.get("timestamp")
    
    if len(timestamp) &gt; len(self.state_vector):
        self.set_num_of_clients(len(timestamp)) # adapt the length of the state vectors
    elif len(timestamp) &lt; len(self.state_vector):
        raise "A disconection ocurred and the client is not aware. (len(timestamp) &lt; len(self.state_vector))" # error condition

    ConcurrentEditable.receive_operation(self, in_op, *args, **kw) # receive the operation
            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.313">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    # create and apply
    t_op = ConcurrentEditable.generate_operation(self, type, pos, data, **kws)

    # overwrite source_site to give a reference (instead of a dummy number)
    ret_op = Operation(**t_op) # copy the operation
    
    return ret_op</t>
<t tx="rodrigob.121403173614.314">def set_text(self, new_text):
    """
    Blindly overwrite the text of this site.
    """
    
    self.text_buffer = new_text
    
    return</t>
<t tx="rodrigob.121403173614.315">@
The unit tests for concurrent editions.
@c


def Tests():
    """
    run the tests
    """
    
    global dbg
    dbg = 0
    
    if 0: # hand made unittest 
        print "Starting tests"
        TestConcurrentEditable1()
        print "-"	* 30
        TestConcurrentEditable2()
        print "-"	* 30	
        TestConcurrentEditableServer()
        print "end of tests"
        return



    import unittest
    

    TestSuite = unittest.TestSuite()
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable1))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable2))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditableServer))
    
    unittest.TextTestRunner().run(TestSuite)
    
    return</t>
<t tx="rodrigob.121403173614.316">
def TestConcurrentEditable1():
    """
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Delete 1 2
        - O4 Insert 2 "c"
    So the final result should be "ABCcD" in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable1 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test the alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4") 
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    

    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.317">
def TestConcurrentEditable2():
    """
    Second test is similar to Test1 but with other operations. Try to test other code areas (i.e. Lost Information cases)
    
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Insert 5 "c"
        - O4 Delete 0 3
    So the final result should be ABCc in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable2 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCc" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCc', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.318">
def TestConcurrentEditableServer():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a Star network; with one central server and three clients connecting to it.
    """

    global dbg
    dbg = 1 # ;P
    
    print "-"*15
    print "Read docstring of TestConcurrentEditableServer for more info about this test.\n"
    
    # creates server
    server = ConcurrentEditableServer()
    
    # connect site 0 and 1
    site0 = ConcurrentEditableClient(server)
    site1 = ConcurrentEditableClient(server)
    
    
    global sent_test_operations; 	sent_test_operations = [] # used for delaying the transmissions in the test
    
    # start editions
    # Apply the operations in each site (following the order of the picture)
    print "Site0"; O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1", gen_site="0") # generate and apply locally the operation
    print "Site1"; O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2", gen_site="1") # test the alias

    # O*_toS* is an operation that was sent by the server to the client. This object is delayed to simulate delays in the transmissions lines.
    # the order of reception of commands is similar of the TestConcurrentEditable1
    server.receive_op(O2); [O2_toS0] = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    server.receive_op(O1);	[O1_toS1] = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    
    # connect site 2 (to test connection during sessions)
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
    
    server.add_client(site2)
    for t_op in sent_test_operations:
        site2.receive_op(t_op)

    sent_test_operations = []
    
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
        
    # continue editions
    print "Site1"; site1.receive_op(O1_toS1) # receive delayed operations sent by the server
    print "Site0"; site0.receive_op(O2_toS0)
    print "Site2"; O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4", gen_site="2") 
    server.receive_op(O4); O4_toS0, O4_toS1 = sent_test_operations; print "sent_test_operations %s\n"%sent_test_operations; sent_test_operations = []	
    print "Site0"; site0.receive_op(O4_toS0)
    print "Site1"; O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3", gen_site="1")
    server.receive_op(O3);	print "sent_test_operations %s\n"%sent_test_operations; O3_toS0, O3_toS2 = sent_test_operations; sent_test_operations = []	
    print "Site2"; site2.receive_op(O3_toS2)
    print "Site1"; site1.receive_op(O4_toS1)
    #print "Site2"; site2.receive_op(O1_toS2) # this op should be sent when site2 connect itself to the server.
    
    # Original sequence------------------
    #O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    #O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    #site2.receive_op(O2)
    #site1.receive_op(O1)
    #site0.receive_op(O2)
    #O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    #site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    #O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    #site2.receive_op(O3)
    #site0.receive_op(O3)
    #site1.receive_op(O4)			
    #site2.receive_op(O1)
    # ------------------
    
    print
    print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
    print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
    print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
    print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
    print
        
    # --------
    
    # disconnect
    if dbg&gt;=1: print "Disconnecting the three sites."
    server.del_client(site0)	
    server.del_client(site1)	
    server.del_client(site2)	
    # --------------
        
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [server, site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success

    return 1




</t>
<t tx="rodrigob.121403173614.319">@first #!/usr/bin/env python2.2

&lt;&lt;docs&gt;&gt;

import types


dbg = 0 # debug level ;p
        
@others


if __name__ == "__main__":

    Tests()
</t>
<t tx="rodrigob.121403173614.320">@others</t>
<t tx="rodrigob.121403173614.321">"""
This code correspond to an implementation of a Concurrent Editable Text buffer.

The code is strictly based on the works of Chengzheng Sun.

Actually all the function were written in order to follow as much as possible the notation introduced in his papers. So most of the code is procedure oriented and not strictly pythonic.

Search at citeseer for the files:

    operational_transformation_issues_algorithms_achievements.djvu
    sun98achieving.pdf (&lt;- the must)
    sun97generic.pdf (citeseer.nec.jp.com/sun97generic.htm)
    sun98operational.pdf
    sun98reversible.pdf

You need this documents to understand the code.

This file provide a unit test that execute an instance of the example proposed in the reference papers.

There is also a class named ConcurrentEditableServer that try to implement a 'star' configuration (one server &lt;-&gt; N clients) for the comunications.

I recomend using Leo to explore the code. http://leo.sf.net

Released under GNU GPL. http://www.gnu.org

Rodrigo Benenson. 2003. LeoN project. 

rodrigob at elo dot utfsm dot cl
"""
</t>
<t tx="rodrigob.121403173614.322">@
release version 0.0.1 (major, minor, release)

this version is not supposed to be error prone, but it is good code base.
-------------------------------------------------------------------------

25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
         Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;HERE LOGS MISSING&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

29/07/01 Working. RodrigoB.
30/07/01 Working. RodrigoB.
31/07/01 Working. RodrigoB.
01/08/01 Working. RodrigoB.
03/08/01 Eureka.  RodrigoB.
04/08/01 Working on the Eureka documentation and implementation. Passed unit test. Cleaning up.  RodrigoB.

Todo

- Find a good TestConcurrentEditable2 to test LostInformation cases

- LI is absolutelly not verified
- Find the Recover_LI specifications.
- Find a better way to quit the ambiguities on the 'if else {}' operation pertenence. (save_RA, save_LI conditions ?)

- collect garbage do not work anymore exactly like in the example. (is this a problem ?)

@c
</t>
<t tx="rodrigob.121403173614.323">@
Big picture (of base implementation: ConcurrentEditable)
-----------

There is a concurrent editable object that receive commands  (operations to realize) associated with the State Vector of the emisor.

The received command are 'received and delayed to preserve causality' or 'executed'.

When executed an undo/transform-do/transform-redo scheme is used.

The transformation of commands (operational transforms) is realized by the GOT algorithm.

The GOT algorithm use two application specific transformation functions IT, ET (inclusion and exclusion transform, respectively).

Tadaaa...
@c
</t>
<t tx="rodrigob.121403173614.324">@
so what? -&gt; Why should you care about this code?

If you want to implement a collaborative text editing software.
You will need to care about three aspects:
    - network layer
    - editor user interface
    - core logic for collaborative editing

The python implementation allow a full cross platform usage and a very rapid deployment; considering that there already exist solutions for the network layer (Twisted) and tools to create easilly user interfaces (Tkinter, wxWindows).

I will enjoy to know about anyone using this code, so please feel free to mail me: &lt;rodrigob at elo dot utfsm dot cl&gt;.

This code is part of the development of LeoN, the Collaborative Leo plugin. http://leo.sf.net
@c
</t>
<t tx="rodrigob.121403173614.325">@
(A little explication about centralized network, ConcurrentEditableServer and ConcurrentEditableClient)

The topology suposed in the Chengzheng Sun works is an all-to-all clients connection. This assumption is theoritically correct, in internet (for example) it is supposed that every computer is able to send messages to any other one (under the restriction of the network security configurations).

Otherwise this figure is not appropiate for a real implementation because it require that every client use his bandwith to talk with every other ones and, more important, it require a distributed logic for login and logout to and ongoing session.
A distributed logic is complex and will tend to make the implementation error prone and not very responsive when login/logout. So a smart decision between the tradeoffs is required.

Tradeoffs:
    - logic complexity
    - speed of connection and disconnection
    - memory usage
    - cpu usage
    - bandwidth usage
    - implementation complexity
    - similarity to original paper

My original idea was to create an abstraction layer that will hide the existence of the other clients. Each site should be only aware of it own and the server. This was an ideal solution: all the logic complexity is situated on the server, the connection/disconnection is managed by exclusively by the server, the bandwith usage to not grow as more clients connect, the memory usage and cpu on the clients is minimized. The only problem: it cannot be done. It tooks be 2 week of work and fight with the implementation to obtain the necessary indepth to understand that such abstraction could not be done without modifying the algorithm, and this is a too dangerous attempt.

So another tradeoff equilibrium has to be found.
Without an abstraction layer every client has to be aware of each others. This make necessary an acknoledgement of every client when a connection or disconnection occurs. Doing this in a distributed scenario where already marked packets are travelling in an unknown order is complex and will tend to provide solutions that blocks the comunication before completion the connection process. Also the logic involved in client references addition and deletion is not minor and would attack the responsiveness of the clients during that process. So after various days of medition I think that I have found a good tradeoff.

To manage in a better way the bandwith we keep a Client-Server topology, where the Server acts as a mere repeater to send the received operation to every connected client.
Then the key idea is "to do not decrease the state_vectors". Doing this could be look stupid in a first perspective. But after thinking it a while you maybe will be able to understand how such a barbarity can become a good idea.
As the state_vectors do not decreases then there are only two cases: the state_vector is increased, a client replace an already disconnected one.
Both case as extremelly simples in logic cost and are robust to distributed awardness. Using the key idea the conection/disconection logic is centralized in the server and is very fast because it do not require an acknoledge signal from the rest of the clients.


If client receive an operation with a timestamp (reference state_vector) bigger than it own it will make grow all his references.
If the server recieve a new client it check for previously liberated client indexes and assign it, else it make grow all his timestamps. If a client disconnect it simply erase his reference in repeatear function.
If a client emit an operation with a shorter state vector it is because it has received no operations from the new client so it is secure to extend it with zeros.
Obviously when the last client disconnect from the server, it have the opportunity to clean shi memory and refresh back into it default state vector length.

As you can see everything become simple and robust. Maybe the bandwith usage is suboptimal, but in most usage cases the wasting marges should be reasonable.


The schema used for testing the protocol is intensionally similar to the Twisted Spread distributed object system, because I pretend to use it for the first networked subclass. I suppose that any distributed object engine should be able to deal with the required network methods.

@c
</t>
<t tx="rodrigob.121403173614.326">@
Base implementation of the paper concepts. This code do not worry about comunication methods.
@c
</t>
<t tx="rodrigob.121403173614.327">class ConcurrentEditable:
    """
    This is the core class.
    It instanciate a Site that contain an editable text.
    Will receive and generate operations.
    The implementation is focused on simplicity and paper similarities.
    """
    
    def __init__(self, site_index, num_of_sites):
        """
        if site_index == None then the site is and Observer
        """
                
        self.site_index   = site_index
        self.state_vector = [0] * num_of_sites
                
        self.state_vector_table   = [[0]* num_of_sites]* num_of_sites # required by the garbage collector (SVT)
        self.minimum_state_vector = [0]*num_of_sites # required by the garbage collector (MSV)

        if self.site_index:
            self.state_vector_table [self.site_index] = self.state_vector # link with local state_vector
  
        self.HB = [] # history buffer
        self.delayed_operations = [] 

        self.text_buffer = ""
        
        return
        
    def get_text(self):
        """
        """
        
        return self.text_buffer


    @others
    


</t>
<t tx="rodrigob.121403173614.328">
def receive_operation(self, t_op, *args, **kw):
    """
    can receive operations receiving an Operation object, or being called as : (type, pos, data, {extra args}) 
    receive an operation to execute
    check if it is causally ready
    if not delay it
    else execute it
    if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
    ---
    The workflow is receive-&gt;apply-&gt;execute
    """

    if not isinstance(t_op, Operation):
        try:
            assert len(args) == 2
            t_op = Operation(t_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(t_op, args, kw)
            
    # receive an operation to execute
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; receiving %s"%(self.site_index, self.state_vector, self.get_text(), t_op)

    
    if is_causally_ready(t_op, self): 		# check if it is causally ready
        self.apply(t_op) # execute it (apply to local buffer)
            
        # if executed check the delayed buffer to check for operation that now can be operated
        # (and so on until no operation is executable)			
        
        while 1: # uhhh, dangerous
            for tt_op in self.delayed_operations:
                if is_causally_ready(tt_op, self): 
                    self.apply(tt_op) 
                    self.delayed_operations.remove(tt_op)
                    break # break the 'for'; go back to 'while 1'
            break # end of while 1

    else: # if not delay it
        self.delayed_operations.append(t_op)
    
    if dbg &gt;=1:
        print "Site %s; HB %s"%(self.site_index, self.HB)
        print "Site %s;%s; '%s'; delayed_ops: %s\n"%(self.site_index, self.state_vector, self.get_text(), self.delayed_operations)

            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.329">def apply(self, Onew):
    """
    Algorithm 3: The undo/transform-do/transform-redo scheme (sun98generic)
    
    Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
    
    1. Undo operations in HB from right to left until an operation EOm is found such that EOm =&gt; Onew .
    2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
    3. Transform each operation EOm+i in HB[m+1,n] into the new execution form EO'm+i as follows:
        - EO'm+1 := IT (EOm+1, EOnew ).
        - For 2 &lt;= i &lt;= (n - m),
            (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
            (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
        Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
    
    After the execution of the above steps, the contents of the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    ---
    This function manage the History Buffer and update the State Vector Table.
    """
            
    assert T(Onew) in ["Insert", "Delete"], "Invalid operation request."
    
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; applying %s"%(self.site_index, self.state_vector, self.get_text(), Onew)


    HB = self.HB

    # 1.
    m = 0 # manage the case HB == []
    undoed = []
    for m in range(len(HB) -1, 0 -1, -1):	 # from right to left
        EOm = HB[m]
        #print "check_total_ordering(%s, %s) =&gt; %i"%(EOm, Onew, check_total_ordering(EOm, Onew)) # just for debugging
        if not check_total_ordering(EOm, Onew):
            self.undo(EOm)
            # operations do should not be erased from HB, because they will later be transformed !
            undoed.append(EOm)
        else:
            break
        
    if HB and len(undoed) == len(HB):
        if dbg&gt;=2:
            print "No previous op found !"
        m = -1 # to indicate that no previous op was found

    # 2.
    EOnew = GOT( Onew, HB[:m+1]) # pass Onew and HB = [EO1, EO2, ..., EOm ]
    self.execute(EOnew)
    # EOnew will be inserted after step 3 to follow better the paper notation.
    if dbg&gt;=2:
        print "m %i; [EO1, ..., EOm ] %s; HB[m+1:] %s"%(m,  HB[:m+1],  HB[m+1:])

    
    # 3.
    if undoed: # if there was an undo, then redo
        if dbg&gt;=1:
            print "Site %s; '%s'; undoed %s; executed %s;"%(self.site_index, self.get_text(), undoed, EOnew) # just for debugging
        EOoL = [] # EO'm+1 List

        EOoL.append( IT( HB[m+1], EOnew ) ) 
        for i in range(1, len(undoed)):  # python indexes start from 'zero' (in the paper they start from 'one')
            TO = LET( HB[m+1+i], reverse(HB[m+1: m+i +1])) # paper [m+1,m+i - 1] -&gt; python [m+1:m+i +1]
            EOoL.append( LIT( TO, [EOnew] + EOoL) )

        #print "m: %i; len(EOoL) %i;EOoL %s"%(m, len(EOoL), EOoL) # just for debugging
        for i in range(len(EOoL)):			
            t_op = EOoL[i]
            self.execute(t_op)
            HB[m+1+i] = t_op # python indexes start from 'zero'


    # After the execution of the above steps [...] HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    HB.insert(m + 1, EOnew) # insert into the HB, just after EOm
        
        
    # Update local State vector
    t_index = Onew["source_site"]
    assert t_index &lt; len(self.state_vector), "Received an operation from a source_site outside the state_vector range"
    self.state_vector[t_index] += 1

    if EOnew["source_site"] != self.site_index: # local SVT is linked to the local SV
        self.state_vector_table[EOnew["source_site"]] = list(EOnew["timestamp"]) # update state_vector_table (via a list copy)

    if (len(HB) % 10) == 0: # call the garbage collector (over a dummy periodic condition)
        self.collect_garbage()

    return
</t>
<t tx="rodrigob.121403173614.330">def execute(self, EO, splitted_part=0):
    """
    Modify the text buffer.
    The lost information is stored into the operators for future undos.
    """
    
    if EO.get("is_splitted"):
        self.execute(EO["splitted_head"], splitted_part=1)
        self.execute(EO["splitted_tail"], splitted_part=1)
        return
        
    startpos = P(EO)
    data     = EO["data"]
    
    if T(EO) == "Insert":
        t_list = list(self.text_buffer)
        t_list.insert(startpos, data)	
        self.text_buffer = ''.join(t_list)
        
    elif T(EO) == "Delete":
        length = data
        t_text = self.text_buffer
        EO["deleted_text"] = t_text[startpos:(startpos+length)]
        self.text_buffer = ''.join(t_text[:startpos] + t_text[(startpos+length):])	
        
    else:
        raise " Tried to executed an Unmanaged Operation type"
        
    return
    
redo = execute # alias</t>
<t tx="rodrigob.121403173614.331">def undo(self, EO):
    """
    Undo an operation. Return the text to his previous state.
    The undo operation supose that EO is the last operation executed over the buffer.
    """
    
    if EO.get("is_splitted"):
        self.undo(EO["splitted_head"])
        self.undo(EO["splitted_tail"])
        return

    if T(EO) == "Delete":
        assert EO.has_key("deleted_text"), "Undoable operation (no undo info stored)"
        self.execute( op("Insert", P(EO), EO["deleted_text"]) ) # create the undo operation and execute it
        
    elif T(EO) == "Insert":
        self.execute( op("Delete", P(EO), len(S(EO)) ) ) # create the undo operation and execute it
        
    else:
        raise "Trying to undo an Unmanaged Operation."
    
    
    return

</t>
<t tx="rodrigob.121403173614.332">def collect_garbage(self):
    """
    Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
    Scan HB from left to right. Let EO be the current operation under inspection.
    Suppose that EO was generated at site i and timestamped by SVEO.
        (1) If SVEO [i] &lt;= MSVk[i], then EO is removed from HB and continue scanning.
        (2) Otherwise stop scanning and return.
        
    (The garbage collection procedure can be invoked periodically, or after processing each remote operation/message, or when the number of buffered operations in HB goes beyond a preset threshold value.)
    """
    # reference asignations (local aliases)
    HB  = self.HB 
    SVT = self.state_vector_table
    MSV = self.minimum_state_vector
    
    # compute the MSV
    for i in range(len(MSV)):
        MSV[i] = min( [ sv[i] for sv in SVT ] )
    
    if dbg &gt;=1:
        print "Site %s; MSV %s; SVT %s;"%(self.site_index, MSV, SVT)
        
    # collect the garbage
    for EO in HB:
        i    = EO["source_site"]
        SVEO = EO["timestamp"]
        
        condition = reduce(lambda x,y: x+y, [ SVEO[i] &lt;= MSV[i] for i in range(len(SVEO))]) == len(SVEO) # bizare but it works
        
        if condition:
            HB.remove(EO)
            if dbg&gt;=1:
                print "Site %s; removing %s"%(self.site_index, EO)
        else:
            break
            
            
    return


def update_SVT(self, site_index, state_vector):
    """
    update_StateVectorTable
    
    sun98achievings.pdf, page 19 paragraph 2.
    If one site happens to be silent for an unusually long period of time, other sites will not know what its state is [a 'mostly observer' site]. Therefore, it is required for a site to broadcast a short state message containing its state vector when it has not generated an operation for a certain period of time and/or after executing a certain number of remote operations. Upon receiving a state message from a remote site r, site k simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
    ---
    This function is used as a remote call to broadcast the state message.
    """
    
    self.state_vector_table[site_index] = state_vector
    
    return</t>
<t tx="rodrigob.121403173614.333">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    t_SV = list(self.state_vector) # copy the list
    t_SV[self.site_index] += 1
    
    t_op = Operation(type, pos, data, t_SV, self.site_index)
    
    for k in kws.keys():
        t_op[k] = kws[k]
        
    if dbg&gt;=1:
        print "Site %s; generating %s"%(self.site_index, t_op)
    
    self.receive_op(t_op)
    
    return t_op

def gen_op(self, type, pos, data, **kws):
    """
    Alias of generate_operation.
    """
    return self.generate_operation(type, pos, data, **kws)
    
    
def gen_Op(self, type, data, pos, **kws):
    """
    Alias with another parameters order.
    """
    
    return self.gen_op(type, pos, data, **kws)
</t>
<t tx="rodrigob.121403173614.334">@
Function defined over the operation that return boolean values
@c
</t>
<t tx="rodrigob.121403173614.335">
def is_causally_ready(t_O, t_site):
    """
    Definition 5: Conditions for executing remote operations

    Let O be an operation generated at site s and timestamped by SVo . O is causally-ready for execution at site d (d != s) with a state vector SVd only if the following conditions are satisfied:
        1. SVo [s] = SVd [s] + 1, and
        2. SVo [i] &lt;= SVd [i], for all i in {0,1, ..., N - 1} and i != s.
    """
    
    SVd = t_site.state_vector
    SVo = t_O["timestamp"]
    s   = t_O["source_site"]
    
    assert len(SVd) == len(SVo), "State vectors are not comparable (len(SVd) == %i, len(SVo) == %i)"%(len(SVd), len(SVo)) 
    assert type(s) == types.IntType, "The operation has no source site (%s)"%(t_O)
    
    # 1.
    condition1 = ( SVo[s] == SVd[s] + 1 )
    
    #2.
    condition2 = 1
    for i in range(len(SVd)):
        if i == s: continue
        condition2 = condition2 and (SVo[i] &lt;= SVd[i])
    
    
    return condition1 and condition2
</t>
<t tx="rodrigob.121403173614.336">
def check_total_ordering(Oa, Ob):
    """
    Check if Oa =&gt; Ob.
    Definition 6: Total ordering relation "=&gt;"
    
    Given two operations Oa and Ob, generated at sites i and j and timestamped by SVOa and SVOb, respectively, then Oa =&gt; O b, iff:
        1. sum(SVOa) &lt; sum(SVOb), or
        2. i &lt; j when sum(SVOa) = sum(SVOb),
    
    where sum(SV) = $\sum_{i=0}^{N-1} SV[i]$.	
    """
    
    sum = lambda t_list: reduce(lambda x,y: x+y, t_list)
    
    SVOa = Oa["timestamp"]
    SVOb = Ob["timestamp"]
    
    assert SVOa and SVOb, "can not check operations without timestamp. (Oa:%s; Ob:%s)"%(Oa, Ob)
    
    # 1.
    condition1 = sum(SVOa) &lt; sum(SVOb)
    
    #2.
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    condition2 = (sum(SVOa) == sum(SVOb)) and (i &lt; j)
        
    return condition1 or condition2
</t>
<t tx="rodrigob.121403173614.337">@
Definition 1: Causal ordering relation "-&gt;"

Given two operations Oa and Ob , generated at sites i and j, then Oa -&gt; Ob , iff:
    1. i = j and the generation of Oa happened before the generation of Ob , or
    2. i != j and the execution of Oa at site j happened before the generation of Ob , or
    3. there exists an operation Ox, such that Oa -&gt; Ox and Ox -&gt; Ob.

Definition 2: Dependent and independent operations

Given any two operations Oa and Ob.
    1. Ob is said to be dependent on Oa iff Oa -&gt; Ob.
    2. Oa and Ob are said to be independent (or concurrent) iff neither Oa -&gt; Ob , nor Ob -&gt; Oa , which is expressed as Oa || Ob.

(nor == not or; 0,0 =&gt; 1 , 0 else)

@c

def are_dependent(Oa,Ob):
    """
    Implement a less than strict check. Will return true if (Oa-&gt;Ob) or if there is a Ox such as (Oa-&gt;Ox and Ox-&gt;Ob)
    
    After reading in detail the papers I propose:
    Oa -&gt; Ob iff :
        if i==j: return SVoa[i] &lt; SVob[i]
        else:    return SVoa[i] &lt;= SVob[i]
    """
    
    i = Oa["source_site"]
    j = Ob["source_site"]
    
    
    if i == j:
        return Oa["timestamp"][i] &lt;  Ob["timestamp"][i]
    else:
        return Oa["timestamp"][i] &lt;= Ob["timestamp"][i]
    
    return
    

def are_concurrent(Oa,Ob):
    """
    Check if both operations are independent (or concurrent)
    
    return Oa-&gt;Ob nor Ob-&gt;Oa
    (nor == not or; 0,0 =&gt; 1 , 0 else)
    """	
    return not (are_dependent(Oa,Ob) or are_dependent(Ob,Oa) )
    
    
are_independent = are_concurrent # just an alias
</t>
<t tx="rodrigob.121403173614.338">
def GOT( Onew, HB):
    """ 
    GOT: Generic Operation Transform
    Algorithm 2: The GOT control scheme (sun98generic)

    Given a new causally-ready operation Onew , and HB = [EO1 , EO2, ..., EOm ]. The following steps are executed to obtain EOnew :
    
    1. Scanning the HB from left to right to find the first operation EOk such that EOk || Onew (EOk and Onew are concurrent (or independent)). If no such an operation EOk is found, then EOnew := Onew.
    
    2. Otherwise, search the range of HB[k+1,m] to find all operations which are causally preceding Onew, and let EOL denote these operations. If EOL = [ ], then EOnew := LIT (Onew , HB[k,m]).
    
    3. Otherwise, suppose EOL = [EOc1, ..., EOcr ], the following steps are executed:
        (a) Get EOL' = [EO'c1, ..., EO'cr ] as follows:
            i. EO'c1 := LET (EOc1, reverse(HB[k, c1 - 1]) ):
            ii. For 2 &lt;= i &lt;= r,
                TO := LET (EOci , reverse(HB[k, ci - 1]) );
                EO'ci := LIT (TO, [EO'c1, ..., EO'ci-1]).
        (b) O'new := LET (Onew, reverse(EOL') ).
        (c) EOnew := LIT (O'new, HB[k,m]).
    """
    
    EOnew = Onew # the default result
    
    for k in range(len(HB)):
        EOk = HB[k]
        if are_concurrent(EOk, Onew): 
            EOL = HB[k+1:]; c1 = k+1 
            if EOL == []:
                EOnew = LIT(Onew, HB[k:])
            else:
                # (a) i.
                r = len(EOL) 
                
                EOLl = range(r) # EOLl &lt;=&gt; EOL'
                #print "GOT (a) i.; r %s; (k,c1 - 1) %s; len(HB) %s"%(r, (k,c1 - 1), len(HB)) # just for debugging
                
                EOLl[0] = LET(EOL[0], reverse(HB[k:c1 - 1 +1])) # +1 because in paper notation ranges are incluse, incluse ('[]'); while python they are incluse, exclusive ('[)')
                
                # (a) ii.
                for i in range(1,r):
                    TO = LET(EOL[i], reverse(HB[k: c1 + i - 1 + 1]))
                    EOLl[i] = LIT(TO, EOLl[1:i-1+1])
                
                # (b)
                Oonew = LET(Onew, reverse(EOLl))
                
                # (c)
                EOnew = LIT(Oonew, HB[k:])
            
    return EOnew</t>
<t tx="rodrigob.121403173614.339">def LIT(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LIT(IT(O, OL[0]), OL[1:])
    
    return Oo
    
def LET(O, OL):
    if OL==[]:
        Oo = O
    else:
        Oo = LET(ET(O, OL[0]), OL[1:])
    
    return Oo
    

def reverse(in_list):
    """
    Helper function used to have a compact notation.
    """
    
    t_list = list(in_list) # create a copy
    t_list.reverse() # in place operator
    
    return t_list</t>
<t tx="rodrigob.121403173614.340">
def IT (Oa, Ob):
    """
    Inclusion Transform.
    Return a transformed Oa, named Ooa, such that the impact of the independent operation Ob (against Oa) is efectively included into Oa.
    Also define the timestamp of the virtual operation.
    """

    if Check_RA(Oa):
        #print "Check_BO(\n\t%s, \n\t%s \n)\t\t=&gt; %s"%(Oa, Ob, Check_BO(Oa, Ob)) # just for debugging
        if Check_BO(Oa, Ob):
             Ooa = Convert_AA(Oa, Ob)
        else:
             Ooa = Oa 
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
         Ooa = IT_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = IT_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = IT_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete"
        Ooa = IT_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:	
        print "IT(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
        
    return Ooa


def IT_II(Oa, Ob):

    if P (Oa) &lt; P (Ob):
        Ooa = Oa
    else:
        Ooa = Op( "Insert", S(Oa), P(Oa) + L(Ob) )
        
    return Ooa


def IT_ID(Oa, Ob):

    if P(Oa) &lt;= P(Ob):
        Ooa = Oa 
    elif P(Oa) &gt; ( P(Ob) + L(Ob) ):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Ob) )
        
        Save_LI(Ooa, Oa, Ob )
        
    return Ooa

def IT_DI(Oa, Ob):

    if P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= P(Ob):
        Ooa = Op( "Delete",  L(Oa), P(Oa) + L(Ob) )
    else: 
        Ooa = Splitted( 
                        Op( "Delete", P(Ob) - P(Oa)          , P(Oa)         ),
                        Op( "Delete", L(Oa) - (P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

def IT_DD(Oa, Ob):

    if P (Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa 
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &gt;= P(Oa) and (P(Oa) + L(Oa)) &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", 0, P(Oa) )
        elif P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", P(Oa) + L(Oa) - (P(Ob)+ L(Ob)), P (Ob) )
        elif P(Ob) &gt; P(Oa) and (P(Ob) + L(Ob)) &gt;= (P(Oa) + L(Oa)):
            Ooa = Op( "Delete", P(Ob) - P (Oa), P(Oa) )
        else:
            Ooa = Op( "Delete", L(Oa) - L(Ob), P(Oa) )
            
        Save_LI(Ooa, Oa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



</t>
<t tx="rodrigob.121403173614.341">def ET(Oa, Ob):
    """
    Exclusion Transform.
    Transform Oa against its causally preceding operation Ob to produce Ooa in such a way that Ob's impact on Oa is excluded.
    Also define the timestamp of the virtual operation.
    """
    
    if Check_RA(Oa):
        Ooa = Oa
    elif T(Oa) == "Insert" and T(Ob) == "Insert":
        Ooa = ET_II(Oa, Ob)
    elif T(Oa) == "Insert" and T(Ob) == "Delete":
        Ooa = ET_ID(Oa, Ob)
    elif T(Oa) == "Delete" and T(Ob) == "Insert":
        Ooa = ET_DI(Oa, Ob)
    else: # if T(Oa) == "Delete" and T(Ob) == "Delete":
        Ooa = ET_DD(Oa, Ob)
        
    
    Ooa["source_site"] = Oa["source_site"]
    Ooa["timestamp"]   = list(Oa["timestamp"]) # copy
    
    if dbg&gt;=2:		
        print "ET(\n\t%s, \n\t%s\n)\t\t=&gt; %s;"%(Oa, Ob,Ooa) # just for debugging
    
    return Ooa

def ET_II(Oa, Ob):

    if P(Oa) &lt;= P(Ob) :
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Insert",  S(Oa), P(Oa) - L(Ob) )
    else:
        Ooa = Op( "Insert",  S(Oa), P(Oa) - P(Ob) )
        Save_RA(Ooa, Ob)
        
    return Ooa

def ET_ID(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Oa) &lt;= P(Ob):
        Ooa= Oa
    else:
        Ooa= Op( "Insert", S(Oa), P(Oa) + L(Ob) )

    return Ooa
    
    
def ET_DI(Oa, Ob):

    if(P(Oa) + L(Oa)) &lt;= P(Ob):
        Ooa = Oa
    elif P(Oa) &gt;= (P(Ob) + L(Ob)):
        Ooa = Op( "Delete", L(Oa), P(Oa) - L(Ob) )
    else:
        if P(Ob) &lt;= P(Oa) and (P(Oa) + L(Oa))  &lt;= (P(Ob) + L(Ob)):
            Ooa = Op( "Delete", L(Oa), P(Oa) - P(Ob) )
        elif P(Ob) &lt;= P(Oa) and ((P(Oa) + L(Oa)) &gt; (P(Ob) + L(Ob))):
            Ooa = Splitted ( Op( "Delete",  P(Ob) + L(Ob) - P(Oa)         ,(P(Oa) - P(Ob)) ),
                                         Op( "Delete", (P(Oa) + L(Oa))-(P(Ob) + L(Ob)), P(Ob)          ) )
        elif P(Oa) &lt; P(Ob) and ((P(Ob) + L(Ob)) &lt;= (P(Oa) + L(Oa))):
            Ooa = Splitted( Op( "Delete", L(Ob)        , 0     ), 
                            Op( "Delete", L(Oa) - L(Ob), P(Oa) ) )
        else:
            Ooa = Splitted( Op( "Delete", P(Oa) + L(Oa) - P(Ob), 0     ), 
                            Op( "Delete", P(Ob) - P(Oa)        , P(Oa) ) )
        
        Save_RA(Ooa, Ob) # this is in the first 'else' # this is a guess
            
    return Ooa



def ET_DD(Oa, Ob):

    if Check_LI(Oa, Ob):
        Ooa = Recover_LI(Oa)
    elif P(Ob) &gt;= (P(Oa) + L(Oa)):
        Ooa = Oa
    elif P(Oa) &gt;= P(Ob) :
        Ooa = Op( "Delete", L(Oa), P(Oa) + L(Ob))
    else :
        Ooa = Splitted( Op( "Delete", P(Ob) - P(Oa)         , P(Oa)         ),
                        Op( "Delete", L(Oa) -(P(Ob) - P(Oa)), P(Ob) + L(Ob) ) )
    return Ooa

</t>
<t tx="rodrigob.121403173614.342">class Operation(dict):
    """
    simple object that encapsulate the information and methods related to the operations.
    it is a dictionary with extra methods.
    """
    
    def __init__(self, type=None, pos=None, data=None, timestamp=None, source_site=None, **kws):
        
        d = self
        
        d["type"] = str(type)
        d["pos"]  = pos
        d["data"] = data # text or len
            
        d["timestamp"]   = timestamp
        d["source_site"] = source_site
        
        for k in kws.keys():
            d[k] = kws[k]
                    
        return

    def __eq__(self, other): 
        """
        The papers do not explain how to manage the TimeStamp of the operations during transforms and do not explain which operations are considered to be equivalents.
        Studying in detail the sequence of transformations that the example generate:
            LIT(ET(O4, ET(EO2, EO1)), [EO1, EO2])
        I deduce that the first approach of using Operations class instances is wrong. Doing that Transformation mutate the operators passed is wrong too.
        If during transform the timestamp are preserved then timestamp and source_site are the unique identifiers of a operation. Then IT(EO, EOx) == ET(EO, EOx) == EO; this is not intuitive but it works.
        ----
        x==y calls x.__eq__(y)
        """
        
        assert isinstance(other, Operation), "Only operations instances can be compared"
        
        return (self["source_site"] == other["source_site"]) and (self["timestamp"] == other["timestamp"])

    def __repr__(self):
        """
        """
        return "%s"%(self)
        
    def __str__(self):
        """
        """
        
        t_keys = filter(lambda x: x not in ["type", "pos", "data", "source_site", "timestamp"], self.keys())
        
        t_string = ""
        
        if self.has_key("source_site") and self.get("timestamp") :
            t_string += "from S%s%s "%(self["source_site"], self["timestamp"])
            
        if type(self["data"]) in types.StringTypes:
            t_data = "'%s'"%(self["data"])
        else:
            t_data = self["data"]
            
        t_string += "%s@%s:%s"%(self["type"], self["pos"], t_data)
         
        for k in t_keys:
                t_string += ", %s:'%s'"%(k, self[k])
            
        return "{%s}"%t_string
        
    def set_timestamp(self, t_SV):
        """
        Save a state vector as the timestamp.
        """
        
        self["timestamp"] = t_SV
        return
        
    def get_timestamp(self):
        """
        return the state vector used as the timestamp.
        """
        return self.get("timestamp")
    
        
# end of class Operation

@
Dummy function to shortcut the code.
@c

def Op(type, data, pos): # this one has a diferent parameters order
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)
    
def op(type, pos, data):
    """
    Return an instance of the Operation Object.
    """
    return Operation(type, pos, data)


@
Simple function used in the algorithm (enhance readability and paper notation matching)
@c

def T(O):
    """
    Return the type of operation ("Insert" or "Delete")
    """
    return O["type"]
        
    
def P(O):
    """
    Return the position where the operation is executed.
    """
    return O["pos"]


def L(O):
    """
    Return length of the deletion operation.
    For safness if the operation is no a deletion it return the length of the inserted text. (stricly it should raise an error...)
    """
    
    data = O["data"] # speed-up
    assert data != None, "Operation has no data! (%s in %s)"%(data, O)
    
    if type(data) == types.IntType:
        return data
    else:
        return len(data)


def S(O):
    """
    Return the string that the insert operation is trying to insert.
    """
    
    assert type(O["data"]) in types.StringTypes, "S(O) is only valid for Insertion operation."
        
    return O["data"]
    
</t>
<t tx="rodrigob.121403173614.343">
def Splitted(O1, O2):
    """
    Return an operation that is splitted. (this should considered in function 'execute' and 'undo')
    """
    
    assert T(O1) == T(O2), "Splitted operations are of different types, this is not sane."
    assert not (O1.get("is_splitted") or O1.get("is_splitted") ), "Recursive splitted operation not yet supported" 
        
    Oo = Operation(T(O1))
    Oo["is_splitted"] = 1
    Oo["splitted_head"] = O1
    Oo["splitted_tail"] = O2
    
    
    if P(O1) &lt; P(O2):
        Oo["pos"] =  P(O1)
        Oo["data"] =  ( P(O2) + L(O2) ) - P(O1)
    elif P(O1) &gt; P(O2):
        Oo["pos"] = P(O2)
        Oo["data"] = ( P(O1) + L(O1) ) - P(O2)
    else:
        raise "Weird split P(O1) == P(O2) (%s,%s)"%(O1, O2)
        
    return Oo



</t>
<t tx="rodrigob.121403173614.344">@
LI refers to "Lost Information".
@c
        
    
def Check_LI(Oa, Ob):
    """
    Ob was involved in a information lossing operation that afected Oa ?
    """
    
    return 	Oaa.get("LI_reference_op") == Ob
    
    
def Save_LI(Oaa, Oa, Ob):
    """
    Store in Oaa the information related to the paremeters of Oa and the reference to Ob.
    
    One operation can only store one and only one information lose.
    """
    
    copy_Oa = op(Oa["type"], Oa["pos"], Oa["data"] )
    
    Oaa["lost_information"]     = copy_Oa
    Oaa["LI_reference_op"]      = Ob
    
    return


def Recover_LI(Oa):
    """
    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DID NOT FOUND SPECIFICATION (this could cause horrible errors)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    """
    
    return 	Oa["lost_information"]
</t>
<t tx="rodrigob.121403173614.345">    
def Check_RA(Oa):
    """
    Is Oa relatively addressed ?
    """
    
    return Oa.has_key("relatively_addressed") and Oa["relatively_addressed"]
    
    
def Save_RA(Oa, Ob):
    """
    Stores the information to mark Oa as having a relative address to over Ob.
    """
    
    #print "called Save_RA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oa["relatively_addressed"] = 1
    Oa["base_operation"] = Ob
    Oa["delta_pos"] = P(Oa) - P(Ob) # Abis = P(Obbis) + A.delta_pos
    
    return
    
def Check_BO(Oa, Ob):
    """
    Ob is the base operation of Oa ? (in the relative address context)
    """
    
    #Ox = Oa.get("base_operation")
    #return (Ox["source_site"] == Ob["source_site"]) and (Ox["timestamp"] == Ob["timestamp"])
    
    return Ob == Oa.get("base_operation") # look at the definition of __eq__ in the Operation class
    

def Convert_AA(Oa, Ob):
    """
    Obtain Oaa, which is an absolute address operation based on Oa, over the relative position of Ob.
    """
    
    assert Check_BO(Oa,Ob), "Convert_AA: Ob is not the base_operation of Oa"
    
    #print "called Convert_AA(%s, %s)"%(Oa, Ob) # just for debugging
    
    Oaa = op( Oa["type"],	Oa["delta_pos"] + Ob["pos"], Oa["data"] )
    
    return Oaa

</t>
<t tx="rodrigob.121403173614.346">@
I had a first attemp to create a virtual Server-Client only comunication between different clients. But this approach seems to have failed.
So now I'm going to implement a less optimal system, but hundred of times easier.
The idea is very easy.
The clients then the operations to the client and the server send them to all the other clients.
The server is an Observer, applying locally the operations but never generating one.

With this approach the client addition process is slower and a little more complicated. Also the operations packet grow a little as there are more clients connected to a node.
The advantage is that this systems still reducing the bandwith usage of each client and it do not add any special logic to the base case.
@c
</t>
<t tx="rodrigob.121403173614.347">class ConcurrentEditableServer(ConcurrentEditable):
    """
    Simple Observer and operations repeater.
    It manage all the conection/disconnection syncronization problems.
    """
    
    def __init__(self,):
        """
        """
        # init the internal ConcurrentEditable
        
        ConcurrentEditable.__init__(self, None, 0) # (self, site_index, num_of_sites)
        
        self.connected_sites = {} # the mapping between the connected sites and they site_index
        self.indexed_sites   = {} # the reverse map of connected_sites
        
        self.base_text = ""
        return
        
        
    def generate_operation(self, type, pos, data, **kws):
        """
        Explicit censure.
        """
        raise "The server is an observer it should never generate an operation.0"
        return
    
    
    @others
    
</t>
<t tx="rodrigob.121403173614.348">def add_client(self, client_perspective):
    """
    Register the client to the clients list. 
    Assign a client index. 
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).
    Return the tuple (site_index, num_of_sites)
    """

    if dbg&gt;=1:
        print "Adding client to server."
        print "Server HB %s"%self.HB

            
    # register the client
    if client_perspective in 	self.connected_sites.keys():
        raise "Client already connected, addition rejected."
        return
    
    # assign a site index
    site_index = None
    for i in range(len(self.state_vector)):
        if self.indexed_sites[i] == None:
            site_index = i
            break
        
    if site_index == None: # could not found an aviable slot
        site_index = len(self.state_vector) # a new entry at the end of the list
        
    # register the site
    self.connected_sites[client_perspective] = site_index 
    self.indexed_sites[site_index] = client_perspective
    

    if site_index == len(self.state_vector): # expand the references only if required.
    
        # expand the vectors and matrices
        extra = [0]
        self.state_vector.extend(extra)
        
        for t_vector in self.state_vector_table:
            if t_vector != self.state_vector:
                t_vector.extend(extra)
            
        self.state_vector_table.append([0]*len(self.state_vector))
        self.minimum_state_vector.extend(extra)
    
        #print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
        #print "Server HB %s" % self.HB # just for debugging
        
        assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)
    
        # expand the operations timestamp in the HB
        for t_op in self.HB:
            t_op["timestamp"].extend(extra)
            
            if t_op.get("base_operation"): # RA: relative address
                t_op["base_operation"]["timestamp"].extend(extra)
                
            if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
                t_op["splitted_head"]["timestamp"].extend(extra)			
                t_op["splitted_tail"]["timestamp"].extend(extra)			
                
            if t_op.get("lost_information"): # LI: lost information
                t_op["lost_information"].get("timestamp", []).extend(extra)
                t_op["LI_reference_op" ].get("timestamp", []).extend(extra)
        
    # end of references expantions -----------
    
    # put up to date the state of the new client
    self.send_text(site_index, self.base_text) 
    
    i = 0
    for t_Op in self.HB: # send the operations in the HB
        i+=1
        t_op = Operation(**t_Op) # copy
        self.send_operation(site_index, t_op) # send it	# compose the history buffer
        
        
    if dbg&gt;=1:
        print "Now we have %s clients connected."%(len(self.connected_sites))
        print "Server HB %s"%self.HB
        print
            
    return (site_index, len(self.state_vector))
    

        
def del_client(self, client_perspective):
    """
    The inverse of add_client.
    """
    
    # delete the client
    i = self.connected_sites[client_perspective]
    
    self.indexed_sites[i] = None # mark for future reuses
    del self.connected_sites[client_perspective]
                    
    if len(self.indexed_sites) == 0: # there are no more clients connected
        # clean up the node
        self.HB = []
        self.base_text = self.get_text()
        #&gt;&gt;&gt;&gt;&gt;&gt;&gt;ADD CODE HERE (what is missing?)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        
    return
</t>
<t tx="rodrigob.121403173614.349">
def receive_operation(self, in_op, *args, **kw):
    """
    adapt the state_vectors lengths
    """

    timestamp = (isinstance(in_op, Operation) and in_op.get("timestamp") ) or kw.get("timestamp")
    
    # if the client is unaware of the new client, it is because if has not received a message from it
    timestamp = timestamp + [0]*(len(self.state_vector) - len(timestamp)) # extend with zeros
    
    if isinstance(in_op, Operation):
        in_op["timestamp"] = timestamp
    else:
        kw["timestamp"] = timestamp

    ConcurrentEditable.receive_operation(self, in_op, *args, **kw) # receive the operation
            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.350">def apply(self, Onew):
    """
    Send to all the other users and Apply locally .
    """
    
    # first send to other users to enhance responsiveness
    for t_index in range(len(self.state_vector)):
        if t_index == Onew["source_site"]: continue # do not send back to the emisor	
        self.send_operation(t_index, Onew) # send it

    
    ConcurrentEditable.apply(self, Onew) # apply localy
    
    return 



</t>
<t tx="rodrigob.121403173614.351">def compute_base_text(self):
    """
    The base text is the text underlying the operations in the history buffer. Could be created from the operation cleaned by the garbage collector or is text that persisted from other sessions.
    """
    for t_op in reverse(self.HB):
        self.undo(t_op)
    
    base_text = self.get_text() # base text is the text created by the erased operations (erased by the garbage collector or when the node was alone)
    
    for t_op in self.HB:
        self.redo(t_op)
    
    return</t>
<t tx="rodrigob.121403173614.352">@
This method have to be overwritten for network transfers support.
@c
</t>
<t tx="rodrigob.121403173614.353">
def send_operation(self, site_index, t_op):
    """
    This function is called by apply.
    This method should be overwritten for real network transmision. 
    Test implementation is presented here.
    I repeat, This method should be overwritten to send the object over the network.
    """
    
    if 1:
        if dbg&gt;=1: print "send_op; sending to S%s %s"%(site_index, t_op)
        global sent_test_operations
        sent_test_operations.append(t_op)
        
    return
</t>
<t tx="rodrigob.121403173614.354">def send_text(self, site_index, new_text):
    """
    This method should be overwritten for a networked implementation.
    Here only code for testing.
    I repeat, This method should be overwritten to send the object over the network.
    """
    
    if 1:
        if dbg&gt;=1: print "send_text; setting S%s base text as '%s'"%(site_index, new_text)
        # dummy no delay implementation, obviously should be overwritten for real network transmisions.
        self.indexed_sites[site_index].set_text(new_text) 
    
    return</t>
<t tx="rodrigob.121403173614.355">class ConcurrentEditableClient(ConcurrentEditable):
    """
    Just a normal ConcurrentEditable but with a special garbage collector, because the Server can send operations from the past (normal client are suposed to do not do that). So the Client garbage collector is triggered by the Server.
    """
    
    def __init__(self, server_perspective=None):
        """
        """
        if server_perspective:
            self.connect_to_server(server_perspective)
            
        return
        
    @others
</t>
<t tx="rodrigob.121403173614.356">def connect_to_server(self, server_reference):
    """
    Connect to the server.
    Dummy implementation for testing purpose. This method should be overwritten to manage network methods.
    """
    
    site_index, num_of_sites = server_reference.add_client(self)
    
    # init the internal ConcurrentEditable		
    ConcurrentEditable.__init__(self, site_index, num_of_sites) # site_index, num_of_sites # the clients has site_index 1, thus state_vector == [server, client]
        
    return
</t>
<t tx="rodrigob.121403173614.357">def add_a_client(self):
    """
    Add one client more
    """
    self.set_num_of_clients(len(self.state_vector)+1)
    return


def set_num_of_clients(self, num_of_clients):
    """
    Adapt the local vector to the num of clients
    
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).
    """

    assert (num_of_clients - len(self.state_vector)) &gt;= 0
    
    extra = [0]*(num_of_clients - len(self.state_vector))
    
    if not extra: # nothing to add
        return 
        
    # expand the vectors and matrices
    self.state_vector.extend(extra)
    
    for t_vector in self.state_vector_table:
        if t_vector != self.state_vector:
            t_vector.extend(extra)
        
    self.state_vector_table.append([0]*len(self.state_vector))
    self.minimum_state_vector.extend(extra)

    #print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
    #print "Server HB %s" % self.HB # just for debugging
    
    assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)

    # expand the operations timestamp in the HB
    for t_op in self.HB:
        t_op["timestamp"].extend(extra)
        
        if t_op.get("base_operation"): # RA: relative address
            t_op["base_operation"]["timestamp"].extend(extra)
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
            t_op["splitted_head"]["timestamp"].extend(extra)			
            t_op["splitted_tail"]["timestamp"].extend(extra)			
            
        if t_op.get("lost_information"): # LI: lost information
            t_op["lost_information"].get("timestamp", []).extend(extra)
            t_op["LI_reference_op" ].get("timestamp", []).extend(extra)
    

    if dbg&gt;=1:
        print "S%s; len(self.state_vector) == %s"%(self.site_index, len(self.state_vector))
    return
    

        
def del_client(self, client_index):
    """
    Eliminate the reference in the state_vectors of one specific client that has disconnected.
    """
    
    i = client_index
    
    # update the site_index mapping ----
        
    # shrink the vectors and matrices
    shrink = lambda x: hasattr(x, "__delslice__") and x.__delslice__(i, i+1) # delete the 'i'th item
    
    shrink(self.state_vector)
    
    for t_vector in self.state_vector_table:
        shrink(t_vector)
        
    shrink(self.state_vector_table)
    shrink(self.minimum_state_vector)

    # shrink the operations timestamp in the HB
    for t_op in self.HB:
        shrink(t_op["timestamp"])
        
        if t_op.get("base_operation"): # RA: relative address
            shrink(t_op["base_operation"]["timestamp"])
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail"): # Splitted
            shrink(t_op["splitted_head"]["timestamp"])			
            shrink(t_op["splitted_tail"]["timestamp"])			
            
        if t_op.get("lost_information"): # LI: lost information
            try:
                shrink(t_op["lost_information"].get("timestamp"))
            except:
                pass
            try:
                shrink(t_op["LI_reference_op" ].get("timestamp"))
            except:
                pass
                
    
    return
        



</t>
<t tx="rodrigob.121403173614.358">
def receive_operation(self, in_op, *args, **kw):
    """
    check if the operation timestamp correspond to the local num_of_sites
    """

    timestamp = (isinstance(in_op, Operation) and in_op.get("timestamp") ) or kw.get("timestamp")
    
    if len(timestamp) &gt; len(self.state_vector):
        self.set_num_of_clients(len(timestamp)) # adapt the length of the state vectors
    elif len(timestamp) &lt; len(self.state_vector):
        timestamp = (isinstance(in_op, Operation) and in_op.get("timestamp") ) or kw.get("timestamp")

        # if the client is unaware of the new client, it is because if has not received a message from it
        timestamp = timestamp + [0]*(len(self.state_vector) - len(timestamp)) # extend with zeros

        if isinstance(in_op, Operation):
            in_op["timestamp"] = timestamp
        else:
            kw["timestamp"] = timestamp
            
    # end of elif --------------

    for t_op in self.HB:
        if t_op["timestamp"] == timestamp:
            print "&lt;strange&gt; Strange network conditions have created a twin message reception. Will be omited. (twin: %s, recieved: %s)"%(t_op, str((in_op, args, kw)))
            return

    ConcurrentEditable.receive_operation(self, in_op, *args, **kw) # receive the operation
            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.359">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    # create and apply
    t_op = ConcurrentEditable.generate_operation(self, type, pos, data, **kws)

    # overwrite source_site to give a reference (instead of a dummy number)
    ret_op = Operation(**t_op) # copy the operation
    
    return ret_op</t>
<t tx="rodrigob.121403173614.360">def set_text(self, new_text):
    """
    Blindly overwrite the text of this site.
    """
    
    self.text_buffer = new_text
    
    return</t>
<t tx="rodrigob.121403173614.361">@
The unit tests for concurrent editions.
@c


def Tests():
    """
    run the tests
    """
    
    global dbg
    dbg = 0
    
    if 0: # hand made unittest 
        print "Starting tests"
        TestConcurrentEditable1()
        print "-"	* 30
        TestConcurrentEditable2()
        print "-"	* 30	
        TestConcurrentEditableServer()
        print "end of tests"
        return



    import unittest
    

    TestSuite = unittest.TestSuite()
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable1))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable2))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditableServer))
    
    unittest.TextTestRunner().run(TestSuite)
    
    return</t>
<t tx="rodrigob.121403173614.362">
def TestConcurrentEditable1():
    """
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Delete 1 2
        - O4 Insert 2 "c"
    So the final result should be "ABCcD" in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable1 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test the alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4") 
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    

    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.363">
def TestConcurrentEditable2():
    """
    Second test is similar to Test1 but with other operations. Try to test other code areas (i.e. Lost Information cases)
    
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Insert 5 "c"
        - O4 Delete 0 3
    So the final result should be ABCc in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable2 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;HB %s"%(t_site.site_index, t_site.state_vector, t_site.HB)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCc" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCc', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.364">
def TestConcurrentEditableServer():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a Star network; with one central server and three clients connecting to it.
    """
    
    global dbg
    dbg = 0 #1 # ;P
    
    # when dbg==1 this is a __very__ verbose test, but it allow a good tracking of every event.
    
    print "-"*15
    print "Read docstring of TestConcurrentEditableServer for more info about this test.\n"
    
    # creates server
    server = ConcurrentEditableServer()
    
    # connect site 0 and 1
    site0 = ConcurrentEditableClient(server)
    site1 = ConcurrentEditableClient(server)
    
    
    global sent_test_operations; 	sent_test_operations = [] # used for delaying the transmissions in the test
    
    # start editions
    # Apply the operations in each site (following the order of the picture)
    O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1", gen_site="0") # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2", gen_site="1") # test the alias

    # O*_toS* is an operation that was sent by the server to the client. This object is delayed to simulate delays in the transmissions lines.
    # the order of reception of commands is similar of the TestConcurrentEditable1
    server.receive_op(O2); 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O2_toS0] = sent_test_operations; sent_test_operations = []	
    server.receive_op(O1);
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O1_toS1] = sent_test_operations; sent_test_operations = []	
    
    # connect site 2 (to test connection during sessions)
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    
    if dbg&gt;=1:
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    O1_toS2, O2_toS2 =  sent_test_operations	
    site2.receive_op(O2_toS2)
    sent_test_operations = []
    
    if dbg&gt;=1:
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
        
    # continue editions
    site1.receive_op(O1_toS1) # receive delayed operations sent by the server
    site0.receive_op(O2_toS0)
    O4 = site2.gen_op("Insert", 2, "c", dbg_name="O4", gen_site="2") 
    server.receive_op(O4); O4_toS0, O4_toS1 = sent_test_operations; 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    sent_test_operations = []	

    
    # test disconnection and site_index reusage (for reconnetion connection)
    if dbg&gt;=1: 
        print "\nDisconnectiong S2"
        
    server.del_client(site2)	
    if dbg&gt;=1: print "\nReconnection S2"
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    for t_op in sent_test_operations:
        site2.receive_op(t_op)
    sent_test_operations = []	
    if dbg&gt;=1: 
        print "Site2 after reconnecting"
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    site0.receive_op(O4_toS0)
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3", gen_site="1")
    server.receive_op(O3);	
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    O3_toS0, O3_toS2 = sent_test_operations; sent_test_operations = []	
    site2.receive_op(O3_toS2)
    site0.receive_op(O3_toS0)
    site1.receive_op(O4_toS1)
    site2.receive_op(O1_toS2)

    
    # Original sequence------------------
    #O1 = site0.gen_op("Insert", 0, "ABC", dbg_name="O1")  # generate and apply locally the operation
    #O2 = site1.gen_Op("Insert", "BCD", 0, dbg_name="O2") # test alias
    #site2.receive_op(O2)
    #site1.receive_op(O1)
    #site0.receive_op(O2)
    #O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    #site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    #O3 = site1.gen_op("Insert", 5, "c", dbg_name="O4")
    #site2.receive_op(O3)
    #site0.receive_op(O3)
    #site1.receive_op(O4)			
    #site2.receive_op(O1)
    # ------------------

    if dbg&gt;=1:	
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
        
    
    if dbg&gt;=1:
        print "\nDirty HBs"
        for t_site in [server, site0, site1, site2]:
            print "Site %s;%s;HB %s; delayed_ops %s"%(t_site.site_index, t_site.state_vector, t_site.HB, t_site.delayed_operations)
        print
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)
        if dbg&gt;=1: print "Manually collecting the garbage in all sites"
        server.collect_garbage()
        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    # --------	
    # disconnect
    if dbg&gt;=1: print "Disconnecting the three sites."
    server.del_client(site0)	
    server.del_client(site1)	
    server.del_client(site2)	
    # --------------
        
    
    if dbg&gt;=1:
        print "\nFinal HBs"
        for t_site in [server, site0, site1, site2]:
            print "Site %s;%s;HB %s; delayed_ops %s"%(t_site.site_index, t_site.state_vector, t_site.HB, t_site.delayed_operations)
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [server, site0, site1, site2]:
        t_res = (t_site.get_text() == "ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success

    return 1
</t>
<t tx="rodrigob.121403173614.365">@
def onBodykey2(tag, keywords):
    """
    Check if send insert conditions are fullfiled and send the data.
    
    Check if a new line was created.
    Send the new line.S
    """
    
    def in_range(text_widget, ranges, index):
        """
        return true if the index is in the range.
        
        """
    
        for i in range(0, len(ranges), 2):
            pass
    

        return
    
    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT THIS CODE should oldSel index instead of the "insert" mark&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT THIS CODE should use oldTagsRanges&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    
    v = keywords["v"]
    
    if v.isOnline():
        
        es("onbodykey2 keywords %s"%(keywords), color="yellow") # just for debugging
        
        c  = keywords["c"]
        ch = keywords["ch"]
        old_sel = keywords["oldSel"] # (first, last)
        undo_type = keywords["undoType"]
        insert_pos = old_sel[0]
        old_tags_ranges = keywords["oldTagsRanges"]	# defined by LeoN
        old_to_send_ranges = old_tags_ranges.get("to_send")
                
        if old_sel and old_sel[0] != old_sel[1]: # text was overwritten	
        
            #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ADD CODE HERE manage the text overwriting &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
            # (should check which overwritten text was already sent)
            # and should create a sequence of deletion operations
            
            es("text was overwritten %s %s"%(old_sel, c.undoer.oldMiddleLines[0] ), color="yellow")
            es("unmanaged case", color="yellow")
            
        elif ch in ['\x7f', '\x08']: # suppretion or deletion 
            # if the operation was applied in a to_send char, we omit it,
            # else we add it to the deletion buffer, that will be latter send over the network.
            
            old_insert = old_sel[0] # old_sel[0] == old_sel[1]
            
            # check if has deleted an unsent char
            prev = c.body.tag_nextrange("to_send", "insert")
            next = c.body.tag_prevrange("to_send", "insert")
            
            
            if next and c.body.compare("insert","&gt;=", next[0]) and c.body.compare("insert","&lt;=", next[1]):
                
                if ch == '\x08': #key, '\x08' # delete		
                    v.client.es("deleted a to_send char")
                elif ch == '\x7f':
                    v.client.es("supressed a to_send char")
                else:
                    v.client.es("Internal error, during deletion or insertion operation management. (OnBodykey2)", color="red")
                    
                return # nothing more to do here
                                    
            # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ADD CODE HERE how to manage the deletion of border characters, how to know his origin?&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
            
            v.client.es("prev %s"%(str(prev)), color="yellow")
            v.client.es("next %s"%(str(next)), color="yellow")
            v.client.es("insert %s"%(c.body.index("insert")), color="yellow")
            
            if 0: # deprecated code
                if ch == '\x08': #key, '\x08' # delete		
                    prev = c.body.tag_nextrange("to_send", "insert")
                    v.client.es("prev %s"%(str(prev)), color="yellow")
                    if prev and c.body.compare("insert - 1 chars","==", prev[0]):
                        v.client.es("deleted a to_send char")
                else: 			     #key, '\x7f' # suppress
                    next = c.body.tag_prevrange("to_send", "insert")
                    v.client.es("next %s"%(str(next)), color="yellow")
                    if next and c.body.compare("insert","==", next[1]):
                        v.client.es("supressed a to_send char")
            # end of deprecation			

            # at his point the deletion was efectued over a non to_send char, and it need to be registered in the deletion buffer.
            
            if v.client.client_node.deletion_buffer: # updating a deletion buffer
                startpos, t_len = v.client.client_node.deletion_buffer
                if ch == '\x08': #key, '\x08' # delete
                    startpos -= 1
                else: 			     #key, '\x7f' # suppress
                    pass	
                
                t_len += 1
                
                v.client.client_node.deletion_buffer = (startpos, t_len)
            
            else: # need to create a new one
            
                startpos = len(c.body.get("1.0", "insert")) 				# transform the insert index to a lineal index
                # startpos do not depend of  '\x08'  delete or '\x7f' # suppress
                t_len = 1
                v.client.client_node.deletion_buffer = (startpos, t_len)
            
            
        elif undo_type == "Typing" and ch: # a 'normal' key was typed
            
            # the flush command is called for every key
            # the flush command check the deletion buffer and flush it as necessary
                                

            for tag in c.body.tag_names(): #clean up any other tag #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT CODE HERE this does not seems to work !&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                if tag not in ["sel", "to_send"]:
                    c.body.tag_remove(tag, insert_pos)		 # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; insert_pos was "insert - 1 chars"
                    
            # mark the actual chars					
            c.body.tag_add("to_send",  insert_pos)		
            
            #v.client.es("%s"%(ch), color="yellow") # just for debugging
            
            
        else: # non text insertion keys (move arrow, page up, etc...)
        
            if ch and len(ch) &gt; 0:
                v.client.es("unmanaged key",`ch`, color="yellow")
                
            v.client.es("unmanaged key of type %s"%(undo_type), color="yellow")
            
            pass
                
            
    return
    
@c</t>
<t tx="rodrigob.121403173614.366">import ConcurrentEditable

class ClientNode(ConcurrentEditable.ConcurrentEditableClient):
    """
    The client side of the selected node.
    This is a dynamic component.
    
    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Add explain HERE&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    """
    
    def __init__(self, LeoClient):
        """
        """
        # local ConcurrentEditable will be initialized during connection process.
        
        # initialize the extra attributes		
        self.leo_client  = LeoClient # stores a reference to the leo client.
        for t_name in ["name", "es", "perspective", "exception"]: # inherit some attributes
            setattr(self, t_name, getattr(self.leo_client, t_name))
        
        self.text_widget = top().frame.body
        
        
        #self.text_widget.delete("1.0", END) # clean up the body # no, should not be done (to preserve the text under the eyes, and to preserve the index mark position)
    
        self.deletion_buffer = () # helper variable store a cumulative erasure (successive delete or insert commands) in the tuple (startpos, len)
        self.last_node_dirty_text = [] # helper variable, that fill_node user when the selection has changed. Will be deprecated in step4.
        
        
        return
    
    
    @others




</t>
<t tx="rodrigob.121403173614.367">def connect_to_server(self, server_perspective):
    """
    Connect to the server.
    """
    
    self.server_perspective = server_perspective
    deferred = self.server_perspective.callRemote("collaborate_in")
    deferred.addCallback(self.connected)
    deferred.addErrback(self.leo_client.exception)
                            
    return


def connected(self, ret_tuple):
    """
    Callback for the connection procedure.
    """
    insert_index = self.text_widget.index("insert")
    
    site_index, num_of_sites, base_text, ops_list = ret_tuple
        
    # init the internal ConcurrentEditable		
    ConcurrentEditable.ConcurrentEditable.__init__(self, site_index, num_of_sites) # site_index, num_of_sites # the clients has site_index 1, thus state_vector == [server, client]


    self.set_text(base_text)
    
    for t_dict in ops_list: #ops_list is a list of dictionaries that define a list of operations
        self.receive_operation(ConcurrentEditable.Operation(**t_dict))	# instanciate and receive
    
    es("Setting the index mark back to his initial location: %s"% (insert_index),color="yellow")
    
    self.text_widget.mark_set("insert", insert_index) # try to keep the insert mark at the same place
    
    self.leo_client.es("Connected to %s as S%s (num_of_sites %s)"%(self.server_perspective, site_index, num_of_sites))	
    return
    

def disconnect_from_server(self):
    """
    Disconnect from the server.
    """

    deferred = self.server_perspective.callRemote("collaborate_out")
    deferred.addCallback(self.disconnected)
    deferred.addErrback(self.leo_client.exception)
    
    return

def disconnected(self, *args):
    """
    """
    
    # what should I do here ?, do I need to do something ?
    self.leo_client.es("Disconnected from the old node.",color="gray") # just to do something
    
    return

</t>
<t tx="rodrigob.121403173614.368">def set_cursor_position(self, who, pos):
    """ 
    Define the new position of someone cursor, so the local user can suspect future editions of the camarades. Used as a visual feedback of other user actions.
    """
    
    raise "Not yet implemented."
    
    return

def set_text(self, new_text):
    """
    Blindly overwrite the text of this site. (including the "to_send" elements)
    Keeps the index mark in the original place.
    """
    
    self.es( "Calling set_text '%s'"%(new_text), color="yellow" ) # for debugging
    
    # clean up the body
    self.text_widget.delete("1.0", END)
    
    # insert the new text
    self.insert_text(0, new_text, op={"source_site":self.site_index})
    
    return

</t>
<t tx="rodrigob.121403173614.369">
        
def insert_text(self, startpos, text, op={}):
    """ 
    Some one insert text on the actual node.
    Should insert text only counting non "to_send" locations.
    """
    
    text_widget = self.text_widget
        
    t_startpos = startpos

    # convert the insertion point, considering the "to_send" elements
    ranges = text_widget.tag_ranges("to_send") # ranges are text indexes
    
    for i in range(0, len(ranges), 2):
        # convert text indexes to numerical values
        start =          len(text_widget.get("1.0",     ranges[i]  ))
        stop  =  start + len(text_widget.get(ranges[i], ranges[i+1]))
        
        if start &lt; startpos:
            startpos += stop - start # make the startpos include the unsent local text.
        if start &gt;= startpos:
            break
        # else: continue

    startpos = "1.0 + %i chars"%(startpos)
                
    self.es("Insert text: input starpos %s, real startpos %s. to_send ranges %s"%(t_startpos, startpos, ranges), color="yellow")
    
    # now startpos is a "line.column" index that consider the correct location
            
            
    if op["source_site"] == self.site_index: # if it is a confirmation
        who = None
    else:
        who = op.get("who")
    
    if who and who != self.name:
            
        # check if the who tag exists
        if who not in text_widget.tag_names(): # this is slowww &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; (how to do it fast?)
            # find a new color (fixed saturation and value. tint is random)(this ensure us to have only 'pleasant' background colors)						
            r,b,g = map(lambda x: int(x*255), colorsys.hsv_to_rgb( random.Random().random(), 
                                                                    0.30 , # thee important value (0 white, 1.0 intense color)
                                                                    1.0
                                                                  ))			
            t_color = "#%02x%02x%02x"%(r,g,b)
            
            text_widget.tag_config(who, background = t_color)
            text_widget.tag_bind(who, "&lt;Button-1&gt;", lambda event: self.es("Text inserted by %s"%(who), color=t_color))
        # end of new tag
        
        text_widget.insert(startpos, text, who)
        
    else: # no 'who', just insert the text
    
        text_widget.insert(startpos, text)
    
    self.es( "%s insert at %s the content '%s'"%(who, startpos, text), color="yellow" ) # for debugging
    
    return
</t>
<t tx="rodrigob.121403173614.370">
def delete_text(self, startpos, length, op={}):
    """ 
    Some one delete text on the actual node.
    Should delete text in  non "to_send" locations.
    """

    if op["source_site"] == self.site_index:
        self.es( "AutoDeletion is avoiyed", color="yellow") # for debugging
        return

    text_widget = self.text_widget
    
    # convert the starting and end points, considering the "to_send" elements
    ranges = text_widget.tag_ranges("to_send") # return a list of index tuples
    
    for i in range(0, len(ranges), 2):
        # convert text indexes to numerical values
        start =          len(text_widget.get("1.0",     ranges[i]  ))
        stop  =  start + len(text_widget.get(ranges[i], ranges[i+1]))
        
        if start &lt; startpos:
            startpos += (stop - start) # make the startpos include the unsent local text.
            
        if start &gt;= startpos:
            ranges = ranges[i:] # store the rest (including actual pos)
            break
        # else: continue
        
                    
    self.es( "Deleting text at %s len %s"%(startpos, length), color="yellow" ) # for debugging
    
    # delete the text avoiying the "to_send" elements. 
    deleted_text = ""
    offset = 0
    for i in range(0, len(ranges), 2): #ranges contain the indexes of the rest of the "to_send" elements
        # convert text indexes to numerical values
        range_start =                len(text_widget.get("1.0", "%s - %i chars"%(ranges[i], offset)  ))
        range_stop  =  range_start + len(text_widget.get( "%s - %i chars"%(ranges[i], offset), "%s - %i chars"%(ranges[i+1], offset))) 
        
        if startpos + length &gt;= range_start: # there is an overlapping
                        
            t_start = "1.0 + %i chars"%(startpos)
            t_stop  = "1.0 + %i chars"%(range_start)

            deleted_text += text_widget.get(t_start, t_stop)  # necessary for algorithm internal undo/redo	operations
            text_widget.delete(t_start, t_stop)
            
            length  -= range_start - startpos
            offset  += range_start - startpos
            startpos = range_stop - (range_start - startpos) # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; this line is wrong
            # continue
            self.es( "continuing deletion at %s len %s"%(startpos, length), color="yellow" ) # for debugging
        else:
            break
        # end of for

    # the last one is direct (or the only one if no ranges==[])
    if length &gt; 0:
        t_start = "1.0 + %i chars"%(startpos)
        t_stop  = "1.0 + %i chars"%(startpos + length)

        deleted_text += text_widget.get(t_start, t_stop)  # necessary for algorithm internal undo/redo	operations
        text_widget.delete(t_start, t_stop)
    #end of last deletion
    
    
    op["deleted_text"] = deleted_text  # necessary for algorithm internal undo/redo	operations

    return
    

</t>
<t tx="rodrigob.121403173614.371">def fill_body(self, keywords):
    """
    Process each new key received in the body.
    Attached to OnBodyKey2. All params are passed as a keyword.
    Manage insertions, deletions, suppresions, range text overwrite and paste operations.
    """
    
    # &lt;&lt;&lt;&lt;&lt;&lt;&lt; flush_body should be at the start or at the end ?	
    self.flush_body(keywords) # send the unsent data and clean up what is necesarry.
            
    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT HERE, should manage the undo_type == Paste case also&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    
    v.client.es("onbodykey2 keywords %s"%(keywords), color="yellow") # just for debugging
    #trace("onbodykey2 keywords %s"%(keywords)) # just for debugging
    
    c  = keywords["c"]		
    ch = keywords["ch"]
    old_sel    = keywords["oldSel"] # (first, last)
    undo_type  = keywords["undoType"]
    old_insert = old_sel[0]
    old_tags_ranges    = keywords["oldTagsRanges"]	# defined by LeoN
    old_to_send_ranges = old_tags_ranges.get("to_send")
            
    
    &lt;&lt; def index_to_list and in_range&gt;&gt;		
    
    if old_sel and old_sel[0] != old_sel[1]: # text was overwritten	
        &lt;&lt; text was overwritten &gt;&gt;

    elif ch in ['\x7f', '\x08']: 
        &lt;&lt; suppression or deletion &gt;&gt;

    elif undo_type == "Typing" and ch: 
        &lt;&lt; "normal" keys&gt;&gt;
        
    else: 
        # non text insertion keys (move arrow, page up, etc...)
        if ch and len(ch) &gt; 0:
            v.client.es("unmanaged key",`ch`, color="yellow")
            
        v.client.es("unmanaged key of type %s"%(undo_type), color="yellow")
        
        pass
                
    
    
    return</t>
<t tx="rodrigob.121403173614.372">def index_to_list(val):
    return map(int, val.split("."))
    
def in_range(ranges, index):
    """
    return true if the index is in the range.
    """
    
    index =  index_to_list(index)
    
    for i in range(0, len(ranges), 2):	
        start  = index_to_list(ranges[i])
        stop   = index_to_list(ranges[i+1])

        if start &lt;= index and index &gt;= stop:
            return 1
        else:
            continue

    return 0 # did not found the index in a range

</t>
<t tx="rodrigob.121403173614.373"># (should check which overwritten text was already sent)
# and should create a sequence of deletion operations

es("text was overwritten %s %s"%(old_sel, c.undoer.oldMiddleLines[0] ), color="yellow")

# need to define the lists:
#	- text_deletion_ranges
#   - to_send_deletion_ranges

# has as input:
#   - old_to_send_ranges
#   - old_sel


# first we prune the to_send_ranges to get only the ranges of interest
text   = c.body
ranges =	old_to_send_ranges
t_ranges = [] # will keep the list of to_send ranges that are embedded in the old_sel range.

for i in range(0, len(ranges), 2):	
    start  = ranges[i]
    stop   = ranges[i+1]	
    # search the initial range
    
    if text.compare(old_sel[0], "&lt;=", stop): # found the initial range
        t_ranges.append(old_sel[0])
        if text.compare(old_sel[1], "&lt;=", stop): # if the all selection fit in the first range
            t_ranges.append(old_sel[1])
            break # finished the job
        else:
            t_ranges.append(stop)
            # search the final range
            
            for i in range(i+2, len(ranges), 2):	
                start  = ranges[i]
                stop   = ranges[i+1]
                if text.compare(old_sel[1], "&lt;=", start):
                    t_ranges.append(stop)
                else:
                    t_ranges.extend()
            

    if text.compare(start, "&lt;=", old_sel[0]) and text.compare(old_sel[0], "&gt;=", stop): # found the initial range
        t_ranges.append(old_sel[0])
        if text.compare(old_sel[1], "&lt;=", stop): # if the all selection fit in the first range
            t_ranges.append(old_sel[1])
            break # finished the job
        else:
            t_ranges.append(stop)
            for i in range(i+2, len(ranges), 2):	
                start  = ranges[i]
                stop   = ranges[i+1]
                if text.compare(old_sel[1], "&lt;=", stop):
                    t_ranges.append(stop)
            
            break # finished the job
            


to_send_deletion_ranges = t_ranges
text_deletion_ranges    = []



es("to_send_deletion_ranges %s, text_deletion_ranges %s"%(to_send_deletion_ranges, text_deletion_ranges), color="yellow")

</t>
<t tx="rodrigob.121403173614.374"># suppression or deletion 
# if the operation was applied in a to_send char, we omit it,
# else we add it to the deletion buffer, that will be latter send over the network.

if ch == '\x7f': #key Suppr, a suppression
    t_index = old_insert
    if in_range(t_index, ranges):
        v.client.es("supressed a to_send char")
        # nothing more to do
        return
    else: 
        # suppressed text
        delta = 0
        
elif ch == '\x08': #key, '\x08' # delete, a deletion
    t_index = old_insert
    if in_range(t_index, ranges):
        v.client.es("deleted a to_send char")
        # nothing more to do
        return
    else: 
        # deleted text
        delta = -1



# at his point the deletion was efectued over a non to_send char, and it need to be registered in the deletion buffer.
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EDIT THIS CODE this code has no sense ! edit it ! &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

if v.client.client_node.deletion_buffer: # updating a deletion buffer
    startpos, t_len = v.client.client_node.deletion_buffer
    startpos += delta				
    t_len += 1
    v.client.client_node.deletion_buffer = (startpos, t_len)

else: # need to create a new one

    startpos = len(c.body.get("1.0", old_insert)) 				# transform the insert index to a lineal index
    # startpos do not depend of  '\x08'  delete or '\x7f' # suppress
    t_len = 1
    v.client.client_node.deletion_buffer = (startpos, t_len)
</t>
<t tx="rodrigob.121403173614.375"># a 'normal' key was typed
# the flush command is called for every key OnBodyKey1
# the flush command check the deletion buffer and flush it as necessary
                    
for tag in c.body.tag_names(): #clean up any other tag
    if tag not in ["sel", "to_send"]:
        c.body.tag_remove(tag, old_insert)
        
# mark the actual chars					
c.body.tag_add("to_send",  old_insert)		

#v.client.es("%s"%(ch), color="yellow") # just for debugging</t>
<t tx="rodrigob.121403173614.376">def flush_body(self, keywords={}, all=0):
    """
    work with "to_send", "to_receive" tags.
    """
    
    undo_type       = keywords.get("undoType")
    ch              = keywords.get("ch")
    old_insert      = keywords.get("oldSel", ["insert"])[0] # (first, last)		
    old_tags_ranges = keywords.get("oldTagsRanges", {}).get("to_send")	# defined by LeoN
    if not old_tags_ranges:
        old_tags_ranges = text_widget.tag_ranges("to_send")
            
    #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT THIS CODE should include a deferred.timeout operation that calls flush(all)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    # flush(all) has to disable a future recall
    # flush without all enable a future recall
    # 
    # def deferred_flush(*args):
    #	if v.isOnline():
    #		how to ensure that I will flush the correct body ? hmm.... problem
    # if v.getattr("deferred_flush_call") and v.deferred_flush_call.active(): 
    #	v.deferred_flush_call.reset(5)
    #else:
    #	v.deferred_flush_call = c = defer.Deferred().setTimeout(5, lambda *args: v.client)
    # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; end of experimental code

    
    if self.deletion_buffer:
        if ((undo_type == "Typing" and ch not in ['\x7f', '\x08']) or all):  # at the end of a chunk deletion
        
            # flush the deletion buffer
            defered = self.send_operation("delete_text", self.deletion_buffer[0], self.deletion_buffer[1])
            
            self.es("deletion_buffer executed with value (%i %i)"%(self.deletion_buffer[0], self.deletion_buffer[1]), color="yellow") # just for debugging
                            
            self.deletion_buffer = ()	
    
        

    # flush the insertions
    text = text_widget
    ranges = old_tags_ranges
    
    for i in range(0, len(ranges), 2):
        
        start  = ranges[i]
        stop   = ranges[i+1]
        t_text = None 

        # self.es("(%s,%s)"%(start, stop), color="yellow") # for debugging
                
        # conditions for text flushing -~-~-~-~-~-~-~-~-~-~
        tt_text = text.get("%s - 2 chars"%(stop), stop)
        
        if tt_text[1] in [' ', '\n'] and tt_text[0] != tt_text[1]: # when the user finish a word and insert a space or an enter.
            t_text = text.get(start, stop)		

        elif (		text.compare(old_insert, "&lt;", "%s - 15  chars"%(start)) 
            or  text.compare(old_insert, "&gt;", "%s + 15  chars"%(stop) ) ): # if we are 15 chars away from a chunk
            t_text = text.get(start, stop)
            
        elif (   text.compare(old_insert,   "&gt;", "%s + 1 lines"%(stop) )
              or text.compare(old_insert,   "&lt;", "%s - 1 lines"%(start)) ) : # if we are 1 lines away from a chunk
            t_text = text.get(start, stop)

        elif (   text.compare(stop,   "&gt;", "%s + 2 lines"%(start) )
              or text.compare(stop,   "&gt;", "%s + 30 chars"%(start)) ) : # if the chunk has more than 2 lines or is bigger than 30 chars.
            t_text = text.get(start, stop)

            
        elif all: # if we have to flush every dirty char
            t_text = text.get(start, stop)
            self.last_node_dirty_text.append(t_text)
            
        # check if the conditions trigered some text flushing  -~-~-~-~-~-~-~-~-~-~

    
        if t_text:
            #self.es(t_text, color="orange") # for debugging
            self.es("(%s,%s)"%(start, stop), color="yellow") # for debugging
            
            # transform the start index to a lineal index
            startpos = len(text.get("1.0", start))
            
            # delete the "to_send" marked text, local aplication will insert it back, unmarked.
            text.delete(start, stop)
            
            # send the data
            self.send_operation("insert_text", startpos, t_text)
            
    return
</t>
<t tx="rodrigob.121403173614.377">def send_operation(self, op_type, pos, data):
    """
    """
    
    if op_type == "insert_text":
        op_type = "Insert"
    elif op_type == "delete_text":
        op_type = "Delete"
    else:
        raise "Unknown op_type '%s'"%op_type
    
    # apply locally
    self.gen_op(op_type, pos, data) 
    
    
    # send to the server
    self.perspective.callRemote("receive_op", op_type, pos, data, self.state_vector ).addErrback(self.exception)
    
    return

</t>
<t tx="rodrigob.121403173614.378"># (should check which overwritten text was already sent)
# and should create a sequence of deletion operations


# need to define the lists:
#	- text_deletion_ranges
#   - to_send_deletion_ranges

# after that we need to advise the text_deleted by "text_deletion_ranges" (if there are sync problems, we can use the "oldText" keyword param to determine more exactly the linear position and the )

# has as input:
#   - old_to_send_ranges
#   - old_sel
#   - old_text

from Tkinter import *
import types

root = Tk()
text   = Text(root)
#text.insert("1.0", "a"*20 + '\n' + "b" * 30) # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; has to test with and without this line &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

#old_text = "Some\nlines\nof text."
#old_sel  = ["1.6", "2.3"]
#old_to_send_ranges = ("1.2","1.8","1.10","2.5")

def index_to_list(val):
    """
    Convert a Tkinter string index to a list of two integer elements [line, column].
    """
    if type(val) in types.StringTypes:
        return map(int, val.split("."))
    else:
        return val
    
def list_to_index(val):
    """
    Convert [line, column] list to a Tkinter index.
    """
    return "%i.%i"%tuple(val)

def range_to_pos_length(start, stop, text):
    """
    Convert a Tkinter range to a length position.
    """
    
    start = index_to_list(start)
    stop  = index_to_list(stop)
    
    if type(text) in types.StringTypes:
        text = text.split("\n")
        
    # Tkinter count the lines from 1 to N and the columns from zero to N
    
    pos    = start[1] + reduce(lambda x,y: len(y) + x, text[:start[0]-1], 0)
    length = stop [1] + reduce(lambda x,y: len(y) + x, text[start[0]-1:stop[0]-1], 0) - start[1]
    
    #print "\nrange_to_pos_length(start=%s, stop=%s, some_text) =&gt; pos, length == %s, %s"%( start, stop, pos, length) # just for debugging
    
    return pos, length
    

def test(old_text, old_sel, old_to_send_ranges):
    print "old_sel", old_sel
    print "old_to_send_ranges", old_to_send_ranges
    
    
    old_sel =	map(index_to_list, old_sel)
    ranges =	old_to_send_ranges
    t_ranges = [] # will keep the list of to_send ranges that are embedded in the old_sel range.
    
    # first we prune the to_send_ranges to get only the ranges of interest
    
    for i in range(0, len(ranges), 2):	
        start  = index_to_list(ranges[i])
        stop   = index_to_list(ranges[i+1])
        # search the initial range
        
        if start &gt;= old_sel[0]: # found the initial range
            break # lets continue with a new logic
        elif  stop &gt;= old_sel[0]:
            t_ranges.append(old_sel[0])
            t_ranges.append(min(stop, old_sel[1]))
            i += 2
            break
        else:
            continue

    for i in range(i, len(ranges), 2):	# starting from last point
        start  = index_to_list(ranges[i])
        stop   = index_to_list(ranges[i+1])	
        
        if start &lt;= old_sel[1]: 
            t_ranges.append(start)
        else:
            break # job finished
            
        if stop &lt;= old_sel[1]:
            t_ranges.append(stop)
        else:
            t_ranges.append(old_sel[1])
            break # job finished
        
    # now we convert the data to lineal ranges and check the valid deletion ranges	
    ranges = to_send_deletion_ranges = t_ranges
    print "to_send_deletion_ranges", to_send_deletion_ranges
    ranges.insert(0, old_sel[0])
    ranges.append(old_sel[1])
    t_ranges = []
    for i in range(0, len(ranges), 2):	
        t_ranges.append( range_to_pos_length(ranges[i], ranges[i+1], old_text) )
    
    ranges   = t_ranges
    t_ranges = []
    t_ranges = filter(lambda x: x[1] &gt; 0, ranges) # if length &gt; 0, keep it
    
    text_deletion_ranges = t_ranges # text_deletion_ranges is a list of (pos, length) tuples that indicates the text areas that where deleted.
    print "text_deletion_ranges", text_deletion_ranges
    print
    return


# run some tests	
old_text = "Ahora estoy escribiendo unas cuanteas frases super largas para poder \nusarlas como pruebas tontas para verificar la calidad de un algoritmo simple que de otra\nforma sería demasiado lento para probear con certeza."


print "old_text:\n", old_text
print

print "old_text lines length", map(len, old_text.split("\n"))
print

old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.2","1.8","1.10","2.5")
test(old_text, old_sel, old_to_send_ranges)


old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.8","1.10")
test(old_text, old_sel, old_to_send_ranges)

old_sel=["1.12", "1.15"]
old_to_send_ranges = ("1.2","1.8", "1.10","2.5", "2.8", "2.20")
test(old_text, old_sel, old_to_send_ranges)



old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.8","1.10", "1.20", "2.15")
test(old_text, old_sel, old_to_send_ranges)

    


</t>
<t tx="rodrigob.121403173614.379"></t>
<t tx="rodrigob.121403173614.380">class Struct:
    pass

class LeoIdentity(Identity):
    """
    This class add the permissions and temporal references 
    """
    
    def __init__(self, name, authorizer):
        """ """
        Identity.__init__(self, name, authorizer)
        
        return

</t>
<t tx="rodrigob.121403173614.381">class LeoAuthorizer(DefaultAuthorizer):
    """
    Dummy sub classing for flexibility and extension possibilities.
    """
    
    identityClass = LeoIdentity
    
    def createIdentity(self, name):
        """Create an identity of an appropriate type for this Authorizer.

        This identity will not be saved!  You must call its .save() method
        before it will be recognized by this authorizer.
        
        This authorizer avoid the usage of the names ["_room", "_everyone"]
        """
        
        if name in ["_room", "_everyone","to_send"]:
            raiseLeoError("The requested name is a keyword. Please choose another name.")
            
        return self.identityClass(name, self)


</t>
<t tx="rodrigob.121403173614.382">    
class LeoService(pb.Service):
    """
    
    This class provide access to a Leo Outline Server.
    
    The Service object's job is to provide Perspective instances, by implementing .getPerspectiveForIdentity(). This function takes a Perspective name, and is expected to return a Deferred which will (eventually) be called back with an instance of Perspective (or a subclass).
    """
    
    def __init__(self, serviceName, serviceParent, authorizer=None):
        pb.Service.__init__(self, serviceName, serviceParent, authorizer)
        self.perspectiveClass = OutlinePerspective 
    
        self.Outline = CollaborativeOutline()
        
        return
        
        
    def createPerspective(self, name, administrator=0):
        """Create a perspective from self.perspectiveClass and add it to this service.
        """
        
        if not administrator:
            p = OutlinePerspective(name, outline = self.Outline) # return an OutlinePerspective
        else:
            p = AdminOutlinePerspective(name, outline = self.Outline) # return an AdministratorPerspective
              
        
        self.perspectives[name] = p # LeoService need this ? Or Twisted use it in any other place ?
        p.setService(self)
        return p
        
        
    def getPerspectiveForIdentity(self, name, identity):
        """
        This method gives a perspective to outline. 
        The perspective name is encoded as an url.
        There is a special perspective named "/somepath/_admin" that give the administrator perspective. (some like the Zope /url/manage )
        Remember, the administrator obtain a diferent perspective that the users. An administrator cannot edit the tree... (obviously the user can log his self to two different paths)
        """
        
        t_list = filter(lambda x:x, name.split('/'))
        
        if t_list and t_list[-1]  == "_admin": # requesting administrator permissions # order is important, it avoid a crash if t_list == []
            administrator = 1
        else:
            administrator = 0					
            
        # name is the base Path (url)			
        if administrator: 
            path = '/' + '/'.join(t_list[:-1]) # erase admin
        else:
            path = name

        
        perspective_node = self.Outline.get_node(path)
        
        # find the correct Key
        keys = filter(lambda x: x[0] == self.getServiceName(), identity.getAllKeys() )
        # example of keys: [('LeoOutline', '/'), ('LeoOutline', '/_admin')]
        
        if administrator: # check if the user have a good key for the requested perspective
            
            # keep only the admin keys
            keys = filter(lambda x: x[1].split('/')[-1] == "_admin", keys)
            
            result = None
            
            for servicename, t_path in keys:
                
                t_path = filter(lambda y:y, t_path[1])[:-1] # avoid the _admin mark
                
                t_node = self.Outline.get_node(t_path)
                
                result = self.Outline.find_upward( lambda x: x == t_node, perspective_node) # check if the key is a parent of the node
                
                if result:
                    break
            # end of for each key
            
            if not result: # could not found a key that is parent of the requested access node
                raise	Unauthorized, "You do not have an administrator key for this path."
        
        
        if not administrator: # check if he can read the first node
            # get the path node
            t_node = self.Outline.get_node(path)
            
            if not t_node:
                raisePathError()
                    
            # obtain the first reference to that user
            t_node = self.Outline.find_upward(lambda x: x.permissions.has_key(identity.name), t_node)
            
            # check if the user has the permissions on the outline
            if not t_node:
                permissions  = []
            else:
                permissions = t_node.permissions[identity.name]
                
            if 'Read' not in permissions:
                raise	Unauthorized, "You do not have Read permission on this path (%s, %s, %s, %s)."%(identity.name, path, t_node, permissions)
                
        
        # create the perspective
        p = self.createPerspective(path, administrator) # one perspective per connection

        return defer.succeed(p)


</t>
<t tx="rodrigob.121403173614.383"></t>
<t tx="rodrigob.121403173614.384"></t>
<t tx="rodrigob.121403173614.385">
@
This program gives an interface for merging two Leo files.
@c


@

Create a Tk pane. Pane has text area (A,B)-&gt;C

Open the two files.

Compute the diff.

For each discrepance
  show the options to the user
  let him choice or edit


@c

import Tkinter
from Tkconstants import *
import tkFileDialog
import tkMessageBox
import ScrolledText

import difflib


class LeoMergePanel:
    
    def __init__(self, text_A, text_B):
        
        self.text_A = text_A
        self.text_B = text_B
        
        Tk = Tkinter
        self.tk_master = Tkinter.Tk()
        self.tk_master.title("Leo Merge Outlines Panel")
        self.frame     = frame = Tk.Frame(self.tk_master)
        self.frame.pack(fill=BOTH, expand=1)
                
        self.doc_text   = ScrolledText.ScrolledText(frame, wrap=WORD, bg="white")
        self.doc_text.pack(fill=BOTH, expand=1)
        
        self.doc_text.tag_config( SEL,     background="yellow" )
        self.doc_text.tag_config("insert", foreground="blue3",  underline  = 1)
        self.doc_text.tag_config("delete", foreground="green4", overstrike = 1)
        
        self.quit_button =  Tkinter.Button(frame, text='Quit', fg='red', command= self.tk_master.quit)
        self.quit_button.pack(side = BOTTOM)
        
        
        self.process()
        
        return
    
        
    def process(self):
        
        assert self.text_A and self.text_B
        linejunk = None
        charjunk = None
        #linejunk = lambda x: x in ['']
        #charjunk = lambda x: x in [' ', '\t']
        t_differ = difflib.Differ(linejunk, charjunk)
        
        t_char = ''#'\n'
        A = self.text_A#.split(t_char)
        B = self.text_B#.split(t_char)
        

        self.doc_text.insert(END, self.text_A)
        self.doc_text.insert(END, '------------------------------\n')
        self.doc_text.insert(END, self.text_B)
        self.doc_text.insert(END, '------------------------------\n')

        for t in t_differ.compare(A,B):
            if   t[0] == '+':			
                self.doc_text.insert(END, t[2:], "insert")
            elif t[0] == '-':
                self.doc_text.insert(END, t[2:], "delete")
            else:
                self.doc_text.insert(END, t[2:])
                
            self.doc_text.insert(END, t_char)
        
        return
        
    def mainloop(self):
        self.tk_master.mainloop()
        return


demo_text1="""
&lt;node "Test node"&gt;
This is a simple test code.
&lt;node "message"&gt;
  Hello world.
&lt;/node&gt;
&lt;/node&gt;
"""

demo_text2="""

&lt;node "node for testing"&gt;
This node is for being used as a simple test code.

Hello world.
&lt;/node&gt;
"""

def main():
    
    global demo_text1, demo_text2
    
    import sys
    if len(sys.argv) &gt;= 3:
        print 'Reading the input files'
        f1 = open(sys.argv[-2])
        f2 = open(sys.argv[-1])
        demo_text1 = f1.read()
        demo_text2 = f2.read()
        f1.close()
        f2.close()
    else:
        print len(sys.argv)
    
    gui = LeoMergePanel(demo_text1, demo_text2)

    gui.mainloop()
    
    return
    
    
if __name__ == "__main__":
    main()</t>
<t tx="rodrigob.121403173614.386">#!/bin/env python

# pyxi.py . Part of Udanax Green.

# Copyright 1999 by Ka-Ping Yee.  All rights reserved.
# This file is part of the Udanax Green distribution.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions: 
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software. 
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL Ka-Ping Yee OR Udanax.com BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
# THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
# 
# Except as contained in this notice, "Udanax", "Udanax.com", and the
# transcluded-U logo shall not be used in advertising or otherwise to
# promote the sale, use or other dealings in this Software without
# prior written authorization from Udanax.com.


import sys, os, string, x88, tktrans
from Tkinter import *


REVISION = "$Revision: 2.31 $"
VERSION = x88.Address(string.split(REVISION)[1])
PROGRAM = "pyxi v" + str(VERSION)
SMALLFONT = "-*-helvetica-medium-r-normal-*-10-*-75-75-*-*-iso8859-1"
MONOFONT = "-*-courier-medium-r-normal-*-12-*-75-75-*-*-iso8859-1"
PROPFONT = "-*-times-medium-r-normal-*-14-*-75-75-*-*-iso8859-1"
INPUTBG = "#e0c8c0"
SOURCEFG = "#0000c0"
TARGETBG = "#d0a060"
MARKBG = "#b0b0b0"
DEFAULTBG = "#d9d9d9"

# editing states
(NOTEDITING, INSERTING, DELETING) = (1, 2, 3)

def warn(message):
    sys.stderr.write(PROGRAM + ": " + message + "\n")

class Notifier:
    def __init__(self):
        self.listeners = {}

    def listen(self, message, callback):
        if not self.listeners.has_key(message):
            self.listeners[message] = []
        self.listeners[message].append(callback)

    def unlisten(self, message, callback):
        if self.listeners.has_key(message):
            try: self.listeners[message].remove(callback)
            except ValueError: pass

    def send(self, message, data=None):
        if self.listeners.has_key(message):
            for callback in self.listeners[message]:
                callback(self, message, data)

class XuText(Text):
    """XuText - an augmented Text widget that groks Addresses and Spans."""

    def __init__(self, *args, **kwargs):
        self.docid = None
        apply(Text.__init__, (self,) + args, kwargs)

    # conversion among positions, indices, and addresses

    # any integer is considered a position (number of characters from start)
    # any string is considered an index (Tk-style line.char, mark, or tag)
    # any x88.Address is considered local if 2 tumbler digits, global if more

    def position(self, other):
        if type(other) is type(1) or other is None:
            return other
        elif type(other) is type(""):
            return len(self.get("1.0", other))
        elif x88.istype(x88.Address, other):
            if len(other) &gt; 2:
                other = self.docid.localize(other)
            if other[0] != 1:
                raise ValueError, "%s is not in text region" % other
            return other[1] - 1
        else:
            raise TypeError, "%s is not an index, position, or address" % other

    def index(self, other):
        if type(other) is type(""):
            return Text.index(self, other)
        else:
            return "1.0 + %d c" % self.position(other)

    def vaddr(self, other):
        if x88.istype(x88.Address, other):
            return other
        else:
            return x88.Address(1, self.position(other) + 1)

    def addr(self, other):
        return self.docid.globalize(self.vaddr(other))

    def indices(self, vspan):
        if not x88.istype(x88.Span, vspan):
            raise TypeError, "%s is not a span" % vspan
        return self.index(vspan.start), self.index(vspan.end())

    def vspan(self, start, end):
        return x88.Span(self.vaddr(start), self.vaddr(end))

    # setting the selection and cursor position

    def setcur(self, other):
        self.mark_set("insert", self.index(other))

    def setsel(self, spec):
        self.tag_remove("sel", "0.0", "end")
        if x88.istype(x88.VSpec, spec):
            for span in spec.spans: self.addsel(span)
        else: self.addsel(spec)

    def addsel(self, span):
        if span is not None:
            start, end = self.index(span.start), self.index(span.end())
            self.tag_add("sel", start, end)

    # information about positions in the text widget

    def __len__(self):
        # Don't count the extra newline added by Tk.
        return self.position("end") - 1

    def selected(self):
        return len(self.tag_ranges("sel")) &gt; 0

    def selind(self):
        range = self.tag_ranges("sel")
        if not range: raise ValueError, "no text is selected"
        return range

    def selvspan(self):
        start, end = self.selind()
        return x88.VSpan(self.docid, self.vspan(start, end))

    def selvspec(self):
        return x88.VSpec(self.docid, [self.selvspan().span])

    def scroll(self, top):
        self.yview("moveto", top + 0.000001)

    def tagspecset(self, name, specset):
        self.tag_delete(name)
        for spec in specset:
            if x88.istype(x88.Span, spec):
                try: self.tagspan(name, self.docid.localize(spec))
                except: pass
            elif x88.istype(x88.VSpec, spec):
                for vspan in spec: self.tagspan(name, vspan.span)

    def tagspan(self, name, vspan):
        start, end = self.indices(vspan)
        self.tag_add(name, start, end)

class Clipboard(Notifier):
    """Clipboard - a class for marking and moving regions of text.
    A single clipboard is shared among all the browser windows."""

    def __init__(self, xusession):
        Notifier.__init__(self)
        self.markspan = None
        self.marktext = None
        self.movable = 0
        self.xs = xusession

    def mark(self, vspan, text=None, movable=0):
        """Set the marked text region."""
        if self.markspan:
            self.marktext.tag_delete("clip")

        if vspan:
            start, end = text.indices(vspan.span)
            text.tag_add("clip", start, end)
            text.tag_configure("clip", background=MARKBG)
            self.movable = movable
        else:
            self.movable = 0

        self.markspan = vspan
        self.marktext = text
        self.send("mark")

    def unmark(self, text):
        """Unset the marked text region."""
        if text is self.marktext:
            self.mark(None)

    def marked(self):
        """Return true if there is some text marked."""
        return self.markspan is not None

    def vcopy(self, addr, text):
        """Transclude the marked text at the given address."""
        docid, vaddr = addr.split()
        self.xs.vcopy(docid, vaddr, x88.SpecSet(self.markspan))
        data = self.marktext.get("clip.first", "clip.last")
        text.insert(text.index(vaddr), data)
        text.setsel(x88.Span(vaddr, vaddr + x88.Offset(0, len(data))))
        text.see("insert")
        self.mark(None)

    def move(self, addr, text):
        """Move the marked text to the given address."""
        docid, vaddr = addr.split()
        if self.markspan.contains(addr):
            self.mark(None)
        elif self.markspan.docid == docid:
            # Move text within a document by pivoting it around.
            vspan = self.markspan.span
            if vaddr &lt; vspan.start:
                self.xs.pivot(docid, vaddr, vspan.start, vspan.end())
            else:
                self.xs.pivot(docid, vspan.start, vspan.end(), vaddr)
            data = self.marktext.get("clip.first", "clip.last")
            text.insert("insert", data)
        else:
            # Move text to another document by doing vcopy and then remove.
            self.xs.vcopy(docid, vaddr, x88.SpecSet(self.markspan))
            data = self.marktext.get("clip.first", "clip.last")
            text.insert(text.index(vaddr), data)
            self.xs.remove(self.markspan.docid, self.markspan.span)

        # Select the newly-inserted text and unset the mark.
        text.setsel(x88.Span(vaddr, vaddr + x88.Offset(0, len(data))))
        text.see("insert")
        self.marktext.delete("clip.first", "clip.last")
        self.mark(None)

class Browser(Notifier, Frame):
    """Browser - the main widget for navigating and editing documents."""

    def __init__(self, parent, xusession, scrollside=RIGHT):
        Notifier.__init__(self)
        Frame.__init__(self, parent)
        self.xs = xusession

        # Build all the subwidgets.

        self.tool_frame = self.buildtoolbar(self)
        self.tool_frame.pack(side=TOP, fill=X)
        self.doc_menu = self.builddocmenu(self.doc_btn)
        self.edit_menu = self.buildeditmenu(self.edit_btn)
        self.link_menu = self.buildlinkmenu(self.link_btn)
        self.doc_frame = self.buildtextarea(self, scrollside)
        self.doc_frame.pack(fill=BOTH, expand=1)

        # Alt changes the cursor; Alt-Left and Alt-Right navigate the history.

        for widget in self, self.loc_entry, self.doc_text:
            for event in "KeyPress", "KeyRelease":
                for key in "Alt_L", "Alt_R":
                    widget.bind("&lt;%s-%s&gt;" % (event, key), self.eh_alt)
            widget.bind("&lt;Alt-Left&gt;", self.eh_back)
            widget.bind("&lt;Alt-Right&gt;", self.eh_fwd)

        # These keys can change the selection.

        for key in ["Shift_L", "Shift_R", "Up", "Down", "Left", "Right",
                    "Home", "End", "Prior", "Next"]:
            self.doc_text.bind("&lt;KeyRelease-%s&gt;" % key, self.eh_keyrelease)

        self.bind("&lt;Enter&gt;", self.eh_enter)
        self.bind("&lt;Destroy&gt;", self.eh_destroy)
        self.doc_text.focus()

        # Initialize member variables.

        self.sourceends = x88.SpecSet()
        self.targetends = x88.SpecSet()

        self.docid = None
        self.textspec = None
        self.textvspan = None
        self.linkvspan = None

        self.history = []
        self.histindex = 0

        self.busycount = 0
        self.xcursor = "xterm"

        self.editable = 0
        self.editstate = NOTEDITING
        self.editcount = 0

        self.linkactions = [(x88.MARGIN_TYPE, self.marginaction)]

    def buildtoolbar(self, parent):
        """Create the toolbar area."""
        frame = Frame(parent)

        self.loc_var = StringVar()
        self.loc_entry = Entry(frame, bd=1, width=8, background=INPUTBG,
                               textvariable=self.loc_var)
        self.loc_entry.bind("&lt;Return&gt;", self.eh_return)
        self.loc_entry.pack(side=LEFT, fill=X, expand=1)

        self.edit_label = Label(frame, pady=2, bd=1, font=SMALLFONT)
        self.edit_label.bind("&lt;Button&gt;", self.eh_click)

        self.doc_btn = Menubutton(frame, text="Document", padx=4, pady=0)
        self.edit_btn = Menubutton(frame, text="Edit", padx=4, pady=0)
        self.link_btn = Menubutton(frame, text="Link", padx=4, pady=0)

        self.back_btn = Button(frame, text="back", font=SMALLFONT,
                               state=DISABLED, padx=4, pady=1, bd=1,
                               command=self.cb_back)
        self.fwd_btn = Button(frame, text="fwd", font=SMALLFONT,
                              state=DISABLED, padx=4, pady=1, bd=1,
                              command=self.cb_fwd)
        self.reload_btn = Button(frame, text="reload", font=SMALLFONT,
                                 state=DISABLED, padx=4, pady=1, bd=1,
                                 command=self.cb_reload)
        for child in [self.reload_btn, self.fwd_btn, self.back_btn,
                      self.link_btn, self.edit_btn, self.doc_btn,
                      self.edit_label]:
            child.pack(side=RIGHT)
        return frame

    def builddocmenu(self, parent):
        """Create the Document menu."""
        parent["menu"] = menu = Menu(parent)

        menu.add_command(label="Open New Window",
                         command=self.cb_newwindow)
        menu.add_command(label="Create New Document",
                         command=self.cb_createdocument)
        menu.add_command(label="Import New Document",
                         command=self.cb_importdocument)
        menu.add_command(label="Export Current Document",
                         command=self.cb_exportdocument)
        menu.add_command(label="Create New Version",
                         command=self.cb_createversion)
        menu.add_separator()
        self.font_var = StringVar()
        self.font_var.set(PROPFONT)
        menu.add_radiobutton(label="Monospaced Font", value=MONOFONT,
                             command=self.cb_font, variable=self.font_var)
        menu.add_radiobutton(label="Proportional Font", value=PROPFONT,
                             command=self.cb_font, variable=self.font_var)
        self.spacing_var = IntVar()
        self.spacing_var.set(1)
        menu.add_checkbutton(label="Paragraph Spacing",
                             command=self.cb_font, variable=self.spacing_var)
        return menu

    def buildeditmenu(self, parent):
        """Create the Edit menu."""
        parent["menu"] = menu = Menu(parent)

        self.edit_var = IntVar()
        menu.add_checkbutton(label="Enable Editing",
                             command=self.cb_editable, variable=self.edit_var)
        menu.add_separator()
        menu.add_command(label="Mark", state=DISABLED,
                         command=self.cb_mark)
        menu.add_command(label="Transclude", state=DISABLED,
                         command=self.cb_vcopy)
        menu.add_command(label="Move", state=DISABLED,
                         command=self.cb_move)
        clipboard.listen("mark", self.updateeditmenu)
        return menu

    def buildlinkmenu(self, parent):
        """Create the Link menu."""
        parent["menu"] = menu = Menu(parent)

        menu.add_command(label="Add Source End",
                         command=self.cb_addsource, state=DISABLED)
        self.sourceindex = menu.index("end")
        menu.add_separator()
        menu.add_command(label="Add Target End",
                         command=self.cb_addtarget, state=DISABLED)
        self.targetindex = menu.index("end")
        menu.add_separator()
        menu.add_command(label="Create Link",
                         command=self.cb_link, state=DISABLED)
        menu.add_command(label="Clear Ends",
                         command=self.cb_clear, state=DISABLED)
        return menu

    def buildtextarea(self, parent, scrollside=RIGHT):
        """Create the text editing area."""
        frame = Frame(parent)

        self.doc_scroll = Scrollbar(frame, bd=2, width=11)
        self.doc_scroll.pack(side=scrollside, fill=Y)
        self.doc_text = XuText(frame, wrap=WORD, font=PROPFONT, spacing1=10)
        self.doc_text.pack(fill=BOTH, expand=1)
        def yview(cmd, pos, units=None, self=self):
            if units is None:
                self.doc_text.yview(cmd, pos)
            else:
                self.doc_text.yview(cmd, pos, units)
            self.send("scroll")
        self.doc_scroll.configure(command=yview)
        def scrollset(top, bottom, self=self):
            self.doc_scroll.set(top, bottom)
            self.send("scroll")
        self.doc_text.configure(yscrollcommand=scrollset)
        self.doc_text.bind("&lt;KeyPress&gt;", self.eh_key)
        self.doc_text.bind("&lt;ButtonPress&gt;", self.eh_click)
        self.doc_text.bind("&lt;ButtonRelease&gt;", self.eh_release)
        return frame

    # UI control

    def updatecursor(self):
        """Update the mouse pointer cursor."""
        if self.busycount &gt; 0:
            self.configure(cursor="watch")
            self.loc_entry.configure(cursor="watch")
            self.doc_text.configure(cursor="watch")
        else:
            self.configure(cursor="")
            self.loc_entry.configure(cursor="xterm")
            self.doc_text.configure(cursor=self.xcursor)
        self.update()

    def busy(self):
        """Call this before doing a potentially lengthy operation."""
        self.busycount = self.busycount + 1
        self.updatecursor()

    def ready(self):
        """Call this after finishing a potentially lengthy operation."""
        if self.busycount &gt; 0:
            self.busycount = self.busycount - 1
        self.updatecursor()

    def updatefwdback(self):
        """Update the forward and back buttons to reflect the history."""
        self.back_btn.configure(
            state=(self.histindex &gt; 0 and NORMAL or DISABLED))
        self.fwd_btn.configure(
            state=(self.histindex &lt; len(self.history) and NORMAL or DISABLED))
        self.reload_btn.configure(
            state=(self.docid and NORMAL or DISABLED))

    def updateeditmenu(self, *args):
        """Update the Edit menu to reflect the selection and clipboard state."""
        selected = self.doc_text.selected() and NORMAL or DISABLED
        self.edit_menu.entryconfigure(3, state=selected)
        self.edit_menu.entryconfigure(4, state=clipboard.marked() and \
            self.editable and NORMAL or DISABLED)
        self.edit_menu.entryconfigure(5, state=clipboard.marked() and \
            self.editable and clipboard.movable and NORMAL or DISABLED)
        
    def updatelinkmenu(self):
        """Update the Link menu to reflect the selection state."""
        linkends = self.sourceends or self.targetends

        last = self.link_menu.index("end")
        self.link_menu.entryconfigure(last - 1,
            state=linkends and self.editable and NORMAL or DISABLED)
        self.link_menu.entryconfigure(last,
            state=linkends and NORMAL or DISABLED)

        selected = self.doc_text.selected() and NORMAL or DISABLED
        self.link_menu.entryconfigure(self.sourceindex, state=selected)
        self.link_menu.entryconfigure(self.targetindex, state=selected)

    def setwidth(self, width):
        dummy = Label(font=self.doc_text.cget("font"), text="0", bd=0, padx=0)
        charwidth = dummy.winfo_reqwidth()
        width = width - self.doc_scroll.winfo_width()
        charcount = width / charwidth
        self.doc_text.config(width=charcount)

    # editing

    def deleteselection(self):
        """Delete the selected text and flush immediately to the back-end."""
        selvspan = self.doc_text.selvspan()
        self.finishedit()
        self.xs.remove(self.docid, selvspan.span)
        return selvspan.span

    def insertchar(self, ch):
        """Handle a single insert operation and buffer it."""
        if self.editstate != INSERTING:
            self.finishedit()
            if self.doc_text.selected():
                self.insaddr = self.deleteselection().start
            else:
                self.insaddr = self.doc_text.vaddr("insert")
            self.inschars = []
            self.editstate = INSERTING

        if ch == "\r": ch = "\n"
        self.inschars.append(ch)
        self.editcount = self.editcount + 1
        self.edit_label.config(text="%3d" % self.editcount,
                               foreground="darkgreen", relief=SUNKEN)
        self.doc_text.insert("insert", ch)
        self.doc_text.tag_remove("source", "insert - 1 c", "insert")
        self.doc_text.tag_remove("target", "insert - 1 c", "insert")
        self.doc_text.tag_remove("type", "insert - 1 c", "insert")
        self.doc_text.see("insert")
        clipboard.unmark(self.doc_text)
        if self.doc_text.selected():
            self.doc_text.delete("sel.first", "sel.last")
        self.send("edit")
        return "break"

    def deletechar(self, ch):
        """Handle a single delete operation and buffer it."""
        if self.doc_text.selected():
            self.deleteselection()
            self.send("edit")
            return

        if self.editstate != DELETING:
            self.finishedit()
            self.delmin = self.delmax = self.doc_text.position("insert")
            self.deletelimit = len(self.doc_text)
            self.editstate = DELETING

        if ch == "\010" and self.delmin &gt; 0:
            self.delmin = self.delmin - 1
        if ch == "\177" and self.delmax &lt; self.deletelimit:
            self.delmax = self.delmax + 1
        self.editcount = self.editcount + 1
        self.edit_label.config(text="%3d" % self.editcount,
                               foreground="darkred", relief=SUNKEN)
        clipboard.unmark(self.doc_text)
        self.send("edit")

    def finishedit(self):
        """Flush the current editing operation to the back-end."""
        if self.editstate != NOTEDITING:
            if self.editstate == INSERTING:
                text = string.join(self.inschars, "")
                self.xs.insert(self.docid, self.insaddr, [text])
            if self.editstate == DELETING:
                vspan = self.doc_text.vspan(self.delmin, self.delmax)
                self.xs.remove(self.docid, vspan)
            self.editstate = NOTEDITING
        self.editcount = 0
        try: self.edit_label.config(text="", foreground="black", relief=FLAT)
        except TclError: pass

    # keyboard event handlers

    def eh_key(self, event):
        """Handle a keypress in the text editing area."""
        if event.keysym[-2:] in ["_L", "_R"]: # Ignore keypress on modifiers.
            return

        if event.state &amp; 4 and event.char: # Ignore Ctrl-* editing commands.
            return "break"
        elif event.state &amp; ~1: # Pass through if any other modifier is on.
            return

        if event.char in ["\010", "\177"]:
            if not self.editable: return "break"
            return self.deletechar(event.char)
        elif event.char &gt;= " " or event.char in ["\t", "\r"]:
            if not self.editable: return "break"
            return self.insertchar(event.char)
        else:
            return self.finishedit()

    def eh_keyrelease(self, event):
        """Update menus when Shift or a cursor-movement key is released,
        since these keys can cause the selection to change."""
        self.updateeditmenu()
        self.updatelinkmenu()

    def eh_alt(self, event):
        """Update the cursor when Alt is depressed or released."""
        if event.type == "2": # KeyPress
            self.xcursor = "hand2"
        elif event.type == "3": # KeyRelease
            self.xcursor = "xterm"
        self.updatecursor()

    def eh_enter(self, event):
        """Do various updates when the mouse pointer enters the window.
        While the pointer has been away, another window may have cleared
        our selection, or the Alt key may have been depressed."""
        self.updateeditmenu()
        self.updatelinkmenu()
        self.xcursor = event.state &amp; 8 and "hand2" or "xterm"
        self.updatecursor()

    def eh_return(self, event):
        """Go to the address that has been entered into the location field."""
        location = string.strip(self.loc_var.get())
        self.loc_var.set(location)
        try:
            addr = x88.Address(location)
        except ValueError:
            tktrans.error(self,
                "\"%s\" is not a well-formed tumbler." % location,
                "Invalid Address")
            self.loc_var.set(self.docid)
            return
        try:
            self.xs.open_document(addr, x88.READ_ONLY, x88.CONFLICT_COPY)
            try:
                self.xs.retrieve_vspanset(addr)
            finally:
                self.xs.close_document(addr)
        except x88.XuError:
            tktrans.error(self,
                "There is no document at the address \"%s\"." % location,
                "Invalid Address")
            self.loc_var.set(self.docid)
            return
        self.browse(addr)

    def eh_fwd(self, event):
        self.cb_fwd()
        return "break"

    def eh_back(self, event):
        self.cb_back()
        return "break"

    def eh_destroy(self, event):
        if event.widget is not self: return
        try: self.closedoc()
        except (IOError, x88.XuError): pass
        return

    # toolbar callbacks and event handlers

    def cb_fwd(self):
        """Navigate one step forward in the history stack."""
        if self.histindex &gt;= len(self.history): return
        self.fwd_btn.configure(relief=SUNKEN)
        self.fwd_btn.update()
        origin, dest = self.history[self.histindex]
        self.goto(dest)
        self.histindex = self.histindex + 1
        self.fwd_btn.configure(relief=RAISED)
        self.updatefwdback()

    def cb_back(self, event=None):
        """Navigate one step backward in the history stack."""
        if self.histindex &lt; 1: return
        self.back_btn.configure(relief=SUNKEN)
        self.back_btn.update()
        self.histindex = self.histindex - 1
        origin, dest = self.history[self.histindex]
        spec, top = origin
        self.goto(spec, top)
        self.back_btn.configure(relief=RAISED)
        self.updatefwdback()

    def cb_reload(self):
        self.reload()

    # document menu callbacks

    def cb_newwindow(self):
        """Open a new window on the same document."""
        window = BrowserWindow(self.xs)
        window.goto(self.docid)

    def cb_createdocument(self):
        """Create a new document and open it for editing in a new window."""
        docid = self.xs.create_document()
        docid = self.xs.open_document(
            docid, x88.READ_WRITE, x88.CONFLICT_COPY)
        # workaround: back-end acts weird on empty documents
        self.xs.insert(docid, x88.Address(1, 1), [" "])
        self.xs.close_document(docid)
        window = BrowserWindow(self.xs)
        window.goto(docid, editable=1)

    def importstuff(self,input):
        """import the stuff in the opened input"""
        if self.editable:
            docid = self.docid
            address = self.doc_text.vaddr("insert")
        else:
            docid = self.xs.create_document()
            docid = self.xs.open_document(
                docid, x88.READ_WRITE, x88.CONFLICT_COPY)
            address = x88.Address(1, 1)

        while 1:
            # workaround: insert buffer in the back-end has a limited size
            data = input.read(900)
            if not data: break
            self.xs.insert(docid, address, [data])
            address = address + x88.Offset(0, len(data))
        self.xs.close_document(docid)
        return docid

    def importdir(self,dirpath,dirs): # called by walk
        """ import contents of the directory """
        for file  in dirs:
            file = os.path.join(dirpath,file)
            if(os.path.isfile(file)): # don't do the directories
                try:
                    input = open(os.path.join(dirpath,file))
                    docid = self.importstuff(input)
                    f = file + "\n"
                    self.xs.insert(self.indexdocid,self.address,[f])
                    sourcespec = x88.SpecSet(x88.VSpec(self.indexdocid,[x88.Span(self.address, x88.Offset(0, len(file)))]))
                    targetspec = x88.SpecSet(x88.VSpec(docid,[x88.Span(x88.Address(1, 1), x88.Offset(0, 1))]))
                    self.address = self.address + x88.Offset(0, len(f))
                    self.xs.create_link(self.indexdocid, sourcespec, targetspec,
                                x88.SpecSet(x88.JUMP_TYPE))
                    #print "opened the file \"%s\"." % os.path.join(dirpath,file)
                except IOError:
                     print "Could not open the file \"%s\"." % os.path.join(dirpath,file)
                 
    def cb_importdocument(self):
        """Read a file or the output of a command, and either insert it
        into the current document if it's editable, or put it into a new
        document otherwise.  if it's a directory (or link or mount) make
        a file with the paths in it and link all the files  to that after
        importing  them"""
        file = tktrans.getstring(self,
            "Enter a filename (or a command followed by \"|\"):",
            self.editable and "Insert Document" or "Import Document")
        if file is None: return
        file = string.strip(file)
        if not file: return

        self.busy()
        try:
            if file[-1:] == "|":
                input = os.popen(file[:-1], "r")
                docid = self.importstuff(input)
            elif(os.path.isdir(file)):
                self.indexdocid = self.xs.create_document()
                self.indexdocid = self.xs.open_document(
                    self.indexdocid, x88.READ_WRITE, x88.CONFLICT_COPY)
                self.address = x88.Address(1, 1)
                os.path.walk(file,Browser.importdir,self)
                docid = self.indexdocid
                self.xs.close_document(self.indexdocid)
            else:
                try:
                    input = open(file)
                    docid = self.importstuff(input)
                except IOError:
                    tktrans.error(self,
                        "Could not open the file \"%s\"." % file,
                        "Import Failed")
                    return
            
            if self.editable:
                self.reload()
            else:
                window = BrowserWindow(self.xs)
                window.goto(docid)

        finally:
            self.ready()

    def cb_exportdocument(self):
        """ export the text  of the  current document, currently as a
        flat text, later perhaps as html or xml or a real standard  when that
        becomes possible"""
        file = tktrans.getstring(self,
            "Enter a filename ")
        if file is None: return
        file = string.strip(file)
        if not file: return
        #print self.doc_text.get("0.0","end")

    output = open(file,"w")
    output.write(self.doc_text.get("0.0","end"))
    output.close();

    def cb_createversion(self):
        """Create a new version of the current document and open it for
        editing in a new window."""
        docid = self.xs.create_version(self.docid)
        window = BrowserWindow(self.xs)
        window.goto(docid, editable=1)

    def cb_font(self):
        """Change the font or spacing settings."""
        self.doc_text.config(font=self.font_var.get(),
                             spacing1=self.spacing_var.get() and 10 or 0)

    # edit menu callbacks

    def cb_editable(self):
        """Reopen the document when the "Enable Editing" box is toggled."""
        docid = self.docid
        self.closedoc()
        self.opendoc(docid, editable=self.edit_var.get())
        self.updateeditmenu()
        self.updatelinkmenu()

    def cb_mark(self):
        """Set the selected span of the text as the marked region."""
        clipboard.mark(self.doc_text.selvspan(), self.doc_text, self.editable)

    def cb_vcopy(self):
        """Transclude the marked text at the text cursor location."""
        clipboard.vcopy(self.doc_text.addr("insert"), self.doc_text)

    def cb_move(self):
        """Move the marked text to the text cursor location."""
        clipboard.move(self.doc_text.addr("insert"), self.doc_text)

    # link menu callbacks

    def cb_link(self):
        """Create a new link with the link ends listed in the Link menu."""
        choices = map(lambda t: (string.capitalize(x88.TYPE_NAMES[t]), t),
                      x88.LINK_TYPES)
        result = tktrans.choose(
            self, choices, "Select a link type:", "Link Type")
        if result:
            self.xs.create_link(self.docid, self.sourceends, self.targetends,
                                x88.SpecSet(result))
            self.cb_clear()
            self.showendsets()

    def cb_clear(self):
        """Clear the link ends from the Link menu."""
        menulength = self.link_menu.index("end")
        if self.targetends:
            self.link_menu.delete(self.targetindex + 1, menulength - 3)
            self.targetends.clear()
        if self.sourceends:
            self.link_menu.delete(self.sourceindex + 1, self.targetindex - 2)
            self.sourceends.clear()
        self.targetindex = self.sourceindex + 2
        self.updatelinkmenu()

    def cb_addsource(self):
        """Add the selected span to the list of source ends in the Link menu."""
        if not self.doc_text.selected(): return
        vspec = self.doc_text.selvspec()
        self.sourceends.append(vspec)

        def jump(browse=self.browse, vspec=vspec): browse(vspec)
        self.link_menu.insert_command(self.sourceindex + len(self.sourceends),
            label=str(vspec)[1:-1], command=jump)

        self.targetindex = self.targetindex + 1
        self.updatelinkmenu()

    def cb_addtarget(self):
        """Add the selected span to the list of target ends in the Link menu."""
        if not self.doc_text.selected(): return
        vspec = self.doc_text.selvspec()
        self.targetends.append(vspec)

        def jump(browse=self.browse, vspec=vspec): browse(vspec)
        self.link_menu.insert_command(self.targetindex + len(self.targetends),
            label=str(vspec)[1:-1], command=jump)

        self.updatelinkmenu()

    # text area event handlers

    def eh_nothing(self, event):
        """This temporary callback prevents mouse activity from affecting
        a newly-loaded document after clicking on a link."""
        self.doc_text.unbind("&lt;Button&gt;")
        return "break"

    def eh_click(self, event):
        """Flush the editing operation when a click moves the cursor."""
        self.finishedit()

    def eh_release(self, event):
        """Update menus when a mouse button is release, since this could
        cause the selection to change."""
        self.updateeditmenu()
        self.updatelinkmenu()

    def findvspan(self, specset, span):
        """Return the unique vspan in a specset containing the given span."""
        result = None
        for vspec in specset:
            for vspan in vspec:
                if vspan.contains(span):
                    if result: return None # not unique
                    else: result = vspan
        return result
        
    def eh_linkend(self, event):
        """Traverse a link when the user clicks on a link end in the text."""
        self.finishedit()
        self.busy()
        try:
            # Get the address and span of the character at the mouse pointer.
            vaddr = self.doc_text.vaddr("current")
            charspan = x88.Span(vaddr, x88.Offset(0, 1))
            specend = x88.SpecSet(x88.VSpec(self.docid, [charspan]))
            clickspan = self.docid.globalize(charspan)

            # Find the first source or target link end at the clicked spot.
            dest = None
            direction = 0
            links = self.xs.find_links(specend)
            if links:
                dests = self.xs.follow_link(links[0], x88.LINK_TARGET)
                origins = self.xs.follow_link(links[0], x88.LINK_SOURCE)
                if dests: dest = dests[0]
                direction = 1
            else:
                links = self.xs.find_links(x88.NOSPECS, specend)
                if links:
                    dests = self.xs.follow_link(links[0], x88.LINK_SOURCE)
                    origins = self.xs.follow_link(links[0], x88.LINK_TARGET)
                    if dests: dest = dests[0]
                    direction = -1

            if dest:
                # Check the type of the link and do the appropriate action.
                types = self.xs.follow_link(links[0], x88.LINK_TYPE)
                for type, function in self.linkactions:
                    if type in types:
                        if function(links[0], origins, dests, direction):
                            break
                else:
                    origin = self.findvspan(origins, clickspan) or clickspan
                    self.browse(dest, origin)

        finally:
            self.ready()
        self.doc_text.focus()
        self.doc_text.bind("&lt;Button&gt;", self.eh_nothing)
        return "break"

    def marginaction(self, link, origins, dests, direction):
        """To present a "marginal note" type of link, display the text
        of the target end of the link in a pop-up message box."""
        if direction == 1:
            docids = {}
            for target in dests:
                if x88.istype(x88.Span, target):
                    docids[target.start.split()[0]] = 1
                if x88.istype(x88.VSpec, target):
                    docids[target.docid] = 1
            for docid in docids.keys():
                self.xs.open_document(
                    docid, x88.READ_ONLY, x88.CONFLICT_COPY)
            data = string.join(self.xs.retrieve_contents(dests), "")
            for docid in docids.keys():
                self.xs.close_document(docid)

            tktrans.MessageBox(self, "Marginal Note", data)
            return 1

    def eh_linkprop(self, event):
        """Present a popup with information about a link end."""
        self.finishedit()
        self.busy()
        try:
            vaddr = self.doc_text.vaddr("current")
            charspan = x88.Span(vaddr, x88.Offset(0, 1))
            specset = x88.SpecSet(x88.VSpec(self.docid, [charspan]))

            links = self.xs.find_links(specset) + \
                    self.xs.find_links(x88.NOSPECS, specset) + \
                    self.xs.find_links(x88.NOSPECS, x88.NOSPECS, specset)
            if links:
                clickspan = specset[0][0]
                if len(links) == 1:
                    self.link_popup = Menu()
                    link = links[0]
                    self.buildlinkpopup(self.link_popup, link, clickspan)
                else:
                    self.link_popup = Menu(tearoff=0)
                    for link in links:
                        menu = Menu(self.link_popup)
                        self.buildlinkpopup(menu, link, clickspan)
                        self.link_popup.add_cascade(
                            label="Link %s" % str(link), menu=menu)
                rootx = event.x + self.winfo_rootx()
                rooty = event.y + self.winfo_rooty()
                self.link_popup.post(rootx, rooty)
        finally:
            self.ready()

        return "break"

    def buildlinkpopup(self, menu, link, clickspan):
        """Construct the popup menu describing a given link."""
        typenames = []
        try:
            specset = self.xs.follow_link(link, x88.LINK_TYPE)
            for spec in specset:
                if spec in x88.LINK_TYPES:
                    typenames.append(x88.TYPE_NAMES[spec])
        except x88.XuError: pass

        label = "Link %s" % str(link)
        if typenames:
            label = label + " (" + string.join(typenames, ", ") + ")"
        menu.add_command(label=label, state=DISABLED)

        for label, end in (("Source", x88.LINK_SOURCE),
                           ("Target", x88.LINK_TARGET)):
            menu.add_separator()
            menu.add_command(label="%s Ends" % label, state=DISABLED)
            specset = self.xs.follow_link(link, end)
            for spec in specset:
                def jump(self=self, spec=spec): self.browse(spec)
                colour = spec.contains(clickspan) and "red" or "black"
                menu.add_command(label=str(spec)[1:-1], command=jump,
                                 foreground=colour, activeforeground=colour)

    # document navigation

    def reload(self):
        """Reload the document, preserving the view and cursor position."""
        self.finishedit()
        top, bottom = self.doc_text.yview()
        cursor = self.doc_text.index("insert")
        self.busy()
        try:
            self.loaddoc(self.docid, self.editable)
            self.doc_text.scroll(top)
            self.doc_text.setcur(cursor)
        finally:
            self.ready()

    def goto(self, spec, top=None, editable=0):
        """Navigate to a given address or span without recording history."""
        self.finishedit()
        self.busy()
        try:
            if x88.istype(x88.Address, spec):
                if spec != self.docid:
                    self.loaddoc(spec, editable)
                if top: self.doc_text.scroll(top)

            elif x88.istype(x88.Span, spec):
                self.goto(spec.localize(), top, editable)
                if top: self.doc_text.scroll(top)

            elif x88.istype(x88.VSpan, spec):
                if spec.docid != self.docid:
                    self.loaddoc(spec.docid, editable)
                if top: self.doc_text.scroll(top)

                start, end = self.doc_text.indices(spec.span)
                self.doc_text.see(start)
                self.doc_text.see(end)
                self.doc_text.setsel(spec.span)
                self.doc_text.setcur(end)

            elif x88.istype(x88.VSpec, spec):
                if len(spec): self.goto(spec[0], top, editable)
                self.doc_text.setsel(spec)

        finally:
            self.ready()

    def browse(self, spec, origin=None):
        """Navigate to a given address or span, recording a history entry."""
        top, bottom = self.doc_text.yview()
        here = (origin or self.docid), top
        self.goto(spec)
        self.history[self.histindex:] = [(here, spec)]
        self.histindex = self.histindex + 1
        self.updatefwdback()

    def showendsets(self):
        """Highlight all the link ends in the current document."""
        source, target, type = self.xs.retrieve_endsets(self.textspec)
        self.doc_text.tagspecset("source", source)
        self.doc_text.tagspecset("target", target)
        self.doc_text.tag_configure("source", underline=1, foreground=SOURCEFG)
        self.doc_text.tag_bind("source", "&lt;Alt-Button-1&gt;", self.eh_linkend)
        self.doc_text.tag_bind("source", "&lt;Button-3&gt;", self.eh_linkprop)
        self.doc_text.tag_configure("target", background=TARGETBG)
        self.doc_text.tag_bind("target", "&lt;Alt-Button-1&gt;", self.eh_linkend)
        self.doc_text.tag_bind("target", "&lt;Button-3&gt;", self.eh_linkprop)

    def loaddoc(self, docid, editable=0):
        """Load a document into the text area."""
        self.closedoc()
        self.opendoc(docid, editable)
        self.showdoc()
        self.showendsets()

    def opendoc(self, docid, editable=0):
        """Open a document, optionally for editing."""
        mode = editable and x88.READ_WRITE or x88.READ_ONLY
        docid = self.xs.open_document(docid, mode, x88.CONFLICT_COPY)

        self.textvspan = self.linkvspan = None
        for vspan in self.xs.retrieve_vspanset(docid):
            span = vspan.span
            if vspan.span.start[0] == 1:
                # This will break if the back-end returns more than one span.
                self.textvspan = vspan.span
            elif vspan.span.start[0] == 2:
                self.linkvspan = vspan.span
            else:
                warn("ignoring vspan %s" % vspan)

        if self.textvspan is not None:
            textvspec = x88.VSpec(docid, [self.textvspan])
            self.textspec = x88.SpecSet(textvspec)
        else:
            warn("document contains no data")

        self.loc_var.set(str(docid))
        self.doc_text.docid = self.docid = docid
        self.editable = editable
        self.doc_menu.entryconfigure(
            3, label=editable and "Insert Document" or "Import New Document")
        self.doc_text.config(bg=editable and INPUTBG or DEFAULTBG)
        self.doc_scroll.config(bg=editable and INPUTBG or DEFAULTBG)
        self.edit_var.set(editable)
        self.updatefwdback()
        self.send("opendoc")

    def showdoc(self):
        """Display the contents of a document in the text area."""
        if self.textvspan is not None:
            text = self.xs.retrieve_contents(self.textspec)[0]
            self.doc_text.delete("1.0", "end")
            self.doc_text.insert("1.0", text)

    def closedoc(self):
        """Clean up and close the current document."""
        self.finishedit()
        if self.docid:
            self.xs.close_document(self.docid)
        self.doc_text.docid = self.docid = None
        self.textspec = None
        self.textvspan = None
        self.linkvspan = None
        clipboard.unmark(self.doc_text)
        self.send("closedoc")

class BrowserWindow(Toplevel):
    """BrowserWindow - a Window containing a single Browser."""

    def __init__(self, xusession, title=PROGRAM):
        Toplevel.__init__(self)
        windows[self] = 1
        self.title(title)
        self.browser = Browser(self, xusession, scrollside=LEFT)
        self.browser.pack(fill=BOTH, expand=1)
        self.bind("&lt;Destroy&gt;", self.eh_destroy)
        self.bind("&lt;Alt-q&gt;", self.eh_quit)

    def goto(self, spec, top=None, editable=0):
        self.browser.goto(spec, top, editable)

    def browse(self, spec, origin=None):
        self.browser.browse(spec, origin)

    def quit(self):
        try: self.browser.closedoc()
        except (IOError, x88.XuError): pass
        Toplevel.quit(self)

    def eh_quit(self, event):
        self.quit()

    def eh_destroy(self, event):
        """Close the window; quit the application if this is the last one."""
        if event.widget is not self: return
        try: self.browser.closedoc()
        except (IOError, x88.XuError): pass

        if windows.has_key(self):
            del windows[self]
            if not windows.keys(): self.quit()
        else:
            return "break"

class TwoBrowserWindow(BrowserWindow):
    """TwoBrowserWindow - a Window that can optionally display two Browsers
    and draw transpointing lines between them connecting common sections."""

    commoncolours = ["#ffc0c0", "#ffe0a0", "#ffffc0", "#c0ffc0",
                     "#c0e0ff", "#c0c0ff", "#e0a0ff"]

    def __init__(self, xusession, title=PROGRAM):
        BrowserWindow.__init__(self, xusession, title)
        self.xs = xusession
        self.browser2 = None
        self.comparing = 0
        self.bind("&lt;Alt-p&gt;", self.eh_parallel)

    def eh_config(self, event):
        if event.widget is self and self.browser2:
            self.fixsize()

    def fixsize(self):
        width = self.winfo_width()
        height = self.winfo_height()
        brwidth = (width-120)/2
        self.browser.setwidth(brwidth)
        self.browser2.setwidth(brwidth)

    def eh_parallel(self, event):
        """Toggle display of the second browser pane."""
        if self.browser2:
            for browser in self.browser, self.browser2:
                browser.unlisten("opendoc", self.updatecompare)
                browser.unlisten("closedoc", self.cb_closedoc)

            self.browser.forget()
            self.trans_frame.forget()
            self.browser2.closedoc()
            self.browser2.forget()

            self.browser.pack(fill=BOTH, expand=1)
            self.browser2 = None
            self.bind("&lt;Configure&gt;", "")

        else:
            self.browser.forget()
            self.trans_frame = Frame(self, width=100)
            self.browser2 = Browser(self, self.browser.xs)

            self.browser.pack(fill=BOTH, side=LEFT)
            self.browser2.pack(fill=BOTH, side=RIGHT)
            self.trans_frame.pack(fill=BOTH, expand=1)

            self.fixsize()
            self.bind("&lt;Configure&gt;", self.eh_config)

            self.compare_btn = Button(self.trans_frame, font=SMALLFONT, bd=1,
                                      pady=1, text="compare", width=100,
                                      command=self.cb_compare)
            self.compare_btn.pack(side=TOP)
            self.updatecompare()
            self.trans_canvas = Canvas(self.trans_frame)
            self.trans_canvas.pack(fill=BOTH, expand=1)

            self.sharedspans = []
            for browser in self.browser, self.browser2:
                browser.listen("opendoc", self.updatecompare)
                browser.listen("closedoc", self.cb_closedoc)

    def quit(self):
        BrowserWindow.quit(self)
        if self.browser2:
            try: self.browser2.closedoc()
            except (IOError, x88.XuError): pass

    def updatelines(self, *args):
        """Update the transpointing lines in the middle canvas."""
        def linenum(text, index, atoi=string.atoi, split=string.split):
            return atoi(split(text.index(index), ".")[0])

        text, text2 = self.browser.doc_text, self.browser2.doc_text
        top, top2 = linenum(text, "@0,0"), linenum(text2, "@0,0")
        lineheight = text.dlineinfo("@0,0")[3]

        self.trans_canvas.config(height=text.winfo_height())
        width = self.trans_canvas.winfo_width()
        height = self.trans_canvas.winfo_height()

        def ymin(text, index):
            result = text.bbox(index)
            return result and result[1]

        def ymax(text, index):
            result = text.bbox(index)
            return result and result[1] + result[3]

        index = 0
        for leftspan, rightspan in self.sharedspans:
            id = self.translines[index]
            index = index + 1

            leftstart, leftend = text.indices(leftspan.span)
            rightstart, rightend = text2.indices(rightspan.span)

            leftymin = ymin(text, leftstart)
            leftymax = ymax(text, leftend)
            rightymin = ymin(text2, rightstart)
            rightymax = ymax(text2, rightend)

            if leftymin or leftymax or rightymin or rightymax:
                # If any boundaries are offscreen, we have to make estimates.
                if not leftymin:
                    if linenum(text, leftstart) &lt;= top: leftymin = -1
                    else: leftymin = height + 1
                if not leftymax:
                    if linenum(text, leftend) &lt;= top: leftymax = -1
                    else: leftymax = height + 1
                if not rightymin:
                    if linenum(text2, rightstart) &lt;= top2: rightymin = -1
                    else: rightymin = height + 1
                if not rightymax:
                    if linenum(text2, rightend) &lt;= top2: rightymax = -1
                    else: rightymax = height + 1

                lefty = (leftymin + leftymax)/2
                righty = (rightymin + rightymax)/2
                self.trans_canvas.coords(id, 0, lefty, width, righty)

            else:
                self.trans_canvas.coords(id, -1, -1, -1, -1)

    def eh_configcanvas(self, event):
        self.updatelines()

    def cb_compare(self):
        if self.comparing:
            self.compare_off()
        else:
            self.compare_on()

    def cb_closedoc(self, *args):
        try: self.compare_off()
        except TclError: pass

    def updatecompare(self, *args):
        """Activate the "compare" button only when both browser panes
        contain documents that are open for reading but not editing."""
        if self.browser and self.browser2:
            if self.browser.docid and self.browser2.docid and \
               not self.browser.editable and not self.browser2.editable:
                self.compare_btn.config(state=NORMAL)
            else:
                self.compare_btn.config(state=DISABLED)

    def compare_on(self):
        """Turn on the display of transpointing lines."""
        self.trans_canvas.delete("all")
        self.trans_canvas.config(background="darkgrey")

        # note: back-end seems to return bogus results if either document
        # contains more than one virtual copy of the same span of text
        self.sharedspans = self.xs.compare_versions(self.browser.textspec,
                                                    self.browser2.textspec)
        index = 0
        self.translines = []
        for leftspan, rightspan in self.sharedspans:
            colour = self.commoncolours[index % len(self.commoncolours)]

            start, end = self.browser.doc_text.indices(leftspan.span)
            tag = "left-%d" % index
            self.browser.doc_text.tag_add(tag, start, end)
            self.browser.doc_text.tag_configure(tag, background=colour)

            start, end = self.browser2.doc_text.indices(rightspan.span)
            tag = "right-%d" % index
            self.browser2.doc_text.tag_add(tag, start, end)
            self.browser2.doc_text.tag_configure(tag, background=colour)
            index = index + 1

            id = self.trans_canvas.create_line(0, 50, 100, 50)
            self.trans_canvas.itemconfigure(id, width=2, fill=colour)
            self.translines.append(id)

        self.updatelines()

        self.trans_canvas.bind("&lt;Configure&gt;", self.eh_configcanvas)
        for browser in self.browser, self.browser2:
            browser.listen("edit", self.updatelines)
            browser.listen("scroll", self.updatelines)

        self.compare_btn.config(relief=SUNKEN)
        self.comparing = 1

    def compare_off(self):
        """Turn off the display of transpointing lines."""
        for index in range(len(self.sharedspans)):
            self.browser.doc_text.tag_delete("left-%d" % index)
            self.browser2.doc_text.tag_delete("right-%d" % index)
            
        self.trans_canvas.delete("all")
        self.trans_canvas.config(background=DEFAULTBG)
        self.trans_canvas.bind("&lt;Configure&gt;", "")
        for browser in self.browser, self.browser2:
            browser.unlisten("edit", self.updatelines)
            browser.unlisten("scroll", self.updatelines)

        self.compare_btn.config(relief=RAISED)
        self.updatecompare()
        self.comparing = 0

    def eh_destroy(self, event):
        if event.widget is not self: return
        if self.browser2 is not None:
            try: self.browser2.closedoc()
            except (IOError, x88.XuError): pass
        BrowserWindow.eh_destroy(self, event)

if __name__ == "__main__":
    print "Pyxi (Python Udanax Interface) v" + str(VERSION)
    print "Copyright 1999 by Ka-Ping Yee.  All rights reserved."
    print "This program and the Udanax Green hypertext server are part of the"
    print "Udanax project.  Please see http://www.udanax.com/ for details."
    print

    dir = os.getcwd()
    if not os.path.isdir("be"):
        print "There is no directory named \"be\" in which to run the Udanax"
        print "server.  Please create it, and also create the file (or link)"
        print "be/backend (the back-end executable)."
        sys.exit(1)
    if not os.path.isfile("be/backend"):
        print "There is no file at be/backend.  Please put a copy or a link"
        print "to the server executable there."
        sys.exit(1)
    if not os.path.exists("be/enf.enf"):
        print "No enfilade file at be/enf.enf; copying in the default."
        os.system("cp -f ../enfs/sample.enf be/enf.enf")
        
    os.chdir("be")

    import getopt
    opts, extra = getopt.getopt(sys.argv[1:], ":dst")
    if ('-d', '') in opts:
        ps = x88.DebugWrapper(x88.PipeStream("./backend"), sys.stderr)
        xc = x88.DebugWrapper(x88.XuConn(ps), sys.stderr)
        xs = x88.DebugWrapper(x88.XuSession(xc), sys.stderr)
    elif ('-s', '') in opts:
        
        port = 55146
        host = "ooba"
        ps = x88.DebugWrapper(x88.TcpStream(host,port), sys.stderr)
        xc = x88.DebugWrapper(x88.XuConn(ps), sys.stderr)
        xs = x88.DebugWrapper(x88.XuSession(xc), sys.stderr)
#        ps.write("34~0.1.0.1.1~")
    elif ('-t', '') in opts:
        port = 55146
        host = "ooba"
        xs = x88.tcpconnect(host,port)
    else:
        xs = x88.pipeconnect("./backend")
    os.chdir(dir)

    Tk().withdraw()
    clipboard = Clipboard(xs)
    windows = {}
    window = TwoBrowserWindow(xs)
    addr = (extra + ["1.1.0.1.0.1"])[0]
    #window.browser.goto(x88.Address(addr))
    mainloop()
    for window in windows.keys():
        window.quit()
    xs.quit()

</t>
<t tx="rodrigob.121403173614.387">@language python

# The code for Leo's Compare Panel and the compare class.

from leoGlobals import *
import difflib,filecmp,os,string
import Tkinter,tkFileDialog

@others

if __name__ == "__main__":
    pass</t>
<t tx="rodrigob.121403173614.388">def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="rodrigob.121403173614.389">def go ():

    cmp = leoCompare(
        commands = None,
        
        appendOutput = true,

        ignoreBlankLines = true,
        ignoreFirstLine1 = false,
        ignoreFirstLine2 = false,
        ignoreInteriorWhitespace = false,
        ignoreLeadingWhitespace = true,
        ignoreSentinelLines = false,
        
        limitCount = 9, # Zero means don't stop.
        limitToExtension = ".py",  # For directory compares.
        makeWhitespaceVisible = true,
        
        printBothMatches = false,
        printMatches = false,
        printMismatches = true,
        printTrailingMismatches = false,

        outputFileName = None)

    if 1: # Compare all files in Tangle test directories

        path1 = "c:\\prog\\test\\tangleTest\\"
        path2 = "c:\\prog\\test\\tangleTestCB\\"
        cmp.compare_directories(path1,path2)

    else: # Compare two files.

        name1 = "c:\\prog\\test\\compare1.txt"
        name2 = "c:\\prog\\test\\compare2.txt"
        cmp.compare_files(name1,name2)</t>
<t tx="rodrigob.121403173614.390">class leoCompare:
    @others</t>
<t tx="rodrigob.121403173614.391"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

    # Keyword arguments are much convenient and more clear for scripts.
    commands = None,
    
    appendOutput = false,

    ignoreBlankLines = true,
    ignoreFirstLine1 = false,
    ignoreFirstLine2 = false,
    ignoreInteriorWhitespace = false,
    ignoreLeadingWhitespace = true,
    ignoreSentinelLines = false,

    limitCount = 0, # Zero means don't stop.
    limitToExtension = ".py",  # For directory compares.
    makeWhitespaceVisible = true,

    printBothMatches = false,
    printMatches = false,
    printMismatches = true,
    printTrailingMismatches = false,

    outputFileName = None ):
        
    # It is more convenient for the leoComparePanel to set these directly.
    self.commands = commands
    
    self.appendOutput = appendOutput

    self.ignoreBlankLines = ignoreBlankLines
    self.ignoreFirstLine1 = ignoreFirstLine1
    self.ignoreFirstLine2 = ignoreFirstLine2
    self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
    self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
    self.ignoreSentinelLines = ignoreSentinelLines

    self.limitCount = limitCount
    self.limitToExtension = limitToExtension

    self.printBothMatches = printBothMatches
    self.printMatches = printMatches
    self.printMismatches = printMismatches
    self.printTrailingMismatches = printTrailingMismatches
    
    # For communication between methods...
    self.outputFileName = outputFileName
    self.fileName1 = None 
    self.fileName2 = None
    # Open files...
    self.outputFile = None</t>
<t tx="rodrigob.121403173614.392"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = os.path.dirname(path1)
    dir2 = os.path.dirname(path2)
    dir1 = os.path.normpath(dir1)
    dir2 = os.path.normpath(dir2)
    
    if dir1 == dir2:
        self.show("Directory names are identical.\nPlease pick distinct directories.")
        return
        
    try:
        list1 = os.listdir(dir1)
    except:
        self.show("invalid directory:" + dir1)
        return
    try:
        list2 = os.listdir(dir2)
    except:
        self.show("invalid directory:" + dir2)
        return
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok:
        return

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = os.path.splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = os.path.splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and fail lists.
    yes = [] ; no = [] ; fail = []
    for f1 in files1:
        head,f2 = os.path.split(f1)
        if f2 in files2:
            try:
                name1 = os.path.join(dir1,f1)
                name2 = os.path.join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                es_exception()
                fail.append(f1)
        else:
            fail.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found ------",fail)):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None</t>
<t tx="rodrigob.121403173614.393">def compare_files (self, name1, name2):
    
    if name1 == name2:
        self.show("File names are identical.\nPlease pick distinct files.")
        return

    f1 = f2 = None
    try:
        f1 = self.doOpen(name1)
        f2 = self.doOpen(name2)
        if self.outputFileName:
            self.openOutputFile()
        ok = self.outputFileName == None or self.outputFile
        ok = choose(ok and ok != 0,1,0)
        if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
            self.compare_open_files(f1,f2,name1,name2)
    except:
        self.show("exception comparing files")
        es_exception()
    try:
        if f1: f1.close()
        if f2: f2.close()
        if self.outputFile:
            self.outputFile.close() ; self.outputFile = None
    except:
        self.show("exception closing files")
        es_exception()</t>
<t tx="rodrigob.121403173614.394">def compare_lines (self,s1,s2):
    
    if self.ignoreLeadingWhitespace:
        s1 = string.lstrip(s1)
        s2 = string.lstrip(s2)

    if self.ignoreInteriorWhitespace:
        k1 = skip_ws(s1,0)
        k2 = skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = string.replace(tail1," ","")
        tail1 = string.replace(tail1,"\t","")
        tail2 = string.replace(tail2," ","")
        tail2 = string.replace(tail2,"\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2</t>
<t tx="rodrigob.121403173614.395">def compare_open_files (self, f1, f2, name1, name2):

    # self.show("compare_open_files")
    lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = true
    sentinelComment1 = sentinelComment2 = None
    if self.openOutputFile():
        self.show("1: " + name1)
        self.show("2: " + name2)
        self.show("")
    s1 = s2 = None
    &lt;&lt; handle opening lines &gt;&gt;
    while 1:
        if s1 == None:
            s1 = readlineForceUnixNewline(f1) ; lines1 += 1
        if s2 == None:
            s2 = readlineForceUnixNewline(f2) ; lines2 += 1
        &lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
        n1 = len(s1) ; n2 = len(s2)
        if n1==0 and n2 != 0: self.show("1.eof***:")
        if n2==0 and n1 != 0: self.show("2.eof***:")
        if n1==0 or n2==0: break
        match = self.compare_lines(s1,s2)
        if not match: mismatches += 1
        &lt;&lt; print matches and/or mismatches &gt;&gt;
        &lt;&lt; warn if mismatch limit reached &gt;&gt;
        s1 = s2 = None # force a read of both lines.
    &lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</t>
<t tx="rodrigob.121403173614.396">if self.ignoreSentinelLines:
    
    s1 = readlineForceUnixNewline(f1) ; lines1 += 1
    s2 = readlineForceUnixNewline(f2) ; lines2 += 1
    # Note: isLeoHeader may return None.
    sentinelComment1 = self.isLeoHeader(s1)
    sentinelComment2 = self.isLeoHeader(s2)
    if not sentinelComment1: self.show("no @+leo line for " + name1)
    if not sentinelComment2: self.show("no @+leo line for " + name2)
        
if self.ignoreFirstLine1:
    if s1 == None:
        readlineForceUnixNewline(f1) ; lines1 += 1
    s1 = None

if self.ignoreFirstLine2:
    if s2 == None:
        readlineForceUnixNewline(f2) ; lines2 += 1
    s2 = None</t>
<t tx="rodrigob.121403173614.397"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
    if self.ignoreBlankLines and len(string.strip(s1)) == 0:
        s1 = None ; continue
        
    if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
        s1 = None ; continue

if s2 and len(s2) &gt; 0:
    if self.ignoreBlankLines and len(string.strip(s2)) == 0:
        s2 = None ; continue

    if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
        s2 = None ; continue
</t>
<t tx="rodrigob.121403173614.398">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

    if match and self.printMatches:
        
        if self.printBothMatches:
            self.dump(string.rjust("1." + `lines1`,6) + ' :',s1)
            self.dump(string.rjust("2." + `lines2`,6) + ' :',s2)
        else:
            self.dump(string.rjust(       `lines1`,6) + ' :',s1)
    
    if not match and self.printMismatches:
        
        self.dump(string.rjust("1." + `lines1`,6) + '*:',s1)
        self.dump(string.rjust("2." + `lines2`,6) + '*:',s2)</t>
<t tx="rodrigob.121403173614.399">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:
    
    if printTrailing:
        self.show("")
        self.show("limit count reached")
        self.show("")
        printTrailing = false</t>
<t tx="rodrigob.121403173614.400">if n1 &gt; 0: 
    lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)
    
if n2 &gt; 0:
    lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + `lines1`)
self.show("lines2:" + `lines2`)
self.show("mismatches:" + `mismatches`)</t>
<t tx="rodrigob.121403173614.401">def filecmp (self,f1,f2):

    val = filecmp.cmp(f1,f2)
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(`val` + " (equal)")
        else:   self.show(`val` + " (not equal)")
    return val</t>
<t tx="rodrigob.121403173614.402"></t>
<t tx="rodrigob.121403173614.403">def doOpen (self,name):

    try:
        f = open(name,'r')
        return f
    except:
        self.show("can not open:" + '"' + name + '"')
        return None</t>
<t tx="rodrigob.121403173614.404">def dump (self,tag,s):

    cmp = self ; out = tag

    for ch in s[:-1]: # don't print the newline
    
        if cmp.makeWhitespaceVisible:
            if ch == '\t':
                out += "[" ; out += "t" ; out += "]"
            elif ch == ' ':
                out += "[" ; out += " " ; out += "]"
            else: out += ch
        else:
            if 1:
                out += ch
            else: # I don't know why I thought this was a good idea ;-)
                if ch == '\t' or ch == ' ':
                    out += ' '
                else:
                    out += ch

    self.show(out)</t>
<t tx="rodrigob.121403173614.405">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

    trailingLines = 0
    while 1:
        if not s:
            s = readlineForceUnixNewline(f)
        if len(s) == 0: break
        trailingLines += 1
        if self.printTrailingMismatches and printTrailing:
            tag2 = string.rjust(tag + `line`,6) + "+:"
            self.dump(tag2,s)
        s = None

    self.show(tag + `trailingLines` + " trailing lines")
    return trailingLines</t>
<t tx="rodrigob.121403173614.406">@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

    tag = "@+leo"
    j = string.find(s,tag)
    if j &gt; 0:
        i = skip_ws(s,0)
        if i &lt; j: return s[i:j]
        else: return None
    else: return None
        
def isSentinel (self,s,sentinelComment):

    i = skip_ws(s,0)
    return match(s,i,sentinelComment)</t>
<t tx="rodrigob.121403173614.407">def openOutputFile (self):
    
    if self.outputFileName == None:
        return
    dir,name = os.path.split(self.outputFileName)
    if len(dir) == 0:
        self.show("empty output directory")
        return
    if len(name) == 0:
        self.show("empty output file name")
        return
    if not os.path.exists(dir):
        self.show("output directory not found: " + dir)
    else:
        try:
            if self.appendOutput:
                self.show("appending to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"ab")
            else:
                self.show("writing to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"wb")
        except:
            self.outputFile = None
            self.show("exception opening output file")
            es_exception()</t>
<t tx="rodrigob.121403173614.408">def show (self,s):
    
    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.commands:
        es(s)
    else:
        print s
        print</t>
<t tx="rodrigob.121403173614.409">def showIvars (self):
    
    self.show("fileName1:"        + `self.fileName1`)
    self.show("fileName2:"        + `self.fileName2`)
    self.show("outputFileName:"   + `self.outputFileName`)
    self.show("limitToExtension:" + `self.limitToExtension`)
    self.show("")

    self.show("ignoreBlankLines:"         + `self.ignoreBlankLines`)
    self.show("ignoreFirstLine1:"         + `self.ignoreFirstLine1`)
    self.show("ignoreFirstLine2:"         + `self.ignoreFirstLine2`)
    self.show("ignoreInteriorWhitespace:" + `self.ignoreInteriorWhitespace`)
    self.show("ignoreLeadingWhitespace:"  + `self.ignoreLeadingWhitespace`)
    self.show("ignoreSentinelLines:"      + `self.ignoreSentinelLines`)
    self.show("")
    
    self.show("limitCount:"              + `self.limitCount`)
    self.show("printMatches:"            + `self.printMatches`)
    self.show("printMismatches:"         + `self.printMismatches`)
    self.show("printTrailingMismatches:" + `self.printTrailingMismatches`)</t>
<t tx="rodrigob.121403173614.410">class leoComparePanel:
    @others</t>
<t tx="rodrigob.121403173614.411">def browser (self,n):
    
    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]

    fileName = tkFileDialog.askopenfilename(
        title="Choose compare file" + n,
        filetypes=types,
        defaultextension=".txt")
        
    if fileName and len(fileName) &gt; 0:
        # The dialog also warns about this, so this may never happen.
        if not os.path.exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None
        
    return fileName</t>
<t tx="rodrigob.121403173614.412">def __init__ (self,c,cmp):

    Tk = Tkinter
    self.commands = c
    self.cmp = cmp
    
    # Ivars pointing to Tk elements.
    self.browseEntries = []
    self.extensionEntry = None
    self.countEntry = None
    self.printButtons = []
    
    # No corresponding cmp ivar.
    self.useOutputFileVar = Tk.IntVar()
    
    # These all correspond to ivars in leoCompare.
    self.appendOutputVar             = Tk.IntVar()

    self.ignoreBlankLinesVar         = Tk.IntVar()
    self.ignoreFirstLine1Var         = Tk.IntVar()
    self.ignoreFirstLine2Var         = Tk.IntVar()
    self.ignoreInteriorWhitespaceVar = Tk.IntVar()
    self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
    self.ignoreSentinelLinesVar      = Tk.IntVar()

    self.limitToExtensionVar         = Tk.IntVar()
    self.makeWhitespaceVisibleVar    = Tk.IntVar()
    
    self.printBothMatchesVar         = Tk.IntVar()
    self.printMatchesVar             = Tk.IntVar()
    self.printMismatchesVar          = Tk.IntVar()
    self.printTrailingMismatchesVar  = Tk.IntVar()
    self.stopAfterMismatchVar        = Tk.IntVar()
    
    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None 
    if 0: # we just use the cmp ivars.
        self.pathName1 = None
        self.pathName2 = None
        self.outputFileName = None
    
    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"</t>
<t tx="rodrigob.121403173614.413"># Initialize ivars from config parameters.

def finishCreate (self):

    config = app().config
    
    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):
            
        name = config.getComparePref(option)
        if name and len(name) &gt; 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)
            
    name = config.getComparePref("output_file")
    b = choose(name and len(name) &gt; 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = config.getBoolComparePref("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)
    
    b = config.getBoolComparePref("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)
    
    b = config.getBoolComparePref("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = config.getComparePref("limit_directory_search_extension")
    b = ext and len(ext) &gt; 0
    b = choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        e.delete(0,"end")
        e.insert(0,ext)
        
    # Print options.
    b = config.getBoolComparePref("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)
    
    b = config.getBoolComparePref("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)
    
    b = config.getBoolComparePref("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)
    
    b = config.getBoolComparePref("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)
    
    n = config.getIntComparePref("limit_count")
    b = n and n &gt; 0
    b = choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.delete(0,"end")
        e.insert(0,`n`)

    # Whitespace options.
    b = config.getBoolComparePref("ignore_blank_lines")
    if b == None: b = 1 # unusual default.
    self.ignoreBlankLinesVar.set(b)
    
    b = config.getBoolComparePref("ignore_interior_whitespace")
    if b == None: b = 0
    self.ignoreInteriorWhitespaceVar.set(b)
    
    b = config.getBoolComparePref("ignore_leading_whitespace")
    if b == None: b = 0
    self.ignoreLeadingWhitespaceVar.set(b)
    
    b = config.getBoolComparePref("ignore_sentinel_lines")
    if b == None: b = 0
    self.ignoreSentinelLinesVar.set(b)
    
    b = config.getBoolComparePref("make_whitespace_visible")
    if b == None: b = 0
    self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="rodrigob.121403173614.414">def run (self):

    import leoApp, leoCommands

    c = self.commands ; cmp = self.cmp ; Tk = Tkinter
    self.top = top = Tk.Toplevel(app().root)
    top.title("Compare files and directories (" + shortFileName(c.frame.title) + ")")
    top.protocol("WM_DELETE_WINDOW", self.onClose)
    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;
    center_dialog(top) # Do this _after_ building the dialog!
    top.resizable(0,0)
    self.finishCreate()</t>
<t tx="rodrigob.121403173614.415">outer = Tk.Frame(top, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="rodrigob.121403173614.416">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)
    
    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)
    
    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")</t>
<t tx="rodrigob.121403173614.417">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="rodrigob.121403173614.418">w,f = create_labeled_frame(ws,caption="Whitespace options",relief="groove")
    
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")
    
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="rodrigob.121403173614.419">w,f = create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)
    
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="rodrigob.121403173614.420">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)</t>
<t tx="rodrigob.121403173614.421">def show (self,s):
    
    self.cmp.show(s)</t>
<t tx="rodrigob.121403173614.422">def setIvarsFromWidgets (self):

    cmp = self.cmp
    
    # File paths. cmp checks for valid file name.
    e = self.browseEntries[0]
    cmp.fileName1 = e.get()
    
    e = self.browseEntries[1]
    cmp.fileName2 = e.get()

    # Ignore first line settings.
    cmp.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    cmp.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
    
    # Output file.  cmp checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.get()
        if name != None and len(name) == 0:
            name = None
        cmp.outputFileName = name
    else:
        cmp.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        cmp.limitToExtension = self.extensionEntry.get()
        if len(cmp.limitToExtension) == 0:
            cmp.limitToExtension = None
    else:
        cmp.limitToExtension = None
        
    cmp.appendOutput = self.appendOutputVar.get()
    
    # Whitespace options.
    cmp.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    cmp.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    cmp.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    cmp.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    cmp.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
    
    # Print options.
    cmp.printMatches            = self.printMatchesVar.get()
    cmp.printMismatches         = self.printMismatchesVar.get()
    cmp.printTrailingMismatches = self.printTrailingMismatchesVar.get()
    
    if cmp.printMatches:
        cmp.printBothMatches = self.printBothMatchesVar.get()
    else:
        cmp.printBothMatches = false
    
    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            cmp.limitCount = int(count)
        except: cmp.limitCount = 0
    else:
        cmp.limitCount = 0</t>
<t tx="rodrigob.121403173614.423"></t>
<t tx="rodrigob.121403173614.424">def onBrowse1 (self):
    
    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()
    
def onBrowse2 (self):
    
    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()
    
def onBrowse3 (self): # Get the name of the output file.

    fileName = tkFileDialog.asksaveasfilename(
        initialfile = self.defaultOutputFileName,
        title="Set output file",
        filetypes=[("Text files", "*.txt")],
        defaultextension=".txt")
        
    if fileName and len(fileName) &gt; 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.delete(0,"end")
        e.insert(0,fileName)</t>
<t tx="rodrigob.121403173614.425">def onClose (self):
    
    self.top.withdraw()</t>
<t tx="rodrigob.121403173614.426">def onCompareDirectories (self):

    cmp = self.cmp
    self.setIvarsFromWidgets()
    cmp.compare_directories(cmp.fileName1,cmp.fileName2)

def onCompareFiles (self):

    cmp = self.cmp
    self.setIvarsFromWidgets()
    cmp.compare_files(cmp.fileName1,cmp.fileName2)</t>
<t tx="rodrigob.121403173614.427">def onPrintMatchedLines (self):
    
    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = choose(v,"normal","disabled")
    b.configure(state=state)</t>
<t tx="rodrigob.121403173614.428"></t>
<t tx="rodrigob.121403173614.429">#!/usr/bin/python
# Copyright (c) 2000 LOGILAB S.A. (Paris, FRANCE).
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

__revision__ = '$Id: xmldiff.py,v 1.29 2002/11/06 09:37:01 syt Exp $'

import sys

def usage(pgm):
    print 'USAGE:'
    print "\t"+pgm, '[OPTIONS] from_file to_file'
    print "\t"+pgm, '[OPTIONS] [-r] from_directory to_directory'
    print """OPTIONS: 
  -h, --help
     display this help message and exit.
  -V, --version
     display version number and exit

  -H, --html
     input files are HTML instead of XML
  -r, --recursive
     when comparing directories, recursively compare any
     subdirectories found.
     
  -x, --xupdate
     display output following the Xupdate xml specification 
     (see http://www.xmldb.org/xupdate/xupdate-wd.html#N19b1de).
  -e encoding, --encoding=encoding
     specify the encoding to use for output. Default is UTF-8

  -n, --not-normalize-spaces
     do not normalize spaces and new lines in text and comment nodes.
  -c, --exclude-comments
     do not process comment nodes
  -g, --ext-ges
     include all external general (text) entities. 
  -p, --ext-pes
     include all external parameter entities, including the external DTD
     subset. 

  --profile=file
     display an execution profile (run slower with this option),
     profile saved to file (binarie form).
"""
##   -z, --ezs
##      use the extended Zhang and Shasha algorithm, much slower
##      but with the best results (only for small documents) 

def process_files(file1, file2, norm_sp, xupd, ezs, verbose,
                  ext_ges, ext_pes, include_comment, encoding,
                  html):
    from xml.sax import SAXParseException
    try:
        fh1, fh2 = open(file1, 'r'), open(file2, 'r')
    except IOError, msg :
        sys.stderr.write('Unable to open ' + msg + '\n')
        return -1
    # convert xml files to tree
    try:
        from input import tree_from_stream
        tree1 = tree_from_stream(fh1, norm_sp, ext_ges, ext_pes, include_comment,
                                 encoding, html)
        tree2 = tree_from_stream(fh2, norm_sp, ext_ges, ext_pes, include_comment,
                                 encoding, html)
        fh1.close (); fh2.close ()
    except SAXParseException, msg:
        print msg
        return -1

    if verbose:
        from objects import repr, N_ISSUE, N_CHILDS
        print "Source tree\n", repr(tree1)
        print "Destination tree\n", repr(tree2)
        print 'Source tree has', tree1[N_ISSUE], 'nodes'
        print 'Destination tree has', tree2[N_ISSUE], 'nodes'
    # output formatter
    if xupd:
        from format import XUpdatePrinter
        formatter = XUpdatePrinter()
    else:
        from format import InternalPrinter
        formatter = InternalPrinter()
    # choose and apply tree to tree algorithm
    if ezs:
        from ezs import EzsCorrector
        strategy = EzsCorrector(formatter)
    else:
        from fmes import FmesCorrector
        #import gc
        #gc.set_debug(gc.DEBUG_LEAK|gc.DEBUG_STATS)
        strategy = FmesCorrector(formatter)
    strategy.process_trees(tree1, tree2)
    return len(formatter.edit_s)

def run(*args):
    import os, getopt
    pgm = args[0]
    s_opt = 'Hrncgpe:xzhvV'
    l_opt = ['html', 'recursive',
             'not-normalize-space','exclude-comments','ext-ges','ext-pes'
             'encoding=', 'xupdate',
             'ezs', # DEPRICATED
             'help', 'verbose', 'version', 'profile=']
    # process command line options
    try:
        (opt, args) = getopt.getopt(args[1:], s_opt, l_opt)
    except getopt.error:
        sys.stderr.write ('Unkwnown option')
        usage(pgm)
        sys.exit(-1)
    recursive, html = 0, 0
    xupd, ezs, verbose= 0, 0, 0
    norm_sp, include_comment, ext_ges, ext_pes = 1, 1, 0, 0
    encoding = 'UTF-8'
    prof = ''
    for o in opt:
        if o[0] == '-r' or o[0] == '--recursive':
            recursive = 1
        elif o[0] == '-H' or o[0] == '--html':
            html = 1
        elif o[0] == '-n' or o[0] == '--not-normalize-space':
            norm_sp = 0
        elif o[0] == '-c' or o[0] == '--exclude-comments':
            include_comment = 0
        elif o[0] == '-g' or o[0] == '--ext-ges':
            ext_ges = 1
        elif o[0] == '-p' or o[0] == '--ext-pes':
            ext_pes = 1
        elif o[0] == '-e' or o[0] == '--encoding':
            encoding = o[1] 
        elif o[0] == '-x' or o[0] == '--xupdate':
            xupd = 1
        elif o[0] == '-z' or o[0] == '--ezs':
            ezs = 1
        elif o[0] == '-v' or o[0] == '--verbose':
            verbose = 1
        elif o[0] == '-p' or o[0] == '--profile':
            prof = o[1] 
        elif o[0] == '-h' or o[0] == '--help':
            usage(pgm)
            sys.exit(0)
        elif o[0] == '-V' or o[0] == '--version':
            from __init__ import modname, version
            print '%s version %s' % (modname, version)
            sys.exit(0)
    if len(args) != 2:
        usage(pgm)
        sys.exit(-2)
    file1, file2 = args[0], args[1]
    exit_status = 0
    # if args are directory    
    if os.path.isdir(file1) and os.path.isdir(file2):
        from misc import process_dirs, list_print
        common, deleted, added = process_dirs(file1, file2, recursive)
        
        list_print(deleted[0], 'FILE:', 'deleted')
        list_print(deleted[1], 'DIRECTORY:', 'deleted')
        list_print(added[0], 'FILE:', 'added')
        list_print(added[1], 'DIRECTORY:', 'added')
        exit_status += len(deleted[0])+len(deleted[1])+len(added[0])+len(added[1])
        for file in common[0]:
            print '-'*80
            print 'FILE:', file
            diffs = process_files(os.path.join(file1, file), os.path.join(file2, file),
                                  norm_sp, xupd, ezs, verbose,
                                  ext_ges, ext_pes, include_comment, encoding, html)
            if diffs:
                exit_status += diffs
    # if  args are files
    elif os.path.isfile(file1) and os.path.isfile(file2):
        if prof:
            import profile, pstats, time
            t = time.clock()
            profile.run('process_files(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'% (
              repr(file1), repr(file2), repr(norm_sp), repr(xupd),
              repr(ezs), repr(verbose), repr(ext_ges), repr(ext_pes),
              repr(include_comment),repr(encoding), repr(html)),
                        prof)
            print 'Time:',`time.clock()-t`
            p = pstats.Stats(prof)
            p.sort_stats('time','calls').print_stats(.25)
            p.sort_stats('cum','calls').print_stats(.25)
            
        else:
            exit_status = process_files(file1, file2, norm_sp, xupd, ezs, verbose,
                                        ext_ges, ext_pes, include_comment, encoding, html)
    else:
        exit_status = -1
        print file1, 'and', file2,\
              'are not comparable, or not directory nor regular files'
    sys.exit(exit_status)
    
if __name__ == '__main__':
    run(*sys.argv)
</t>
<t tx="rodrigob.121403173614.430"># Copyright (c) 2000 LOGILAB S.A. (Paris, FRANCE).
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""
this module provides classes to format the native tree2tree output
"""
__revision__ = '$Id: format.py,v 1.24 2002/11/06 09:37:01 syt Exp $'

import types
try:
    from xml.dom import EMPTY_NAMESPACE as NO_NS
except:
    NO_NS = None
from objects import A_N1, A_N2, A_DESC, N_PARENT, caract, xml_print, f_xpath,\
     XUPD_PREFIX, XUPD_URI, to_dom

def get_attrs_string(attrs):
    """ extract and return a string corresponding to an attributes list """
    attr_s = []
    for attr_n, attr_v in attrs:
        attr_s.append('%s="%s" '%(attr_n, attr_v))
    return ' '.join(attr_s)

## XUPDATE FUNCTIONS ###########################################################

def open_xupdate_node(type, attrs, indent=''):
    print '%s&lt;%s:%s %s&gt;'%(indent, XUPD_PREFIX, type, get_attrs_string(attrs))

def close_xupdate_node(action, indent=''):
    print '%s&lt;/%s:%s&gt;'%(indent, XUPD_PREFIX, action)

def write_xupdate_node(type, attrs, indent=''):
    print '%s&lt;%s:%s %s/&gt;'%(indent, XUPD_PREFIX, type, get_attrs_string(attrs))
    

## Formatter interface #########################################################
class AbstractFormatter:

    def init(self):
        """ method called before the begining of the tree 2 tree correction """
        self.edit_s = []
    
    def add_action(self, action):
        """ method called when an action is added to the edit script """
        self.edit_s.append(action)

    def format_action(self, action):
        """ method called by end() to format each action in the edit script
        at least this method should be overriden
        """
        raise NotImplementedError()

    def end(self):
        """ method called at the end of the tree 2 tree correction """
        for action in self.edit_s:
            self.format_action(action)


## Internal Formatter ##########################################################

class InternalPrinter(AbstractFormatter):
    """ print actions in the internal format """
    
    def add_action(self, action):
        if len(action) &gt; 2 and type(action[A_N2]) == types.ListType:
            if type(action[A_N1]) == types.ListType:
                #swap or move node
                action[A_N1] = f_xpath(action[A_N1])
                action[A_N2] = f_xpath(action[A_N2])
        AbstractFormatter.add_action(self, action)
        
    def format_action(self, action):
        if len(action) &gt; 2 and type(action[A_N2]) == types.ListType:
            print '[%s, %s,' % (action[A_DESC], action[A_N1])
            xml_print(action[A_N2])
            print "]"
        elif len(action) &gt; 2:
            print '[%s, %s, %s]' % (action[A_DESC], action[A_N1], action[A_N2])
        else:
            print '[%s, %s]' % (action[A_DESC], action[A_N1])

## XUpdate Formatters (text / DOM) #############################################

class XUpdateMixIn:
    """ XUpdate mixin to preprocess added actions """

    def add_action(self, action):
        if action[A_DESC] == 'move-first':
            # replace move-first with remove and insert (sibling nodes)
            self.edit_s.append(('remove', f_xpath(action[A_N1])))
            self.edit_s.append(('append', f_xpath(action[A_N2]), action[A_N1]))
        elif action[A_DESC] == 'move-after':
            # replace move-after with remove and insert (sibling nodes)
            self.edit_s.append(('remove', f_xpath(action[A_N1])))
            self.edit_s.append(('insert-after', f_xpath(action[A_N2]), action[A_N1]))
        elif action[A_DESC] == 'move-and-rename':
            # replace move-and-rename with remove and append (attribute nodes)
            self.edit_s.append(('remove', f_xpath(action[A_N1])))
            self.edit_s.append(('append', f_xpath(action[A_N2][N_PARENT]), action[A_N2]))
        elif action[A_DESC] == 'swap':
            # replace swap with remove and insert (sibling nodes)
            self.edit_s.append(('remove', f_xpath(action[A_N2])))
            self.edit_s.append(('insert-after', f_xpath(action[A_N1]), action[A_N2]))
        else:
            self.edit_s.append(action)

        
class XUpdatePrinter(XUpdateMixIn, AbstractFormatter):
    """ take the actions list in standard format and output it following
    Xupdate xml specification
    """
    def init(self):
        AbstractFormatter.init(self)
        print '''&lt;?xml version="1.0"?&gt; 
&lt;xupdate:modifications version="1.0"
 xmlns:%s="%s"&gt;
''' % (XUPD_PREFIX, XUPD_URI)
        
    def format_action(self, action):
        if action[A_DESC] == 'remove': 
            write_xupdate_node(action[A_DESC], (('select', action[A_N1]),), '  ')
        elif action[A_DESC] == 'append-last':
            open_xupdate_node('append', (('select', action[A_N1]), ('child', 'last()')), '  ')
            xml_print(action[A_N2], '    ', xupdate=1)
            close_xupdate_node('append', '  ')
        elif action[A_DESC] == 'append-first':
            open_xupdate_node('append', (('select', action[A_N1]), ('child', 'first()')), '  ')
            xml_print(action[A_N2], '    ', xupdate=1)
            close_xupdate_node('append', '  ')
        elif action[A_DESC] in ['append', 'insert-after']:
            open_xupdate_node(action[A_DESC], (('select', action[A_N1]),), '  ')
            xml_print(action[A_N2], '    ', xupdate=1)
            close_xupdate_node(action[A_DESC], '  ')
        elif action[A_DESC] == 'rename': 
            open_xupdate_node(action[A_DESC], (('select', action[A_N1]),), '  ')
            print action[A_N2]
            close_xupdate_node(action[A_DESC], '  ')
        else:
            open_xupdate_node(action[A_DESC], (('select', action[A_N1]),), '  ')
            print action[A_N2]
            close_xupdate_node(action[A_DESC], '  ')
        print

    def end(self):
        AbstractFormatter.end(self)
        print '&lt;/%s:modifications&gt;'%XUPD_PREFIX


class DOMXUpdateFormatter(XUpdateMixIn, AbstractFormatter):
    """ take the actions list in standard format and return a dom tree
    which follow Xupdate xml specification (without xupdate namespace)
    dom tree is append to doc (DOM Document node)
    """
    def __init__(self, doc, encoding='UTF-8'):
        self.doc = doc
        self.encoding = encoding
        
    def init(self):
        AbstractFormatter.init(self)
        output = self.doc.createElementNS(XUPD_URI, '%s:modifications'%XUPD_PREFIX)
        output.setAttributeNS(NO_NS, 'version', '1.0')
        self.output = output
        
    def format_action(self, action):
        doc = self.doc
        if action[A_DESC] == 'remove':
            node = doc.createElementNS(XUPD_URI, '%s:%s' % (XUPD_PREFIX, action[A_DESC]))
            node.setAttributeNS(NO_NS, 'select', action[A_N1])
        elif action[A_DESC] == 'append-first':
            node = doc.createElementNS(XUPD_URI, '%s:%s'% (XUPD_PREFIX, 'append'))
            node.setAttributeNS(NO_NS, 'select', action[A_N1])
            node.setAttributeNS(NO_NS, 'child', 'first()')
            node.appendChild(to_dom(action[A_N2], doc, XUPD_URI, XUPD_PREFIX))
        elif action[A_DESC] == 'append-last':
            node = doc.createElementNS(XUPD_URI, '%s:%s' % (XUPD_PREFIX, 'append'))
            node.setAttributeNS(NO_NS, 'select', action[A_N1])
            node.setAttributeNS(NO_NS, 'child', 'last()')
            node.appendChild(to_dom(action[A_N2], doc, XUPD_URI, XUPD_PREFIX))
        elif action[A_DESC] in ['append', 'insert-after', 'insert-before']:
            node = doc.createElementNS(XUPD_URI, '%s:%s' % (XUPD_PREFIX, action[A_DESC]))
            node.setAttributeNS(NO_NS, 'select', action[A_N1])
            node.appendChild(to_dom(action[A_N2], doc, XUPD_URI, XUPD_PREFIX))
        elif action[A_DESC] == 'rename': 
            node = doc.createElementNS(XUPD_URI, '%s:%s' %(XUPD_PREFIX, action[A_DESC]))
            node.setAttributeNS(NO_NS, 'name', action[A_N1])
            v = unicode(action[A_N2], self.encoding)
            node.appendChild(doc.createTextNode(v))
        else:
            node = doc.createElementNS(XUPD_URI, '%s:%s' % (XUPD_PREFIX, action[A_DESC]))
            node.setAttributeNS(NO_NS, 'select', action[A_N1])
            v = unicode(action[A_N2], self.encoding)
            node.appendChild(doc.createTextNode(v))
        # append xupdate node
        self.output.appendChild(node)

</t>
<t tx="rodrigob.121403173614.431"></t>
<t tx="rodrigob.121403173614.432"></t>
<t tx="rodrigob.121403173614.433"></t>
<t tx="rodrigob.121403173614.434">
import os
from twisted.internet import app 
from twisted.web.woven import page, input
from twisted.web import server, static, microdom, domhelpers
from twisted.python import components


rootDirectory = os.path.expanduser("./")  #os.path.expanduser("./")  #os.path.expanduser("~/Pictures")


@others
        
site = server.Site(DirectoryListing(directory=rootDirectory))
application = app.Application("ImagePool") 
application.listenTCP(8088, site)

if __name__ == '__main__': 
    import sys               
    from twisted.python import log 
    log.startLogging(sys.stdout, 0) 
    application.run() 

</t>
<t tx="rodrigob.121403173614.435">class IPreferences(components.Interface):
    pass

</t>
<t tx="rodrigob.121403173614.436">class Preferences(components.Adapter):
    __implements__ = IPreferences


components.registerAdapter(Preferences, server.Session, IPreferences)</t>
<t tx="rodrigob.121403173614.437">

class DirectoryListing(page.Page):
    templateFile = "directory-listing4.xhtml"

    @others
</t>
<t tx="rodrigob.121403173614.438">def initialize(self, *args, **kwargs):
    self.directory = kwargs['directory']
</t>
<t tx="rodrigob.121403173614.439">def wmfactory_title(self, request):
  return self.directory
</t>
<t tx="rodrigob.121403173614.440">def wmfactory_directory(self, request):
  files = os.listdir(self.directory)
  for i in xrange(len(files)):
      if os.path.isdir(os.path.join(self.directory,files[i])):
          files[i] = files[i] + '/'
  return files
</t>
<t tx="rodrigob.121403173614.441">def getDynamicChild(self, name, request):
  path = os.path.join(self.directory,name)
  if os.path.exists(path):
      if os.path.isdir(path):
          return DirectoryListing(directory=path)
      else:
          return ImageDisplay(image=path)
</t>
<t tx="rodrigob.121403173614.442">def wvupdate_thumbnail(self, request, node, data):
    prefs = request.getSession(IPreferences)
    size = getattr(prefs, 'size','200')
    a = microdom.lmx(node)
    a['href'] = data
    if os.path.isdir(os.path.join(self.directory,data)):
        a.text(data)
    else:
        a.add('img', src=(data+'/preview'),width=size,height=size)
</t>
<t tx="rodrigob.121403173614.443">def wvupdate_adjuster(self, request, widget, data):
    prefs = request.getSession(IPreferences)
    size = getattr(prefs, 'size','200')
    domhelpers.locateNodes(widget.node.childNodes, 
                           'value', size)[0].setAttribute('selected', '1')
</t>
<t tx="rodrigob.121403173614.444">def wcfactory_adjuster(self, request, node, model):
    return ImageSizer(model, name='thumbnailSize')
</t>
<t tx="rodrigob.121403173614.445">       
class ImageSizer(input.Anything):
    @others
</t>
<t tx="rodrigob.121403173614.446">def handleValid(self, request, data):
    if data:
        prefs = request.getSession(IPreferences)
        prefs.size = data 
</t>
<t tx="rodrigob.121403173614.447">        
class ImageDisplay(page.Page):
    templateFile="image-display.xhtml"

    @others
</t>
<t tx="rodrigob.121403173614.448">def initialize(self, *args, **kwargs):
    self.image = kwargs['image']
</t>
<t tx="rodrigob.121403173614.449">def wmfactory_image(self, request):
    return self.image
</t>
<t tx="rodrigob.121403173614.450">def wchild_preview(self, request):
    return static.File(self.image)
</t>
<t tx="rodrigob.121403173614.451"></t>
<t tx="rodrigob.121403173614.452"></t>
<t tx="rodrigob.121403173614.453">#! /usr/bin/python

from twisted.spread import pb

class MasterDuckPond(pb.Cacheable):
    def __init__(self, ducks):
        self.observers = []
        self.ducks = ducks
    def count(self):
        print "I have [%d] ducks" % len(self.ducks)
    def addDuck(self, duck):
        self.ducks.append(duck)
        for o in self.observers: o.callRemote('addDuck', duck)
    def removeDuck(self, duck):
        self.ducks.remove(duck)
        for o in self.observers: o.callRemote('removeDuck', duck)
    def getStateToCacheAndObserveFor(self, perspective, observer):
        self.observers.append(observer)
        # you should ignore pb.Cacheable-specific state, like self.observers
        return self.ducks # in this case, just a list of ducks
    def stoppedObserving(self, perspective, observer):
        self.observers.remove(observer)

class SlaveDuckPond(pb.RemoteCache):
    # This is a cache of a remote MasterDuckPond
    def count(self):
        return len(self.cacheducks)
    def getDucks(self):
        return self.cacheducks
    def setCopyableState(self, state):
        print " cache - sitting, er, setting ducks"
        self.cacheducks = state
    def observe_addDuck(self, newDuck):
        print " cache - addDuck"
        self.cacheducks.append(newDuck)
    def observe_removeDuck(self, deadDuck):
        print " cache - removeDuck"
        self.cacheducks.remove(deadDuck)

pb.setUnjellyableForClass(MasterDuckPond, SlaveDuckPond)
</t>
<t tx="rodrigob.121403173614.454">#! /usr/bin/python

from twisted.internet.app import Application
from twisted.internet import reactor
from twisted.spread import pb
import cache_classes

class Receiver(pb.Root):
    def remote_takePond(self, pond):
        self.pond = pond
        print "got pond:", pond # a DuckPondCache
        self.remote_checkDucks()
    def remote_checkDucks(self):
        print "[%d] ducks: " % self.pond.count(), self.pond.getDucks()
    def remote_ignorePond(self):
        # stop watching the pond
        print "dropping pond"
        # gc causes __del__ causes 'decache' msg causes stoppedObserving
        self.pond = None
    def remote_shutdown(self):
        reactor.stop()

app = Application("copy_receiver")
app.listenTCP(8800, pb.BrokerFactory(Receiver()))
app.run(save=0)
</t>
<t tx="rodrigob.121403173614.455">#! /usr/bin/python

from twisted.spread import pb, jelly
from twisted.python import log
from twisted.internet import reactor
from cache_classes import MasterDuckPond

class Sender:
    def __init__(self, pond):
        self.pond = pond

    def phase1(self, remote):
        self.remote = remote
        d = remote.callRemote("takePond", self.pond)
        d.addCallback(self.phase2).addErrback(log.err)
    def phase2(self, response):
        self.pond.addDuck("ugly duckling")
        self.pond.count()
        reactor.callLater(1, self.phase3)
    def phase3(self):
        d = self.remote.callRemote("checkDucks")
        d.addCallback(self.phase4).addErrback(log.err)
    def phase4(self, dummy):
        self.pond.removeDuck("one duck")
        self.pond.count()
        self.remote.callRemote("checkDucks")
        d = self.remote.callRemote("ignorePond")
        d.addCallback(self.phase5)
    def phase5(self, dummy):
        d = self.remote.callRemote("shutdown")
        d.addCallback(self.phase6)
    def phase6(self, dummy):
        reactor.stop()

def main():
    master = MasterDuckPond(["one duck", "two duck"])
    master.count()

    sender = Sender(master)
    deferred = pb.getObjectAt("localhost", 8800, 30)
    deferred.addCallback(sender.phase1)
    reactor.run()

if __name__ == '__main__':
    main()
</t>
<t tx="rodrigob.121403173614.456"></t>
<t tx="rodrigob.121403173614.457">from twisted.spread import pb

class MultipleClientPerspective(pb.Perspective):
    """Many clients may use this Perspective at once."""

    # This example is from twisted.manhole.service.Perspective.

    def __init__(self, perspectiveName, identityName="Nobody"):
        pb.Perspective.__init__(self, perspectiveName, identityName)
        self.clients = {}

    def attached(self, client, identity):
        # The clients dictionary is really only used as a set and not as a
        # mapping, but we go ahead and throw the Identity into the value slot
        # because hey, it's there.
        self.clients[client] = identity
        return self

    def detached(self, client, identity):
        try:
            del self.clients[client]
        except KeyError:
            # This is probably something as benign as the client being removed
            # by a DeadReferenceError in sendMessage and again when the broker
            # formally closes down.  No big deal.
            pass

    def sendMessage(self, message):
        """Pass a message to my clients' console.
        """
        for client in self.clients.keys():
            try:
                client.callRemote('message', message)
            except pb.DeadReferenceError:
                # Stale broker.  This is the error you get if in the process
                # of doing the callRemote, the broker finds out the transport
                # just died, or something along those lines.  So remove that
                # client from our list.
                self.detached(client, None)

    def __getstate__(self):
        state = styles.Versioned.__getstate__(self)
        state['client'] = {}
        return state


</t>
<t tx="rodrigob.121403173614.458">from twisted.cred import error, perspective

class PerspectiveInUse(error.Unauthorized):
    """Raised when a client requests a perspective already connected to another.
    """
    # XXX: Is there any information this exception should carry, i.e.
    #   the Perspective in question.
    #   the client it's currently attached to.
    #   the Identity which attached it.


class SingleClientPerspective(perspective.Perspective):
    """One client may attach to me at a time.

    If another client tries to attach while a previous one is still connected,
    it will encounter a PerspectiveInUse exception.

    @ivar client: The client attached to me, if any.  (Passed by the
        client as the I{client} argument to L{pb.connect}.
    @type client: L{RemoteReference}
    """

    client = None

    def attached(self, ref, identity):
        if self.client is not None:
            raise PerspectiveInUse
        self.client = ref

        # Perspective.attached methods must return a Perspective to tell the
        # caller what they actually ended up being attached to.
        return self

    def detached(self, ref, identity):
        assert ref is self.client, "Detaching something that isn't attached."
        del self.client

    def sendMessage(self, message):
        """Send a message to my client.

        (This isn't a defined Perspective method, just an example of something
        you would define in your sub-class to use to talk to your client.)
        """
        # Using 'assert' in this case is probably not a good idea for real
        # code.  Define an exception, or choose to let it pass without comment,
        # as your needs see fit.
        assert self.client is not None, "No client to send a message to!"
        # Nor is the 'message' method defined by twisted.cred -- your client
        # can have any interface you desire, any type of object may be passed
        # to 'attached'.
        self.client.message(message)

    def __getstate__(self):
        state = styles.Versioned.__getstate__(self)
        # References to clients generally aren't persistable.
        try:
            del state['client']
        except KeyError:
            pass
        return state

</t>
<t tx="rodrigob.121403173614.459"></t>
<t tx="rodrigob.121403173614.460">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

def main():
    def1 = pb.getObjectAt("localhost", 8800, 30)
    def1.addCallbacks(got_obj1, err_obj1)
    reactor.run()

def err_obj1(reason):
    print "error getting first object", reason
    reactor.stop()

def got_obj1(obj1):
    print "got first object:", obj1
    print "asking it to getTwo"
    def2 = obj1.callRemote("getTwo")
    def2.addCallbacks(got_obj2)

def got_obj2(obj2):
    print "got second object:", obj2
    print "telling it to do three(12)"
    obj2.callRemote("three", 12)

main()
</t>
<t tx="rodrigob.121403173614.461">#! /usr/bin/python

from twisted.spread import pb
import twisted.internet.app

class Two(pb.Referenceable):
    def remote_three(self, arg):
        print "Two.three was given", arg
        
class One(pb.Root):
    def remote_getTwo(self):
        two = Two()
        print "returning a Two called", two
        return two

app = twisted.internet.app.Application("pb1server")
app.listenTCP(8800, pb.BrokerFactory(One()))
app.run(save=0)
</t>
<t tx="rodrigob.121403173614.462"></t>
<t tx="rodrigob.121403173614.463">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

class Two(pb.Referenceable):
    def remote_print(self, arg):
        print "Two.print() called with", arg

def main():
    two = Two()
    def1 = pb.getObjectAt("localhost", 8800, 30)
    def1.addCallback(got_obj, two) # hands our 'two' to the callback
    reactor.run()

def got_obj(obj, two):
    print "got One:", obj
    print "giving it our two"
    obj.callRemote("takeTwo", two)

main()
</t>
<t tx="rodrigob.121403173614.464">#! /usr/bin/python

from twisted.spread import pb
import twisted.internet.app
        
class One(pb.Root):
    def remote_takeTwo(self, two):
        print "received a Two called", two
        print "telling it to print(12)"
        two.callRemote("print", 12)

app = twisted.internet.app.Application("pb3server")
app.listenTCP(8800, pb.BrokerFactory(One()))
app.run(save=0)
</t>
<t tx="rodrigob.121403173614.465"></t>
<t tx="rodrigob.121403173614.466">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

def main():
    d = pb.getObjectAt("localhost", 8800, 30)
    d.addCallbacks(got_obj)
    reactor.run()

def got_obj(obj):
    # change "broken" into "broken2" to demonstrate an unhandled exception
    d2 = obj.callRemote("broken")
    d2.addCallback(working)
    d2.addErrback(broken)

def working():
    print "erm, it wasn't *supposed* to work.."
    
def broken(reason):
    print "got remote Exception"
    # reason should be a Failure (or subclass) holding the MyError exception
    print " .__class__ =", reason.__class__
    print " .getErrorMessage() =", reason.getErrorMessage()
    print " .type =", reason.type
    reactor.stop()

main()
</t>
<t tx="rodrigob.121403173614.467">#! /usr/bin/python

from twisted.spread import pb
import twisted.internet.app

class MyError(pb.Error):
    """This is an Expected Exception. Something bad happened."""
    pass

class MyError2(Exception):
    """This is an Unexpected Exception. Something really bad happened."""
    pass

class One(pb.Root):
    def remote_broken(self):
        msg = "fall down go boom"
        print "raising a MyError exception with data '%s'" % msg
        raise MyError(msg)
    def remote_broken2(self):
        msg = "hadda owie"
        print "raising a MyError2 exception with data '%s'" % msg
        raise MyError2(msg)

def main():
    app = twisted.internet.app.Application("exc_server")
    app.listenTCP(8800, pb.BrokerFactory(One()))
    app.run(save=0)

if __name__ == '__main__':
    main()
</t>
<t tx="rodrigob.121403173614.468"></t>
<t tx="rodrigob.121403173614.469">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

def main():
    def1 = pb.connect("localhost", 8800,
                      "user1", "pass1",
                      "myservice", "perspective1",
                      timeout=30)
    def1.addCallbacks(connected)
    reactor.run()

def connected(perspective):
    print "got perspective1 ref:", perspective
    print "asking it to foo(13)"
    perspective.callRemote("foo", 13)

main()
</t>
<t tx="rodrigob.121403173614.470">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

def main():
    def1 = pb.connect("localhost", 8800,
                      "user2", "pass2",
                      "myservice", "perspective2",
                      timeout=30)
    def1.addCallbacks(connected)
    reactor.run()

def connected(perspective):
    print "got perspective2 ref:", perspective
    print "asking it to foo(14)"
    perspective.callRemote("foo", 14)

main()
</t>
<t tx="rodrigob.121403173614.471">#! /usr/bin/python

from twisted.spread import pb
from twisted.cred.authorizer import DefaultAuthorizer
import twisted.internet.app

class MyPerspective(pb.Perspective):
    def attached(self, clientref, identity):
        print "client attached! they are:", identity
        return self
    def detached(self, ref, identity):
        print "client detached! they were:", identity
    def perspective_foo(self, arg):
        print "I am", self.myname, "perspective_foo(",arg,") called on", self

# much of the following is magic
app = twisted.internet.app.Application("pb6server")
auth = DefaultAuthorizer(app)
# create the service, tell it to generate MyPerspective objects when asked
s = pb.Service("myservice", app, auth)
s.perspectiveClass = MyPerspective

#  create one MyPerspective
p1 = s.createPerspective("perspective1")
p1.myname = "p1"
# create an Identity, give it a name and password, and allow it access to
# the MyPerspective we created before
i1 = auth.createIdentity("user1")
i1.setPassword("pass1")
i1.addKeyByString("myservice", "perspective1")
auth.addIdentity(i1)

#  create another MyPerspective
p2 = s.createPerspective("perspective2")
p2.myname = "p2"
i2 = auth.createIdentity("user2")
i2.setPassword("pass2")
i2.addKeyByString("myservice", "perspective2")
auth.addIdentity(i2)


# start the application
app.listenTCP(8800, pb.BrokerFactory(pb.AuthRoot(auth)))
app.run(save=0)
</t>
<t tx="rodrigob.121403173614.472"></t>
<t tx="rodrigob.121403173614.473">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

def one(port, user, pw, service, perspective, number):
    def1 = pb.connect("localhost", port,
                      user, pw, service, perspective,
                      timeout=30)
    def1.addCallback(connected, number)

def connected(perspective, number):
    print "got perspective ref:", perspective
    print "asking it to foo(%d)" % number
    perspective.callRemote("foo", number)

def main():
    one(8800, "user1", "pass1", "service1", "perspective1.1", 10)
    one(8800, "user1", "pass1", "service2", "perspective2.1", 11)
    one(8800, "user2", "pass2", "service1", "perspective1.2", 12)
    one(8800, "user2", "pass2", "service2", "perspective2.2", 13)
    one(8801, "user3", "pass3", "service3", "perspective3.3", 14)
    reactor.run()
    
main()
</t>
<t tx="rodrigob.121403173614.474">#! /usr/bin/python

from twisted.spread import pb
from twisted.cred.authorizer import DefaultAuthorizer
import twisted.internet.app

class MyPerspective(pb.Perspective):
    def perspective_foo(self, arg):
        print "pname", self.perspectiveName, \
              "of servicename", self.getService().serviceName, \
              ":", arg
              
class MyService(pb.Service):
    def __init__(self, serviceName, serviceParent, authorizer=None):
        pb.Service.__init__(self, serviceName, serviceParent, authorizer)
        self.perspectiveClass = MyPerspective
    def getPerspectiveNamed(self, name):
        # create them on the fly if necessary
        p = self.perspectives.get(name, None)
        if not p:
            p = self.createPerspective(name)
        return p
    
        
# much of the following is magic
app = twisted.internet.app.Application("pb7server")

# create three services: one and two share an Authorizer (auth1).
multi = twisted.internet.app.MultiService("shared", app)
auth1 = DefaultAuthorizer(multi)
s1 = MyService("service1", multi, auth1)
s2 = MyService("service2", multi, auth1)

auth2 = DefaultAuthorizer(app)
s3 = MyService("service3", app, auth2)

# create user1 and user2 on the shared authorizer auth1. Both are allowed
# access to a perspective on both services
i1 = auth1.createIdentity("user1")
i1.setPassword("pass1")
i1.addKeyByString("service1", "perspective1.1")
i1.addKeyByString("service2", "perspective2.1")
auth1.addIdentity(i1)
i2 = auth1.createIdentity("user2")
i2.setPassword("pass2")
i2.addKeyByString("service1", "perspective1.2")
i2.addKeyByString("service2", "perspective2.2")
auth1.addIdentity(i2)

# create user3 on the non-shared auth2 Authorizer
i3 = auth2.createIdentity("user3")
i3.setPassword("pass3")
i3.addKeyByString("service3", "perspective3.3")
auth2.addIdentity(i3)

# start the application. auth1 listens on 8800, auth2 on 8801
app.listenTCP(8800, pb.BrokerFactory(pb.AuthRoot(auth1)))
app.listenTCP(8801, pb.BrokerFactory(pb.AuthRoot(auth2)))
app.run(save=0)

</t>
<t tx="rodrigob.121403173614.475"></t>
<t tx="rodrigob.121403173614.476">#! /usr/bin/python

import sys, re
from twisted.internet import reactor
from twisted.internet.stdio import StandardIO
from twisted.spread import pb
from twisted.protocols.basic import LineReceiver
from go_server import GoGameError

class PlayerInput(LineReceiver):
    delimiter = '\n'
    def __init__(self, player):
        #LineReceiver.__init__(self)   # LineReceiver has no __init__ method
        self.player = player
        self.player.input = self
    def connectionMade(self):
        self.printPrompt()
    def printPrompt(self):
        self.transport.write("command : ")
    def lineReceived(self, line):
        self.player.parseCommand(line)
        
    

class Player:
    def __init__(self):
        self.input = None
        self.showCommands()

    def showCommands(self):
        print "valid commands:"
        print " join name passwd side   (where side is 'black' or 'white')"
        print " move x,y   (where x and y are 0 .. 18)"
        
    def connect(self, name, passwd, side):
        self = pb.connect("localhost", 8800, name, passwd, "goservice",
                            side)
        self.addCallback(self.join)
        self.addErrback(self.join_failed)
    def join(self, perspective):
        self.p = perspective
        print " game joined"
        #self.p.callRemote('getBoard').addCallback(self.printBoard)
        self.input.printPrompt()
    def join_failed(self, why):
        t = why.type
        print "t", t, type(t)
        print "check", why.check(GoGameError)
        print " failed:", why.getErrorMessage()
        self.input.printPrompt()

    def newBoard(self, board):
        self.board = board
    def printBoard(self, board):
        self.board = board
        print " current board:", board

    def move(self, x, y):
        d = self.p.callRemote('makeMove', x, y)
        d.addCallback(self.moveOk)
        d.addErrback(self.badMove)
    def moveOk(self, result):
        if result == "game over":
            print " Game Over"
            reactor.stop()
            return
        print " move ok"
        self.input.printPrompt()
    def badMove(self, why):
        print " move failed:", why.getErrorMessage()
        self.input.printPrompt()
        
    def parseCommand(self, cmd):
        m = re.search(r'^\s*join\s+(\w+)\s+(\w+)\s+(\w+)', cmd)
        if m:
            self.connect(m.group(1), m.group(2), m.group(3))
            return
        m = re.search(r'^\s*move\s+(\d+)[\s,]+(\d+)', cmd)
        if m:
            self.move(int(m.group(1)), int(m.group(2)))
            return
        print "unknown command '%s'" % cmd
        self.input.printPrompt()
            
def main():
    #p = Player("alice", "sekrit", "black")
    p = Player()
    s = StandardIO(PlayerInput(p))

    reactor.run()

if __name__ == '__main__':
    main()
</t>
<t tx="rodrigob.121403173614.477">#! /usr/bin/python

import twisted.internet.app
from twisted.cred.authorizer import DefaultAuthorizer
from twisted.spread import pb
from twisted.internet import defer

class GoGameError(pb.Error):
    """Something went wrong in the GoGame"""
    pass

class GoGame:
    def __init__(self):
        self.board = {}
        self.numPlayers = 0
    def addPlayer(self):
        self.numPlayers += 1
    def haveQuorum(self):
        if self.numPlayers == 2:
            return 1
        return 0
    def getBoard(self):
        return self.board # a dict, with the state of the board
    def moveIsLegal(self, x, y, player):
        return 1 # yeah, sure, why not
    def gameIsOver(self):
        return 0 # no, not yet
    def move(self, x, y, playerName):
        if not self.haveQuorum():
            raise GoGameError("NeedMorePlayers")
        if self.moveIsLegal(x, y, playerName):
            self.board[x,y] = playerName
            if self.gameIsOver():
                return "game over"
            else:
                return "ok"
        else:
            raise GoGameError("IllegalMove")
        

class Player(pb.Perspective):
    def __init__(self, perspectiveName, identityName="Nobody"):
        pb.Perspective.__init__(self, perspectiveName, identityName)
    def setGame(self, game):
        self.game = game

    def attached(self, clientref, identity):
        print "player '%s' joining game on side '%s'" % \
              (identity.name, self.perspectiveName)
        self.identity = identity
        self.game.addPlayer()
        return self
    def detached(self, clientref, identity):
        return self
    
    def perspective_getBoard(self):
        return self.game.getBoard()
    def perspective_makeMove(self, x, y):
        print "player '%s' [%s] moving at %d,%d" % (self.identity.name,
                                                    self.perspectiveName,
                                                    x, y)
        return self.game.move(self.perspectiveName, x, y)
    

class GoService(pb.Service):
    def __init__(self, serviceName, serviceParent=None, authorizer=None,
                 application=None):
        pb.Service.__init__(self, serviceName, serviceParent, authorizer,
                            application)
        self.sides = { 'black': None, 'white': None }
        self.game = GoGame()
        
    def getPerspectiveRequest(self, name):
        # players are allowed to to choose any side that hasn't already been
        # taken
        if name not in ('black', 'white'):
            return defer.fail(GoGameError("No such side '%s'" % name))
        if self.sides[name]:
            return defer.fail(GoGameError("That side is already taken"))
        player = Player(name)
        player.setGame(self.game)
        self.sides[name] = player
        return defer.succeed(player)

def setup_players(auth, players):
    for (name, pw) in players:
        i = auth.createIdentity(name)
        i.setPassword(pw)
        i.addKeyByString("goservice", "black")
        i.addKeyByString("goservice", "white")
        i.addKeyByString("goservice", "bogus")
        auth.addIdentity(i)
        

def main():
    app = twisted.internet.app.Application("go_server")
    auth = DefaultAuthorizer(app)
    service = GoService("goservice", app, auth)
    players = [["alice", "sekrit"],
               ["bob", "b0b"],
               ["charlie", "chuck"],
               ["david", "password"],
               ]
    setup_players(auth, players)

    # start the application
    app.listenTCP(8800, pb.BrokerFactory(pb.AuthRoot(auth)))
    app.run(save=0)

if __name__ == '__main__':
    main()
</t>
<t tx="rodrigob.121403173614.478"></t>
<t tx="rodrigob.121403173614.479"></t>
<t tx="rodrigob.121403173614.480">Message: 10
Date: Mon, 16 Jun 2003 05:28:46 -0500
From: Glyph Lefkowitz &lt;glyph@twistedmatrix.com&gt;
To: twisted-python@twistedmatrix.com
Subject: [Twisted-Python] Lies, Damn Lies, and Stable Interfaces
Reply-To: twisted-python@twistedmatrix.com

There are some new modules in CVS right now, and I would like some 
feedback on them.

The modules in question are a sketch of The Wave of the Future of 
authentication in Twisted, A.K.A. "New Cred".  A good place to start 
looking is sandbox/webhappyrealm.py

Unfortunately, this sets a bad precedent, since old cred was 
"semi-stable".  However, I think that the break with declared stability 
is a small price to pay for the _VASTLY_ improved interfaces which this 
package provides.  Since not too many people were using the old cred 
deeply, and the new interfaces are much smaller, hopefully we can 
migrate to the new code as quickly as possible.

Of course, no new Twisted functionality would be complete without a 
byzantine new set of terms.  In this case, the terms are hopefully more 
descriptive and more memorable; as a bonus, they do not conflict with 
the old names, so we can keep both versions of cred on-line until such 
time as the deprecation warnings can be resolved.

This message is primarily about those new names.  I hope that this 
provides enough fodder for someone with more time to produce a 
nice-looking HOWTO.  Without further ado, here are the new words you 
need to integrate into your basal nervous system:


#############################

Portal
======

This is the ineffable mystery at the core of login.  There is one 
concrete implementation of Portal, and no interface - it does a very 
simple task.  A Portal associates one (1) Realm with a collection of 
CredentialChecker instances.  (More on those later.)

The closest analogue of this in Old Cred was the Authorizer.

If you are writing a protocol that needs to authenticate against 
something, you will need a reference to a Portal, and to nothing else.  
This has only 2 methods -

login(credentials, mind, *interfaces)

The docstring is quite expansive (see twisted.cred.portal), but in 
brief, this is what you call when you need to call in order to connect 
a user to the system.  The result is a deferred which fires a tuple of:

- interface (which was one of the interfaces passed in the *interfaces 
tuple)
- an object that implements that interface (an Aspect of an Avatar) - 
logout, a 0-argument callable which disconnects the connection that was 
established by this call to login

registerChecker(checker, *credentialInterfaces)

which adds a CredentialChecker to the portal.

Mind
====

Masters of Perspective Broker already know this object as the ill-named 
"client object".  There is no "mind" class, or even interface, but it 
is an object which serves an important role - any notifications which 
are to be relayed to an authenticated client are passed through a 
'mind'.

The name may seem rather unusual, but considering that a Mind is 
representative of the entity on the "other end" of a network connection 
that is both receiving updates and issuing commands, I believe it is 
appropriate.

Although many protocols will not use this, it serves an important role. 
  It is provided as an argument both to the Portal and to the Realm, 
although a CredentialChecker should interact with a client program 
exclusively through a Credentials instance.

Unlike the original Perspective Broker "client object", a Mind's 
implementation is most often dictated by the protocol that is 
connecting rather than the Realm.  A Realm which requires a particular 
interface to issue notifications will need to wrap the Protocol's mind 
implementation with an adapter in order to get one that conforms to its 
expected interface - however, Perspective Broker will likely continue 
to use the model where the client object has a pre-specified remote 
interface.

(If you don't quite understand this, it's fine.  It's hard to explain, 
and it's not used in simple usages of cred, so feel free to pass None 
until you find yourself requiring something like this.)

CredentialChecker
=================

This is an object which resolves some Credentials to an avatar ID.  
Some examples of CredentialChecker implementations would be: 
InMemoryUsernamePassword, ApacheStyleHTAccessFile, 
UNIXPasswordDatabase, SSHPublicKeyChecker.  A credential checker 
stipulates some requirements of the credentials it can check by 
specifying a credentialInterfaces attribute, which is a list of 
interfaces.  Credentials passed to its requestAvatarId method must 
implement one of those interfaces.

For the most part, these things will just check usernames and passwords 
and produce the username as the result, but hopefully we will be seeing 
some public-key, challenge-response, and certificate based credential 
checker mechanisms soon.  (If somebody were to write an 
ActiveDirectory-compatible LDAP login, they would be my best friend for 
EVER.)

A credential checker should raise an error if it cannot authenticate 
the user, and return '' for anonymous access.

Credentials
===========

Oddly enough, this represents some credentials that the user presents.  
Usually this will just be a small static blob of data, but in some 
cases it will actually be an object connected to a network protocol.  
For example, a username/password pair is static, but a 
challenge/response server is an active state-machine that will require 
several method calls in order to determine a result.

Realm
=====

A realm is an interface which connects your universe of "business 
objects" to the authentication system.  This is similar to the Old Cred 
"Service", but the name "Service" will be phased out when referring to 
cred - another planned refactoring is to move 
twisted.internet.app.ApplicationService into its own module and more 
heavily emphasize its use in start-up and shut-down.

IRealm is another one-method interface:

requestAvatar(avatarId, mind, *interfaces)

This method will typically be called from 'Portal.login'.  The avatarId 
is the one returned by a CredentialChecker.

The important thing to realize about this method is that if it is being 
called, _the user has already authenticated_.  Therefore, if possible, 
the Realm should create a new user if one does not already exist 
whenever possible.  Of course, sometimes this will be impossible 
without more information, and that is the case that the interfaces 
argument is for.

Some protocols can only accept a fixed set of interfaces.  However, 
others (most notably PB) can deal with more arbitrary data being 
returned.  An online game may call Portal.login with:

     login(PBChallengeResponse(...), clientSideThingy,
           IServerPlayerInWorld, IUserChooser, ICharacterCreationThing)

This specifies that the client would most prefer a player in the world, 
but, failing that, a UserChooser (selection interface for a second step 
to get a PlayerInWorld) or a CharacterCreationThing (interface to 
create a new character in the world before returning it) would be 
acceptable.

Since requestAvatar should be called from a Deferred callback, it may 
return a Deferred or a synchronous result.

At the moment, there is only an interface for the Realm.  However, it 
is expected that a utility class will be written in the near future to 
facilitate log-in methods, a re-directing method similar to 
"Perspective.attached" for Avatars, and at least somewhat automated 
compositing of Realms.  However, in writing the code for cred and 
guard, there has been no need for such a thing yet.

Avatar
======

This object has the dubious distinction of appearing nowhere in the 
code; in fact, very few things will ever touch an actual Avatar, and it 
is not clear that it will have an interface.  However, _aspects_ of an 
avatar are returned in deferreds from the above methods, which is to 
say, things that implement particular interfaces which communicate with 
various protocols that may access your Realm.

This is (hopefully, obviously) similar to a 'Perspective'.  However, an 
Avatar separates 2 concerns which were muddied previously - _access_ to 
a realm and _storage of user data_ within a realm.  The avatar itself 
stores the data, and the aspects interface to it.  The avatar itself 
may of course implement its own aspects, but it is suggested in most 
cases to register adapters that do this.  (Perspective Broker will keep 
its name, because the Avatar Aspect that communicates with the remote 
object protocol will still be called a Perspective.)

#############################


While it's understandable to want to wait for this interface to fully 
stabilize, we suggest that you start porting code to it _now_, 
especially if you're already tracking CVS.  The old cred was, through 
the continued efforts of many developers, experimentally determined to 
be a piece of crap.  I humbly suggest that this interface is not only 
not a piece of crap, but totally awesome, and actually usable in real 
applications.  Not only is it a vastly better design, it makes use of 
Deferreds in such a way that it is almost effortless to provide or 
manipulate an implementation of one of these interfaces.  (As a 
yardstick, the code for woven.guard was 30% shorter and the example was 
almost unmeasureably shorter - sandbox/webhappyrealm.py is already 
doing things that were impossible under the old model.)

I hope this explanation was helpful.  Please give feedback.



</t>
<t tx="rodrigob.121403173614.481">@language python
&lt;&lt; webhappyrealm declarations &gt;&gt;
@others

theRealm = MyRealm()

# get our password checker ready
from twisted.cred.checkers import InMemoryUsernamePasswordDatabaseDontUse, AllowAnonymousAccess

checker = InMemoryUsernamePasswordDatabaseDontUse()
checker.addUser("bob", "12345")

anon = AllowAnonymousAccess()

# authenticatiferize it
from twisted.cred.portal import Portal

usersOnly = Portal(theRealm)
usersOnly.registerChecker(checker)

usersAndAnon = Portal(theRealm)
usersAndAnon.registerChecker(checker)
usersAndAnon.registerChecker(anon)

# create the intarweb
from twisted.web.server import Site
res = Resource()
sit = Site(res)
res.putChild("", Data("&lt;html&gt;&lt;a href='site1'&gt;site1&lt;/a&gt;&lt;br/&gt;&lt;a href='site2'&gt;site2&lt;/a&gt;&lt;/html&gt;", "text/html"))

# put our sites online
from twisted.web.woven.guard import UsernamePasswordWrapper, SessionWrapper
res.putChild("site1", SessionWrapper(UsernamePasswordWrapper(usersOnly)))
res.putChild("site2", SessionWrapper(UsernamePasswordWrapper(usersAndAnon)))

# and finally talk to the internat
from twisted.internet import reactor
reactor.listenTCP(8080, sit)
reactor.run()
</t>
<t tx="rodrigob.121403173614.482"># implement a simple realm
from twisted.cred.portal import IRealm
from twisted.web.static import Data
from twisted.web.resource import Resource, IResource

</t>
<t tx="rodrigob.121403173614.483">class MyRealm:
    &lt;&lt; class MyRealm declarations &gt;&gt;
    @others
</t>
<t tx="rodrigob.121403173614.484">__implements__ = IRealm
</t>
<t tx="rodrigob.121403173614.485">def requestAvatar(self, avatarId, mind, *interfaces):
    if IResource in interfaces:
        if avatarId:
            return IResource, Data("logged in as %s" % avatarId, "text/plain"), lambda : None
        else:
            return IResource, Data("anonymous browsing - &lt;a href='perspective-init'&gt;login&lt;/a&gt;", "text/html"), lambda : None
    else:
        raise NotImplementedError("no interface")
</t>
<t tx="rodrigob.121403173614.486">@language plain
client:
    login
    getOutlinePerspective
    tadaa !
    
server:
    Simple Portal
    Simple Realm
    Avatar check if user is authorized 
    
    </t>
<t tx="rodrigob.121403173614.487"></t>
<t tx="rodrigob.121403173614.488">@ignore
@language python
&lt;&lt; pb-go-client declarations &gt;&gt;
@others

if __name__ == '__main__':
    main(*(sys.argv[1:5]))
    
</t>
<t tx="rodrigob.121403173614.489">import sys, random
from twisted.cred import credentials
from twisted.spread import pb

</t>
<t tx="rodrigob.121403173614.490">class RandomPlayer:
    @others
</t>
<t tx="rodrigob.121403173614.491">def __init__(self, name):
    self.name = name
</t>
<t tx="rodrigob.121403173614.492">def login(self, host, port, pword):
    self.factory = pb.PBClientFactory()
    d = self.factory.login(credentials.UsernamePassword(self.name, pword))
    d.addCallbacks(self.loggedIn, disaster)

    from twisted.internet import reactor
    reactor.connectTCP(host, int(port), self.factory)
</t>
<t tx="rodrigob.121403173614.493">def loggedIn(self, perspective):
    self.perspective = perspective
    d = self.perspective.callRemote('getBoardSize')
    d.addCallbacks(self.gotSize, disaster)
    return d
</t>
<t tx="rodrigob.121403173614.494">def gotSize(self, size):
    self.boardSize = size
    x = random.randrange(size)
    y = random.randrange(size)
    d = self.perspective.callRemote('move', x, y)
    d.addCallbacks(self.madeMove, disaster)
    return d
</t>
<t tx="rodrigob.121403173614.495">def madeMove(self, ignored):
    d = self.perspective.callRemote('getBoard')
    d.addCallbacks(self.displayBoard, disaster)
    d.addCallbacks(self.quit, disaster)
    return d
</t>
<t tx="rodrigob.121403173614.496">def displayBoard(self, board):
    print board
</t>
<t tx="rodrigob.121403173614.497">def quit(self, ignored):
    from twisted.internet import reactor
    self.factory.disconnect()
    reactor.stop()
</t>
<t tx="rodrigob.121403173614.498">def disaster(failing):
    print failing
    sys.exit(-1)
</t>
<t tx="rodrigob.121403173614.499">def main(host, port, username, password):
    from twisted.internet import reactor
    player = RandomPlayer(username)
    player.login(host, int(port), password)
    reactor.run()
</t>
<t tx="rodrigob.121403173614.500">@ignore
@language python
&lt;&lt; pb-go declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="rodrigob.121403173614.501">from twisted.cred import checkers, portal
from twisted.spread import pb

</t>
<t tx="rodrigob.121403173614.502">class GoException(Exception):
    &lt;&lt; class GoException declarations &gt;&gt;
</t>
<t tx="rodrigob.121403173614.503">"""Raised when a violation of the rules of Go is detected."""

</t>
<t tx="rodrigob.121403173614.504">class Board:
    &lt;&lt; class Board declarations &gt;&gt;
    @others
</t>
<t tx="rodrigob.121403173614.505">"""I represent something like a Go board."""

size = 19

</t>
<t tx="rodrigob.121403173614.506">def __init__(self):
    self.board = {}
    self.players = {}
</t>
<t tx="rodrigob.121403173614.507">def addPlayer(self, name):
    if name not in self.players.keys():
        p = Player(name, self)
        self.players[name] = p
        return p
</t>
<t tx="rodrigob.121403173614.508">def getPlayer(self, name):
    return self.players[name]
</t>
<t tx="rodrigob.121403173614.509">def playStone(self, x, y, side):
    if self.board.has_key((x, y)):
        raise GoException(
               "A stone has already been played at %d, %d" % (x, y))
    if 0 &lt;= x &lt; self.size and 0 &lt;= y &lt; self.size:
        self.board[(x, y)] = side
    else:
        raise ValueError("%d, %d is not a valid position" % (x, y))
</t>
<t tx="rodrigob.121403173614.510">

class Player(pb.Perspective):
    &lt;&lt; class Player declarations &gt;&gt;
    @others
</t>
<t tx="rodrigob.121403173614.511">"""A represent a Go player."""
__implements__ = pb.IPerspective,

</t>
<t tx="rodrigob.121403173614.512">def __init__(self, name, board):
    self.name = name
    self.board = board
</t>
<t tx="rodrigob.121403173614.513">def __repr__(self):
    return "Player(%s)" % (self.name,)
</t>
<t tx="rodrigob.121403173614.514">def logout(self):
    print "%r has logged out." % (self,)
</t>
<t tx="rodrigob.121403173614.515">def perspective_move(self, x, y):
    self.board.playStone(x, y, self.name)
</t>
<t tx="rodrigob.121403173614.516">def perspective_getBoard(self):
    return self.board.board
</t>
<t tx="rodrigob.121403173614.517">def perspective_getBoardSize(self):
    return self.board.size
</t>
<t tx="rodrigob.121403173614.518">

class MyRealm:
    &lt;&lt; class MyRealm declarations &gt;&gt;
    @others
</t>
<t tx="rodrigob.121403173614.519">__implements__ = portal.IRealm

</t>
<t tx="rodrigob.121403173614.520">def __init__(self, game):
    self.game = game
</t>
<t tx="rodrigob.121403173614.521">def requestAvatar(self, avatarId, mind, *interfaces):
    if pb.IPerspective in interfaces:
        try:
            player = self.game.getPlayer(avatarId)
        except KeyError:
            player = self.game.addPlayer(avatarId)
        return pb.IPerspective, player, player.logout
    else:
        raise NotImplementedError, "I only do PB"
</t>
<t tx="rodrigob.121403173614.522">def main():
    from twisted.internet import reactor
    checker = checkers.InMemoryUsernamePasswordDatabaseDontUse()
    checker.addUser("alice", "pass1")
    checker.addUser("bob", "pass2")

    board = Board()

    myPortal = portal.Portal(MyRealm(board))
    myPortal.registerChecker(checker)

    factory = pb.PBServerFactory(myPortal)
    reactor.listenTCP(8787, factory)
    reactor.run()
</t>
<t tx="rodrigob.121403173614.523"></t>
<t tx="rodrigob.121403173614.524">@ignore
@language python
&lt;&lt; pb6server declarations &gt;&gt;
@others

p = portal.Portal(MyRealm())
p.registerChecker(checkers.InMemoryDatabaseDontUse(user1="pass1",
                                                   user2="pass2"))
reactor.listenTCP(8800, pb.PBServerFactory(p))
reactor.run()
</t>
<t tx="rodrigob.121403173614.525">#! /usr/bin/python

from twisted.spread import pb
from twisted.cred import checkers, portal
from twisted.internet import reactor

</t>
<t tx="rodrigob.121403173614.526">class MyPerspective(pb.Avatar):
    @others
</t>
<t tx="rodrigob.121403173614.527">def __init__(self, name):
    self.name = name
</t>
<t tx="rodrigob.121403173614.528">def perspective_foo(self, arg):
    print "I am", self.name, "perspective_foo(",arg,") called on", self
</t>
<t tx="rodrigob.121403173614.529">
class MyRealm:
    &lt;&lt; class MyRealm declarations &gt;&gt;
    @others
</t>
<t tx="rodrigob.121403173614.530">__implements__ = portal.IRealm
</t>
<t tx="rodrigob.121403173614.531">def requestAvatar(self, avatarId, mind, *interfaces):
    if pb.IPerspective not in interfaces:
        raise NotImplementedError
    return pb.IPerspective, MyPerspective(avatarId), lambda:None
</t>
<t tx="rodrigob.121403173614.532">@ignore
@language python
&lt;&lt; pb6client1 declarations &gt;&gt;
@others

main()
</t>
<t tx="rodrigob.121403173614.533">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor
from twisted.cred import credentials

</t>
<t tx="rodrigob.121403173614.534">def main():
    factory = pb.PBClientFactory()
    reactor.connectTCP("localhost", 8800, factory)
    def1 = factory.login(credentials.UsernamePassword("user1", "pass1"))
    def1.addCallback(connected)
    reactor.run()
</t>
<t tx="rodrigob.121403173614.535">def connected(perspective):
    print "got perspective1 ref:", perspective
    print "asking it to foo(13)"
    perspective.callRemote("foo", 13)
</t>
<t tx="rodrigob.121403173614.536">@ignore
@language python
&lt;&lt; pb6client2 declarations &gt;&gt;
@others

main()
</t>
<t tx="rodrigob.121403173614.537">#! /usr/bin/python

from twisted.spread import pb
from twisted.internet import reactor

from twisted.spread import pb
from twisted.internet import reactor
from twisted.cred import credentials

</t>
<t tx="rodrigob.121403173614.538">def main():
    factory = pb.PBClientFactory()
    reactor.connectTCP("localhost", 8800, factory)
    def1 = factory.login(credentials.UsernamePassword("user2", "pass2"))
    def1.addCallback(connected)
    reactor.run()
</t>
<t tx="rodrigob.121403173614.539">def connected(perspective):
    print "got perspective2 ref:", perspective
    print "asking it to foo(14)"
    perspective.callRemote("foo", 14)
</t>
<t tx="rodrigob.121403173614.540"></t>
<t tx="rodrigob.121403173614.541">@ignore
@language python
&lt;&lt; Tetris0_4 declarations &gt;&gt;
@others
                        

if __name__ == "__main__":
    
    global Liste_couleurs, brique, jeu, nb_lignes, score, niveau
        Liste_couleurs = ["blue","red","green","orange","violet","grey"]

    root=Tk()
    root.title("Pytetris")
    root.resizable(0,0)
    Frame(root, height=200, width=10).pack(side="left")
    Frame(root, height=20, width=200).pack(side="top")
    Frame(root, height=20, width=200).pack(side="bottom")
    
    # dessine l'espace de jeu
    cv = Canvas(root, height=519, width=269)
    cv.pack(side="left")
    cv.create_rectangle( 0, 0, 269, 519, fill="dark green")
    cv.create_rectangle( 9, 9, 260, 510, fill="white")
    cv.create_line( 0, 0, 9, 9, fill="black")
    cv.create_line( 260, 9, 269, 0, fill="black")
    cv.create_line( 0, 519, 9, 510, fill="black")
    cv.create_line( 260, 510, 269, 519, fill="black")
    
    Frame(root,height=300,width=20).pack(side="left")
    frame2=Frame(root, bd=0)
    frame2.pack(side="left", anchor=N)
    Frame(root, height=300, width=20).pack(side="left")
    
    # les trois boutons principaux: start, pause et stop
    bouton_start=Button(frame2, text="!! START !!").pack(fill="x")
    bouton_pause=Button(frame2, text="...PAUSE...", command=pauser).pack(fill="x")
    bouton_stop=Button(frame2, text="STOP").pack(fill="x")
    Frame(frame2, height=20).pack()
        
    # le canvas o� apparait le prochain bloc
    canvas_suivant = Canvas(frame2, height=150, width=200, relief="raised", bd=2).pack()
    Frame(frame2, height=20).pack()
    
    # les labels o� s'affichent le score, le nombre de lignes et le niveau
    # il faut initialiser les variables pour les labels
    score, nb_lignes, niveau = 0, 0, 1
    lb_score = StringVar()
    lb_nb_lignes = StringVar()
    lb_niveau = StringVar()
    Label(frame2, text="Score:").pack(anchor=NW)
    label_score = Label(frame2, textvariable=lb_score).pack(anchor=NE)
    lb_score.set(score)
    Frame(frame2, height=10).pack()
    Label(frame2, text="Lignes:").pack(anchor=NW)
    label_lignes = Label(frame2, textvariable=lb_nb_lignes).pack(anchor=NE)
    lb_nb_lignes.set(nb_lignes)
    Frame(frame2, height=10).pack()
    Label(frame2, text="Niveau:").pack(anchor=NW)
    label_niveau = Label(frame2, textvariable=lb_niveau).pack(anchor=NE)
    lb_niveau.set(niveau)
    Frame(frame2, height=20).pack(side="top")
    
    # on cr�e le premier bloc et l'espace de jeu
    jeu=Jeu()
    brique=Bloc()
    nouveau_bloc()
    
    # les touches de direction pour d�placer le bloc
    root.bind("&lt;Left&gt;",brique.gauche)
    root.bind("&lt;Right&gt;",brique.droite)
    root.bind("&lt;Up&gt;",brique.tourner_g)
    root.bind("&lt;Down&gt;",vite)
    pause=0
        
    # c'est parti !
    root.after(460-niveau*30, descendre_auto)

</t>
<t tx="rodrigob.121403173614.542">#!/usr/bin/env python

import random, time
from tkMessageBox import *
from tkFileDialog import *
from Tkinter import *

</t>
<t tx="rodrigob.121403173614.543">class Jeu:
    @others
</t>
<t tx="rodrigob.121403173614.544">def __init__(self):
    self.grille=[]
    for i in range(0,10):
        self.grille.append([0]*20)
</t>
<t tx="rodrigob.121403173614.545">def pos(self,x,y):
    return self.grille[x][y]
</t>
<t tx="rodrigob.121403173614.546">def changer(self,x,y,couleur):
    self.grille[x][y]=couleur
</t>
<t tx="rodrigob.121403173614.547">def updater(self):
    cv.delete("autres")
    for i in range(0,10):
        for j in  range(0,20):
            if self.grille[i][j] != 0:
                carre(i,j,self.pos(i,j),"autres")
</t>
<t tx="rodrigob.121403173614.548">def verif(self):
    global score,nb_lignes
    lignes=[]
    for j in range(19,0,-1):
        compteur=0
        for i in range(0,10):
            if self.grille[i][j] != 0:
                compteur=compteur+1
        if compteur==10:
            lignes.append(j)
    
    if len(lignes) != 0:
        compteur = -1
        for j in lignes:
            compteur = compteur + 1
            for i in range(0,10):
                self.grille[i].reverse()
                self.grille[i][19-j-compteur:20-j-compteur]=[]
                self.grille[i].reverse()
                self.grille[i].insert(0,0)
        self.updater()
                        
        nb_lignes=nb_lignes+len(lignes)
        niveau = nb_lignes/10 + 1
        if len(lignes) &lt;= 3:
            score=score+100+200*(len(lignes)-1)
        else:
            score=score+1000
                    
        lb_score.set(score)
        lb_nb_lignes.set(nb_lignes)
        lb_niveau.set(niveau)
        self.updater()
</t>
<t tx="rodrigob.121403173614.549">                        
            
class Bloc:
    @others
</t>
<t tx="rodrigob.121403173614.550">def verif(self):
    """Retourne 0 si c'est ok, 1 si la place est d�j� occup�e, /n
       et 2 si une case occup�e est hors-jeu"""
    for i in range(0,self.taille):
        for j in range(0,self.taille):
            if self.grille[i][j] != 0:
                if self.x+i&lt;0 or self.x+i&gt;9:
                    return 2
                if self.y+j&gt;19:
                    return 2
                if jeu.pos(self.x+i,self.y+j) != 0:
                    return 1
    return 0
</t>
<t tx="rodrigob.121403173614.551">def tourner_g(self, event=NONE):
    if pause:
        return
    if self.taille==3:
        (self.grille[0][0], self.grille[1][0], self.grille[2][0],
        self.grille[0][1], self.grille[1][1], self.grille[2][1],
        self.grille[0][2], self.grille[1][2], self.grille[2][2])=(self.grille[2][0],
        self.grille[2][1], self.grille[2][2],
        self.grille[1][0], self.grille[1][1], self.grille[1][2],
        self.grille[0][0], self.grille[0][1], self.grille[0][2])
    else:
        (self.grille[0][0], self.grille[1][0], self.grille[2][0], self.grille[3][0],
        self.grille[0][1], self.grille[1][1], self.grille[2][1], self.grille[3][1],
        self.grille[0][2], self.grille[1][2], self.grille[2][2], self.grille[3][2],
        self.grille[0][3], self.grille[1][3], self.grille[2][3], self.grille[3][3])=(self.grille[3][0],
        self.grille[3][1], self.grille[3][2], self.grille[3][3],
        self.grille[2][0], self.grille[2][1], self.grille[2][2], self.grille[2][3],
        self.grille[1][0], self.grille[1][1], self.grille[1][2], self.grille[1][3],
        self.grille[0][0], self.grille[0][1], self.grille[0][2], self.grille[0][3])
    if self.verif():
        self.tourner_d()
    self.updater()
</t>
<t tx="rodrigob.121403173614.552">def tourner_d(self):
    if pause:
        return
    if self.taille==3:
        (self.grille[2][0], self.grille[2][1], self.grille[2][2],
        self.grille[1][0], self.grille[1][1], self.grille[1][2],
        self.grille[0][0], self.grille[0][1], self.grille[0][2])=(self.grille[0][0],
        self.grille[1][0], self.grille[2][0],
        self.grille[0][1], self.grille[1][1], self.grille[2][1],
        self.grille[0][2], self.grille[1][2], self.grille[2][2])
    else:
        (self.grille[3][0], self.grille[3][1], self.grille[3][2], self.grille[3][3],
        self.grille[2][0], self.grille[2][1], self.grille[2][2], self.grille[2][3],
        self.grille[1][0], self.grille[1][1], self.grille[1][2], self.grille[1][3],
        self.grille[0][0], self.grille[0][1], self.grille[0][2], self.grille[0][3])=(self.grille[0][0],
        self.grille[1][0], self.grille[2][0], self.grille[3][0],
        self.grille[0][1], self.grille[1][1], self.grille[2][1], self.grille[3][1],
        self.grille[0][2], self.grille[1][2], self.grille[2][2], self.grille[3][2],
        self.grille[0][3], self.grille[1][3], self.grille[2][3], self.grille[3][3])
</t>
<t tx="rodrigob.121403173614.553">def updater(self):
    cv.delete("brique")
    for i in range(0,self.taille):
        for j in range(0,self.taille):
            if self.grille[i][j] != 0:
                carre(self.x+i, self.y+j, self.c, "brique")
</t>
<t tx="rodrigob.121403173614.554">def gauche(self, event=NONE):
    if pause:
        return
    self.x=self.x-1
    if self.verif() != 0:
        self.x=self.x+1
    self.updater()
</t>
<t tx="rodrigob.121403173614.555">def droite(self, event=NONE):
    if pause:
        return
    self.x=self.x+1
    if self.verif() != 0:
        self.x=self.x-1
    self.updater()
</t>
<t tx="rodrigob.121403173614.556">def bas(self):
    self.y=self.y+1
    if self.verif() != 0:
        self.y=self.y-1
        for i in range(0,self.taille):
            for j in range(0,self.taille):
                if self.grille[i][j] != 0:
                    jeu.changer(self.x+i,self.y+j,self.c)
        self.etat="pos�"
</t>
<t tx="rodrigob.121403173614.557">def carre(x,y,c,opt):
    cv.create_rectangle(10+x*25, 10+y*25, 34+x*25, 34+y*25, fill="dark "+c, tag=opt)
        cv.create_rectangle(13+x*25, 13+y*25, 31+x*25, 31+y*25, fill=c, tag=opt)
</t>
<t tx="rodrigob.121403173614.558">def nouveau_bloc():
    global brique
    brique.c=random.choice(Liste_couleurs)
    brique.x=4
    brique.y=0
    brique.etat="ok"
    
    type_de_bloc=random.choice(range(1,8))
    if type_de_bloc &lt;=5:
        brique.grille=[[0,0,0],[0,0,0],[0,0,0]]
        brique.taille=3
    else:
        brique.grille=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
        brique.taille=4
    
    if type_de_bloc==1:
        brique.grille[1][0], brique.grille[1][1] = 1,1
        brique.grille[1][2], brique.grille[0][2] = 1,1	
    elif type_de_bloc==2:
            brique.grille[1][0], brique.grille[1][1] = 1, 1
            brique.grille[1][2], brique.grille[2][2] = 1, 1
    elif type_de_bloc==3:
        brique.grille[0][0], brique.grille[1][0] = 1, 1
            brique.grille[1][1], brique.grille[2][1] = 1, 1
    elif type_de_bloc==4:
            brique.grille[0][1], brique.grille[1][1] = 1, 1
            brique.grille[1][0], brique.grille[2][0] = 1, 1
    elif type_de_bloc==5:
            brique.grille[1][0], brique.grille[1][1] = 1, 1
            brique.grille[0][1], brique.grille[2][1] = 1, 1
    elif type_de_bloc==6:
            brique.grille[1][1], brique.grille[1][2] = 1, 1
            brique.grille[2][1], brique.grille[2][2] = 1, 1
    else:
            brique.grille[2][0], brique.grille[2][1] = 1, 1
            brique.grille[2][2], brique.grille[2][3] = 1, 1
</t>
<t tx="rodrigob.121403173614.559">def descendre_auto():
    if pause:
        pass
    else:
        global brique
        brique.bas()
        if brique.etat != "ok":
            jeu.verif()
            nouveau_bloc()
        brique.updater()
        jeu.updater()
        root.after(460-niveau*30, descendre_auto)
</t>
<t tx="rodrigob.121403173614.560">def vite(event=NONE):
    # Pour l'instant il faut rappuyer sur pause pour que la vitesse des blocs
    # redevienne normale.
    global pause, brique
    pause=1
    while brique.etat == "ok":
        brique.bas()
    jeu.verif()
    nouveau_bloc()
    brique.updater()
    jeu.updater()
    pauser()
</t>
<t tx="rodrigob.121403173614.561">def pauser(event=NONE):
    global pause
    if pause:
        pause=0
        root.after(460-niveau*30, descendre_auto)
    else:
        pause=1
</t>
<t tx="rodrigob.121403173614.562"># creating a simple dialog

from Tkinter import *


class MyDialog:
    
    def __init__(self, parent):
        
        top = self.top = Toplevel(parent)
        Label(top, text, etc...)
        
        
        
    def ok(self):
        
        print "Finishing dialog"
        
        self.top.destroy()
        
        

root = Tk()
Button(root, text="Hello").pack()
root.update()

d = MyDialog(root)

root.wait_window(d.top)
        
        </t>
<t tx="rodrigob.121403173614.563">#
# An Introduction to Tkinter
# tkSimpleDialog.py
#
# Copyright (c) 1997 by Fredrik Lundh
#
# fredrik@pythonware.com
# http://www.pythonware.com
#

# --------------------------------------------------------------------
# dialog base class

'''Dialog boxes

This module handles dialog boxes. It contains the following
public symbols:

Dialog -- a base class for dialogs

askinteger -- get an integer from the user

askfloat -- get a float from the user

askstring -- get a string from the user
'''

from Tkinter import *
import os

class Dialog(Toplevel):

    '''Class to open dialogs.

    This class is intended as a base class for custom dialogs
    '''

    def __init__(self, parent, title = None):

        '''Initialize a dialog.

        Arguments:

            parent -- a parent window (the application window)

            title -- the dialog title
        '''
        Toplevel.__init__(self, parent)
        self.transient(parent)

        if title:
            self.title(title)

        self.parent = parent

        self.result = None

        body = Frame(self)
        self.initial_focus = self.body(body)
        body.pack(padx=5, pady=5)

        self.buttonbox()

        self.grab_set()

        if not self.initial_focus:
            self.initial_focus = self

        self.protocol("WM_DELETE_WINDOW", self.cancel)

        if self.parent is not None:
            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

        self.initial_focus.focus_set()

        self.wait_window(self)

    def destroy(self):
        '''Destroy the window'''
        self.initial_focus = None
        Toplevel.destroy(self)

    #
    # construction hooks

    def body(self, master):
        '''create dialog body.

        return widget that should have initial focus.
        This method should be overridden, and is called
        by the __init__ method.
        '''
        pass

    def buttonbox(self):
        '''add standard button box.

        override if you do not want the standard buttons
        '''

        box = Frame(self)

        w = Button(box, text="OK", width=10, command=self.ok, default=ACTIVE)
        w.pack(side=LEFT, padx=5, pady=5)
        w = Button(box, text="Cancel", width=10, command=self.cancel)
        w.pack(side=LEFT, padx=5, pady=5)

        self.bind("&lt;Return&gt;", self.ok)
        self.bind("&lt;Escape&gt;", self.cancel)

        box.pack()

    #
    # standard button semantics

    def ok(self, event=None):

        if not self.validate():
            self.initial_focus.focus_set() # put focus back
            return

        self.withdraw()
        self.update_idletasks()

        self.apply()

        self.cancel()

    def cancel(self, event=None):

        # put focus back to the parent window
        if self.parent is not None:
            self.parent.focus_set()
        self.destroy()

    #
    # command hooks

    def validate(self):
        '''validate the data

        This method is called automatically to validate the data before the
        dialog is destroyed. By default, it always validates OK.
        '''

        return 1 # override

    def apply(self):
        '''process the data

        This method is called automatically to process the data, *after*
        the dialog is destroyed. By default, it does nothing.
        '''

        pass # override


# --------------------------------------------------------------------
# convenience dialogues

class _QueryDialog(Dialog):

    def __init__(self, title, prompt,
                 initialvalue=None,
                 minvalue = None, maxvalue = None,
                 parent = None):

        if not parent:
            import Tkinter
            parent = Tkinter._default_root

        self.prompt   = prompt
        self.minvalue = minvalue
        self.maxvalue = maxvalue

        self.initialvalue = initialvalue

        Dialog.__init__(self, parent, title)

    def destroy(self):
        self.entry = None
        Dialog.destroy(self)

    def body(self, master):

        w = Label(master, text=self.prompt, justify=LEFT)
        w.grid(row=0, padx=5, sticky=W)

        self.entry = Entry(master, name="entry")
        self.entry.grid(row=1, padx=5, sticky=W+E)

        if self.initialvalue:
            self.entry.insert(0, self.initialvalue)
            self.entry.select_range(0, END)

        return self.entry

    def validate(self):

        import tkMessageBox

        try:
            result = self.getresult()
        except ValueError:
            tkMessageBox.showwarning(
                "Illegal value",
                self.errormessage + "\nPlease try again",
                parent = self
            )
            return 0

        if self.minvalue is not None and result &lt; self.minvalue:
            tkMessageBox.showwarning(
                "Too small",
                "The allowed minimum value is %s. "
                "Please try again." % self.minvalue,
                parent = self
            )
            return 0

        if self.maxvalue is not None and result &gt; self.maxvalue:
            tkMessageBox.showwarning(
                "Too large",
                "The allowed maximum value is %s. "
                "Please try again." % self.maxvalue,
                parent = self
            )
            return 0

        self.result = result

        return 1


class _QueryInteger(_QueryDialog):
    errormessage = "Not an integer."
    def getresult(self):
        return int(self.entry.get())

def askinteger(title, prompt, **kw):
    '''get an integer from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is an integer
    '''
    d = apply(_QueryInteger, (title, prompt), kw)
    return d.result

class _QueryFloat(_QueryDialog):
    errormessage = "Not a floating point value."
    def getresult(self):
        return float(self.entry.get())

def askfloat(title, prompt, **kw):
    '''get a float from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a float
    '''
    d = apply(_QueryFloat, (title, prompt), kw)
    return d.result

class _QueryString(_QueryDialog):
    def __init__(self, *args, **kw):
        if kw.has_key("show"):
            self.__show = kw["show"]
            del kw["show"]
        else:
            self.__show = None
        _QueryDialog.__init__(self, *args, **kw)

    def body(self, master):
        entry = _QueryDialog.body(self, master)
        if self.__show is not None:
            entry.configure(show=self.__show)
        return entry

    def getresult(self):
        return self.entry.get()

def askstring(title, prompt, **kw):
    '''get a string from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a string
    '''
    d = apply(_QueryString, (title, prompt), kw)
    return d.result

if __name__ == "__main__":

    root = Tk()
    root.update()

    print askinteger("Spam", "Egg count", initialvalue=12*12)
    print askfloat("Spam", "Egg weight\n(in tons)", minvalue=1, maxvalue=100)
    print askstring("Spam", "Egg label")
</t>
<t tx="rodrigob.121403173614.564">class Dialog(Toplevel):

    '''Class to open dialogs.

    This class is intended as a base class for custom dialogs
    '''

    def __init__(self, parent, title = None):

        '''Initialize a dialog.

        Arguments:

            parent -- a parent window (the application window)

            title -- the dialog title
        '''
        Toplevel.__init__(self, parent)
        self.transient(parent)

        if title:
            self.title(title)

        self.parent = parent

        self.result = None

        body = Frame(self)
        self.initial_focus = self.body(body)
        body.pack(padx=5, pady=5)

        self.buttonbox()

        self.grab_set()

        if not self.initial_focus:
            self.initial_focus = self

        self.protocol("WM_DELETE_WINDOW", self.cancel)

        if self.parent is not None:
            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

        self.initial_focus.focus_set()

        self.wait_window(self)

    def destroy(self):
        '''Destroy the window'''
        self.initial_focus = None
        Toplevel.destroy(self)

    #
    # construction hooks

    def body(self, master):
        '''create dialog body.

        return widget that should have initial focus.
        This method should be overridden, and is called
        by the __init__ method.
        '''
        pass

    def buttonbox(self):
        '''add standard button box.

        override if you do not want the standard buttons
        '''

        box = Frame(self)

        w = Button(box, text="OK", width=10, command=self.ok, default=ACTIVE)
        w.pack(side=LEFT, padx=5, pady=5)
        w = Button(box, text="Cancel", width=10, command=self.cancel)
        w.pack(side=LEFT, padx=5, pady=5)

        self.bind("&lt;Return&gt;", self.ok)
        self.bind("&lt;Escape&gt;", self.cancel)

        box.pack()

    #
    # standard button semantics

    def ok(self, event=None):

        if not self.validate():
            self.initial_focus.focus_set() # put focus back
            return

        self.withdraw()
        self.update_idletasks()

        self.apply()

        self.cancel()

    def cancel(self, event=None):

        # put focus back to the parent window
        if self.parent is not None:
            self.parent.focus_set()
        self.destroy()

    #
    # command hooks

    def validate(self):
        '''validate the data

        This method is called automatically to validate the data before the
        dialog is destroyed. By default, it always validates OK.
        '''

        return 1 # override

    def apply(self):
        '''process the data

        This method is called automatically to process the data, *after*
        the dialog is destroyed. By default, it does nothing.
        '''

        pass # override

</t>
<t tx="rodrigob.121403173614.565"></t>
<t tx="rodrigob.121403173614.566"></t>
<t tx="rodrigob.121403173614.567">@nocolor

This file contains code for all plugins distributed with Leo.</t>
<t tx="rodrigob.121403173614.568">@nocolor

Scripting is fully documented in Leo's Users Guide, and the following should be enough to get you started:

@color

top() # The commander of the top (current) windows.
top().rootVnode() # The root vnode of the outline.
top().currentVnode() # The presently selected vnode.

@nocolor

If v is any vnode:
    
@color

v.headString() # is the headline of v.
v.bodyString() # is the body of v.
v.threadNext() # is node after v in outline order.

@nocolor

For example, this prints every headline of an outline:
    
@color

v = top().rootVnode()
while v:
    print v.headString()
    v = v.threadNext()
</t>
<t tx="rodrigob.121403173614.569">At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event 
"bodyclick2"            after  normal click in body       c,v,event 
"bodydclick1"  yes      before double click in body       c,v,event 
"bodydclick2"           after  double click in body       c,v,event 
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event 
"bodyrclick2"           after  right click in body        c,v,event 
"boxclick1"    yes      before click in +- box            c,v,event 
"boxclick2"             after  click in +- box            c,v,event 
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event 
"drag2"                 after  start of drag              c,v,event 
"dragging1"    yes      before continuing to drag         c,v,event 
"dragging2"             after  continuing to drag         c,v,event 
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event 
"enddrag2"              after  end of drag                c,v,event 
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"headclick1"   yes      before normal click in headline   c,v,event 
"headclick2"            after  normal click in headline   c,v,event 
"headrclick1"  yes      before right click in headline    c,v,event 
"headrclick2"           after  right click in headline    c,v,event 
"hypercclick1" yes      before control click in hyperlink c,v,event 
"hypercclick2"          after  control click in hyperlink c,v,event 
"hyperenter1"  yes      before entering hyperlink         c,v,event 
"hyperenter2"           after  entering hyperlink         c,v,event 
"hyperleave1"  yes      before leaving  hyperlink         c,v,event 
"hyperleave2"           after  leaving  hyperlink         c,v,event 
"iconclick1"   yes      before single click in icon box   c,v,event 
"iconclick2"            after  single click in icon box   c,v,event 
"iconrclick1"  yes      before right click in icon box    c,v,event 
"iconrclick2"           after  right click in icon box    c,v,event 
"icondclick1"  yes      before double click in icon box   c,v,event 
"icondclick2"           after  double click in icon box   c,v,event 
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v (note 3)
"menu2"        yes      before updating menus             c,v
"new"          no       during New command                old_c,new_c
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,old_v
"select2"               after  selecting a vnode          c,new_v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v 
"unselect2"             after  unselecting a vnode        c,old_v,old_v 
"@url1"        yes      before double-click @url node     c,v (note 5)
"@url2"                 after  double-click @url node     c,v (note 5)

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                   keys in keywords
(hook name)             overrides    when called               dictionary argument
---------               ---------    -----------               -------------------

"create-optional-menus"  no          (note 8)                  (note 8)

"draw-outine-box"        yes         start of drawBox          tree,v,x,y (note 6)
"draw-outline-icon"      yes         start of tree.drawIcon    tree,v,x,y (note 6)
"draw-outline-node"      yes         start of tree.drawNode    tree,v,x,y (note 6)
"draw-outline-text-box"  yes         start of tree.drawText    tree,v,x,y (note 6)
"draw-sub-outline"       yes         start of tree.drawTree    tree,v,x,y,h,level (note 6)
"redraw-entire-outline"  yes         start of tree.redraw      c (note 6)

"color-optional-markup"  yes *       (note 7)                  colorer,v (note 7)
"init-color-markup"      no          (note 7)                  colorer,v,s,i,j,colortag (note 7)

"new"                    no          start of New command      old_c,new_c (note 9)

"scan-directives"        no          in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open.
Leo will also call the "open1" and "open2" hooks if:
a) a file is opened using the Recent Files menu and
b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns
None.

(6) These stub hooks allow plugins to revise or completely replace how Leo
draws outlines. For example, you could change tree.drawIcon to add additional
icons. These stub hooks are really methods of the leoTree class, with the
"tree" keyword corresponding to the "self" parameter. These stub hooks are
called at the beginning of the indicated method. See the method themselves for
a description of the paramters.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.</t>
<t tx="rodrigob.121403173614.570">Naively using hooks can expose you and your .leo files to malicious attacks.

** Hooks should never blindly execute Python scripts in .leo files.

It is safe to import and execute code from Leo itself, provided that you got Leo from Leo's SourceForge site.</t>
<t tx="rodrigob.121403173614.571">@color
@ WARNING ***** Using the following routine exposes you malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
    def onLoadFile():
        v = top().rootVnode()
        while v:
            h = v.headString().lower()
            if match_word(h,0,"@onloadpythonscript"):
                s = v.bodyString()
                if s and len(s) &gt; 0:
                    try: # SECURITY BREACH: s may be malicious!
                        exec s + '\n' in {}
                    except:
                        es_exception()
            v = v.threadNext()</t>
<t tx="rodrigob.121403173614.572">@ignore
@ It is usually best not to catch exceptions in plugins.  doHook catches all exceptions and disables further calls to plugins.
</t>
<t tx="rodrigob.121403173614.573"></t>
<t tx="rodrigob.121403173614.574"></t>
<t tx="rodrigob.121403173614.575">"""Import cisco configuration files"""

from leoPlugins import *
from leoGlobals import *
import tkFileDialog

&lt;&lt; about this plugin &gt;&gt;
@others

if 0:
    registerHandler(("start2","open2","command2"), create_import_cisco_menu)
    
    __version__ = "1.3" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.576">@ This plugin adds a menu item under the File-&gt;Import menu to import
Cisco configuration files.

The plugin will:

1) create a new node, under the current node, where the configuration will be
written. This node will typically have references to several sections (see below).

2) create sections (child nodes) for the indented blocks present in the original
config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
there will be an 'interface' child node, with as many sub-nodes as there are real
interfaces in the configuration file).

3) create sections for the custom keywords specified in the customBlocks[] list in
importCiscoConfig(). You can modify this list to specify different keywords. DO
NOT put keywords that are followed by indented blocks (these are taken care of by
point 2 above). The negated form of the keywords (for example, if the keyword is
'service', the negated form is 'no service') is also included in the sections.

4) not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.

Feedback on this plugin can be sent to Davide Salomoni (dsalomoni@yahoo.com).
</t>
<t tx="rodrigob.121403173614.577">def create_import_cisco_menu(tag, keywords):
    if	(tag=="open2" or
        (tag=="start2" and not keywords.has_key('c')) or
        (tag=="command2" and keywords.get("label")=="new")):

        c = top()
        importMenu = c.frame.getMenu('import')
        newEntries = (
            ("-", None, None),
            ("Import C&amp;isco Configuration", "Shift+Ctrl+I", importCiscoConfig))
        
        c.frame.createMenuEntries(importMenu, newEntries)</t>
<t tx="rodrigob.121403173614.578">def importCiscoConfig(event=None):
    c = top(); current = c.currentVnode()
    if current == None: return
    &lt;&lt; open file &gt;&gt;

    # define which additional child nodes will be created
    # these keywords must NOT be followed by indented blocks
    customBlocks = ['aaa','ip as-path','ip prefix-list','ip route',
                    'ip community-list','access-list','snmp-server','ntp',
                    'boot','service','logging']
    out = []
    blocks = {}
    children = []
    lines = len(linelist)
    i = 0
    skipToNextLine = 0
    # create level-0 and level-1 children
    while i&lt;(lines-1):
        for customLine in customBlocks:
            if (linelist[i].startswith(customLine) or
                linelist[i].startswith('no %s' % customLine)):
                &lt;&lt; process custom line &gt;&gt;
                skipToNextLine = 1
                break
        if skipToNextLine:
            skipToNextLine = 0
        else:
            if linelist[i+1].startswith(' '):
                &lt;&lt; process indented block &gt;&gt;
            else:
                out.append(linelist[i])
        i=i+1
    # process last line
    out.append(linelist[i])
    
    &lt;&lt; complete outline &gt;&gt;</t>
<t tx="rodrigob.121403173614.579">name = tkFileDialog.askopenfilename(
    title="Import Cisco Configuration File",
    filetypes=[("All files", "*")]
    )
if name == "":	return

v = current.insertAsNthChild(0)
c.beginUpdate()
v.setHeadString("cisco config: %s" % name)
c.endUpdate()

try:
    fh = open(name)
    es("importing: %s" % name)
    linelist = fh.read().splitlines()
    fh.close()
except IOError,msg:
    es("error reading %s: %s" % (name, msg))
    return</t>
<t tx="rodrigob.121403173614.580">if not blocks.has_key(customLine):
    blocks[customLine] = []
    out.append(angleBrackets(customLine))
    # create first-level child
    child = v.insertAsNthChild(0)
    child.setHeadStringOrHeadline(angleBrackets(customLine))
    children.append(child)

blocks[customLine].append(linelist[i])</t>
<t tx="rodrigob.121403173614.581">space = linelist[i].find(' ')
if space == -1:
    space = len(linelist[i])
key = linelist[i][:space]
if not blocks.has_key(key):
    blocks[key] = []
    out.append(angleBrackets(key))
    # create first-level child
    child = v.insertAsNthChild(0)
    child.setHeadStringOrHeadline(angleBrackets(key))
    children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
    while linelist[i].startswith(' '):
        value.append(linelist[i])
        i = i+1
except:
    # EOF
    pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)</t>
<t tx="rodrigob.121403173614.582"># first print the level-0 text
outClean = []
prev = ''
for line in out:
    if line=='!' and prev=='!':
        pass # skip repeated comment lines
    else:
        outClean.append(line)
    prev = line
v.setBodyStringOrPane('\n'.join(outClean))

# scan through the created outline and add children
for child in children:
    # extract the key from the headline. Uhm... :)
    key = child.headString().split('&lt;&lt;'
        )[1].split('&gt;&gt;')[0].strip()
    if blocks.has_key(key):
        if type(blocks[key][0]) == type(''):
            # it's a string, no sub-children, so just print the text
            child.setBodyStringOrPane('\n'.join(blocks[key]))
        else:
            # it's a multi-level node
            for value in blocks[key]:
                # each value is a list containing the headline and then the text
                subchild = child.insertAsNthChild(0)
                subchild.setHeadStringOrHeadline(value[0])
                subchild.setBodyStringOrPane('\n'.join(value))
        child.sortChildren()
    else:
        # this should never happen
        es("Unknown key: %s" % key)
v.sortChildren()</t>
<t tx="rodrigob.121403173614.583">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="rodrigob.121403173614.584">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="rodrigob.121403173614.585">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="rodrigob.121403173614.586">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="rodrigob.121403173614.587">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="rodrigob.121403173614.588"></t>
<t tx="rodrigob.121403173614.589">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="rodrigob.121403173614.590">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="rodrigob.121403173614.591">controller SONET 1/0/0
 framing sdh</t>
<t tx="rodrigob.121403173614.592"></t>
<t tx="rodrigob.121403173614.593">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="rodrigob.121403173614.594">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="rodrigob.121403173614.595">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="rodrigob.121403173614.596">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="rodrigob.121403173614.597">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="rodrigob.121403173614.598">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="rodrigob.121403173614.599">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="rodrigob.121403173614.600">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="rodrigob.121403173614.601">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="rodrigob.121403173614.602">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="rodrigob.121403173614.603">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="rodrigob.121403173614.604">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="rodrigob.121403173614.605">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="rodrigob.121403173614.606">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="rodrigob.121403173614.607">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="rodrigob.121403173614.608">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="rodrigob.121403173614.609">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="rodrigob.121403173614.610">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="rodrigob.121403173614.611"></t>
<t tx="rodrigob.121403173614.612">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="rodrigob.121403173614.613">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="rodrigob.121403173614.614">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="rodrigob.121403173614.615">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="rodrigob.121403173614.616"></t>
<t tx="rodrigob.121403173614.617">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="rodrigob.121403173614.618">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="rodrigob.121403173614.619">route-map only3 permit 10
 match community 100</t>
<t tx="rodrigob.121403173614.620">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="rodrigob.121403173614.621">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="rodrigob.121403173614.622"></t>
<t tx="rodrigob.121403173614.623">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="rodrigob.121403173614.624">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="rodrigob.121403173614.625">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="rodrigob.121403173614.626">"""Modify the way exported outlines are displayed"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
    import leoNodes
    funcToMethod(newMoreHead,leoNodes.vnode,"moreHead")

@others

if 0: # Register the handlers...
    registerHandler("start2", onStart)
    
    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.627"># Returns the headline string in MORE format.

def newMoreHead (self,firstLevel,useVerticalBar=true):

    useVerticalBar = true # Force the vertical bar

    v = self
    level = self.level() - firstLevel
    if level &gt; 0:
        if useVerticalBar:
            s = " |\t" * level
        else:
            s = "\t"
    else:
        s = ""
    s += choose(v.hasChildren(), "+ ", "- ")
    s += v.headString()
    return s
</t>
<t tx="rodrigob.121403173614.628"></t>
<t tx="rodrigob.121403173614.629">"""Dump globals at startup"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("start2", onStart)

    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.630">def onStart (tag,keywords):

    print "\nglobals..."
    for s in globals():
        if s not in __builtins__:
            print s
    
    print "\nlocals..."
    for s in locals():
        if s not in __builtins__:
            print s
</t>
<t tx="rodrigob.121403173614.631">"""Enable debugging for garbage collector"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("start2", onStart)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.632">def onStart (tag,keywords):

    try:
        import gc
        gc.set_debug(gc.DEBUG_LEAK)
    except: pass</t>
<t tx="rodrigob.121403173614.633">"""Trace changes to objects at idle time"""

from leoPlugins import *
from leoGlobals import *

count = 0

def printIdleRefs(tag,keywords):
    printGcRefs(verbose=false)

def printIdleGC(tag,keywords):
    
    # Calling printGc is too expensive to do on every idle call.
    # Note: printGc only works if debugGc is true in leoGlobals.py.
    # At present, this code does _not_ set that constant.
    if tag == "idle":
        global count ; count += 1
        if (count % 20) == 0:
            # collectGarbage() # Has no effect.
            printGc(tag,onlyPrintChanges=true)
    else:
        printGc(tag,onlyPrintChanges=false)
        
if 0:
    registerHandler("command2", printIdleRefs)

if 0: # Register the handlers...
    if 1: # Very effective.
        registerHandler("idle", printIdleGC)
    else: # Very precise.
        registerHandler("all", printIdleGC)
    
    __version__ = "1.2"
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.634">"""Trace keystrokes in the outline and body panes"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.635">def onKey (tag,keywords):

    ch = keywords.get("ch")
    if ch and len(ch) &gt; 0:
        es("key",`ch`)</t>
<t tx="rodrigob.121403173614.636">"""Trace most comment events, but not key, drag or idle events"""

from leoPlugins import *
from leoGlobals import *

tagCount = 0

@others

if 0: # Register the handlers...
    registerHandler("all", trace_tags)

    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.637">def trace_tags (tag,keywords):

    # Almost all tags have both c and v keys in the keywords dict.
    if tag not in ("start1","end1","open1","open2"):
        c = keywords.get("c")
        v = keywords.get("v")
        if not c:
            print tag, "c = None"
        if not v:
            if tag not in ("select1","select2","unselect1","unselect2"):
                print tag, "v = None"
    
    if tag not in (
        "bodykey1","bodykey2","dragging1","dragging2",
        "headkey1","headkey2","idle"):
    
        global tagCount ; tagCount += 1 # Count all other hooks.
    
        if tag in ("command1","command2"):
            print tagCount,tag,keywords.get("label")
        elif tag in ("open1","open2"):
            print tagCount,tag,keywords.get("fileName")
        else:
            if 1: # Brief
                print tagCount,tag
            else: # Verbose
                keys = keywords.items()
                keys.sort()
                for key,value in keys:
                    print tagCount,tag,key,value
                print</t>
<t tx="rodrigob.121403173614.638"></t>
<t tx="rodrigob.121403173614.639">"""Support new @direcives"""

from leoPlugins import *
from leoGlobals import *

if 1:
    directives = "markup", # A tuple with one string.
else:
    directives = ("markup","markup2")
    
@others

if 1: # Register the handlers...

    registerHandler("start1",addPluginDirectives)
    registerHandler("scan-directives",scanPluginDirectives)
    
    __version__ = "1.1"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.640">def addPluginDirectives (tag,keywords):
    
    """Add all new directives to globalDirectivesList"""
    
    global directives

    if 0:
        s = ""
        for d in directives:
            s += '@' + d + ' '
        es(s,color="blue")

    for d in directives:
        if d not in globalDirectiveList:
            globalDirectiveList.append(d)</t>
<t tx="rodrigob.121403173614.641">def scanPluginDirectives (tag, keywords):
    
    """Add a tuple (d,v,s,k) to list for every directive d found"""
    
    global directives

    keys = ("c","v","s","old_dict","dict","pluginsList")
    c,v,s,old_dict,dict,pluginsList = [keywords.get(key) for key in keys]

    for d in directives:
        if not old_dict.has_key(d) and dict.has_key(d):
            # Point k at whatever follows the directive.
            k = dict[d]
            k += 1 + len(d) # Skip @directive
            k = skip_ws(s,k) # Skip whitespace
            # trace(`d`,`k`)
            pluginsList.append((d,v,s,k),)
</t>
<t tx="rodrigob.121403173614.642"></t>
<t tx="rodrigob.121403173614.643">"""Handle coloring for markup in doc parts and Python triple-double-quoted strings"""

from leoPlugins import *
from leoGlobals import *
import string  # zfill does not exist in Python 2.2.1

@others

if 1: # Register the handlers...

    registerHandler("color-optional-markup", colorWikiMarkup)
    registerHandler("init-color-markup", initAnyMarkup)

    __version__ = "1.1"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.644">def initAnyMarkup (tag,keywords):
    
    """initialize colorer.markup_string
    
    The colorer completely recolors the body pane when this changes"""
    
    keys = ("colorer","v")
    colorer,v = [keywords.get(key) for key in keys]

    c = colorer.commands
    if not c or not v or not top(): return

    # trace()
    dict = scanDirectives(c,v=v) # v arg is essential.
    pluginsList = dict.get("pluginsList")
    
    if pluginsList:
        for d,v,s,k in pluginsList:
            if d == "markup":
                kind = s[k:]
                if kind:
                    colorer.markup_string = kind
                    return
                    
    colorer.markup_string = "unknown" # default</t>
<t tx="rodrigob.121403173614.645">colorCount = 0

def colorWikiMarkup (tag,keywords):

    keys = ("colorer","v","s","i","j","colortag")
    colorer,v,s,i,j,colortag = [keywords.get(key) for key in keys]

    global colorCount ; colorCount += 1
    
    c = colorer.commands
    dict = scanDirectives(c,v=v) # v arg is essential.
    pluginsList = dict.get("pluginsList")
    
    if pluginsList:
        for d,v,s2,k in pluginsList:
            if d == "markup":
                # trace(`colorCount`,`d`)
                if match_word(s2,k,"wiki"):
                    doWikiText(colorer,v,s,i,j,colortag)
                    return true # We have colored the text.
            
    # trace(`colorCount`,"no markup")
    return None # We have not colored the text.</t>
<t tx="rodrigob.121403173614.646">def doWikiText (colorer,v,s,i,end,colortag):

    firsti = i ; inserted = 0

    while i &lt; end:
        &lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;
        if first:
            tag,n1,n2,delim1,delim2 = first
            i = n2 + len(delim2)
            &lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;
        else: i = end
        
    colorer.tag(colortag,firsti,end+inserted)</t>
<t tx="rodrigob.121403173614.647">first = None

for tag,delim1,delim2 in (
    ("bold","__","__"),
    ("italic","''","''"),
    ("picture","{picture file=","}"),
    ("color","~~","~~")):
    n1 = s.find(delim1,i,end)
    if n1 &gt; -1:
        n2 = s.find(delim2,n1+len(delim1),end)
        if n2 &gt; -1:
            if not first or (first and n1 &lt; first[1]):
                first = tag,n1,n2,delim1,delim2
</t>
<t tx="rodrigob.121403173614.648">if tag =="picture":
    colorer.tag("elide",n1,n2+len(delim2)) # Elide everything.
    filename = s[n1+len(delim1):n2]
    filename = os.path.join(app().loadDir,filename)
    filename = os.path.normpath(filename)
    inserted += insertWikiPicture(colorer,filename,n2+len(delim2))
elif tag == "color":
    &lt;&lt; parse and handle color field &gt;&gt;
else:
    # look for nested bold or italic.
    if tag == "bold":
        delim3,delim4 = "''","''" # Look for nested italic.
    else:
        delim3,delim4 = "__","__" # Look for nested bold.
    n3 = s.find(delim3,n1+len(delim1),n2) ; n4 = -1
    if n3 &gt; -1:
        n4 = s.find(delim4,n3+len(delim3),n2+len(delim2))
    if n3 &gt; -1 and n4 &gt; -1:
        colorer.tag("elide",n1,n1+len(delim1))
        colorer.tag("elide",n2,n2+len(delim2))
        colorer.tag("elide",n3,n3+len(delim3))
        colorer.tag("elide",n4,n4+len(delim4))
        colorer.tag(tag,n1+len(delim1),n3)
        colorer.tag("bolditalic",n3+len(delim3),n4)
        colorer.tag(tag,n4+len(delim4),n2)
    else:
        # No nested tag.
        colorer.tag("elide",n1,n1+len(delim1))
        colorer.tag("elide",n2,n2+len(delim2))
        colorer.tag(tag,n1+len(delim1),n2)</t>
<t tx="rodrigob.121403173614.649"># Parse the color value.
j = n1+len(delim1)
n = s.find(":",j,n2)
if n2 &gt; n &gt; j &gt; -1:
    name = s[j:n]
    if name[0] == '#' and len(name) &gt; 1:
        name = '#' + string.zfill(name[1:],6)
    if name in colorer.color_tags_list:
        colorer.tag("elide",n1,n+1)
        colorer.tag(name,n+1,n2)
        colorer.tag("elide",n2,n2+len(delim2))
    else:
        try:
            # print "entering", name
            colorer.body.tag_configure(name,foreground=name)
            colorer.color_tags_list.append(name)
            colorer.tag("elide",n1,n+1)
            colorer.tag(name,n+1,n2)
            colorer.tag("elide",n2,n2+len(delim2))
        except: # an invalid color name: elide nothing.
            pass # es_exception()</t>
<t tx="rodrigob.121403173614.650">def insertWikiPicture (colorer,filename,i):
    
    """Try to insert a picture with the give filename.
    
    Returns the number of characters actually inserted"""
    
    # trace(`colorer.color_pass`)
    if colorer.color_pass == 0:
        colorer.redoColoring = true # schedule a two-pass recoloring.
        return 0
        
    if colorer.color_pass == 2:
        return 0 # The second redo pass.
        
    # trace(`filename`,`v`)
    if not os.path.exists(filename):
        return 0

    try:
        # Create the image
        photo = Tkinter.PhotoImage(master=app().root, file=filename)
        image = colorer.body.image_create(colorer.index(i),image=photo,padx=0)
        
        # Keep references so images stay on the canvas.
        colorer.image_references.append((photo,image,colorer.line_index,i),)
        return 1
    except:
        es_exception()
        return 0</t>
<t tx="rodrigob.121403173614.651">"""Handle images in body text"""

from leoPlugins import *
from leoGlobals import *

@others

if 1: # Register the handlers...
    registerHandler("select2", onSelect)
    registerHandler("unselect1", onUnselect)
    
    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.652">def onSelect (tag,keywords):

    import Tkinter,os

    new_v = keywords.get("new_v")
    h = new_v.headString()
    if h[:7] == "@image ":
        filename = h[7:]
        &lt;&lt; Select Image &gt;&gt;</t>
<t tx="rodrigob.121403173614.653"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
    try:
        # Note that Tkinter only understands GIF
        photo = Tkinter.PhotoImage(master=a.root, file=filename)
    except:
        es("error: cannot load image")
        return
    # Nicely display the image at the center top and push the text below.
    a.gsphoto = photo # This is soooo important.
    photoWidth = photo.width()
    bodyWidth = body.winfo_width()
    padding = int((bodyWidth - photoWidth - 16) / 2)
    padding = max(0,padding)
    a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
    es("warning: missing image file")</t>
<t tx="rodrigob.121403173614.654">def onUnselect (tag,keywords):

    import Tkinter, os.path

    a = app()
    old_v = keywords.get("old_v")
    if old_v:
        h = old_v.headString()
        if h[:7] == "@image ":
            &lt;&lt; Unselect Image &gt;&gt;					
    else: # Leo is initializing.
        a.gsphoto = None # Holds our photo file
        a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="rodrigob.121403173614.655"># Erase image if it was previously displayed
a = app() ; c = keywords.get("c")

if a.gsimage:
    try:
         c.frame.body.delete(a.gsimage)
    except:
        es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="rodrigob.121403173614.656">"""Adds navigation buttons to icon bar"""

from leoPlugins import *
from leoGlobals import *
from leoDialog import listBoxDialog
import os, Tkinter

@others
    
globalInfo = globalInfoClass()

Tk = Tkinter

if 1: # Register the handlers...

    registerHandler("after-create-leo-frame", globalInfo.addNavWidgets)
    registerHandler("select2",globalInfo.updateRecentSections)
    registerHandler("command2",globalInfo.updateMarksAfterCommand)
    registerHandler(("set-mark","clear-mark"),globalInfo.updateMarks)
    registerHandler("close-frame",globalInfo.destroyFrame)
    registerHandler("destroy-all-global-windows",globalInfo.destroyAllFrames)

    # 7/12/03: Moved marksDialog and recentSectionsDialog into this plugin.
    # 7/12/03: Handled "set-mark" and "clear-mark" hooks.
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.657">class commanderInfoClass:
    @others</t>
<t tx="rodrigob.121403173614.658">def __init__ (self,c,globalInfo):
    
    self.c = c
    self.globalInfo = globalInfo
    
    # The icon frame in c.
    self.iconFrame = c.frame.iconFrame
    
    # Dialogs.
    self.marksDialog = None
    self.recentSectionsDialog = None

    # Images for arrow buttons.
    self.lt_nav_disabled_image = self.lt_nav_enabled_image = None
    self.rt_nav_disabled_image = self.rt_nav_enabled_image = None
    
    # The arrow and text buttons.
    self.lt_nav_button = self.rt_nav_button = None
    sections_button = self.marks_button = None
    
    self.nav_buttons = None
</t>
<t tx="rodrigob.121403173614.659">def addWidgets (self):
    
    c = self.c ; d = self
    
    d.lt_nav_disabled_image = self.createImage("../Icons/lt_arrow_disabled.gif")
    d.lt_nav_enabled_image  = self.createImage("../Icons/lt_arrow_enabled.gif")
    
    d.rt_nav_disabled_image = self.createImage("../Icons/rt_arrow_disabled.gif")
    d.rt_nav_enabled_image  = self.createImage("../Icons/rt_arrow_enabled.gif")
    
    for image in (
        self.lt_nav_disabled_image, self.lt_nav_enabled_image,
        self.rt_nav_disabled_image, self.rt_nav_enabled_image):
        if not image:
            return
    
    # It's so nice to be able to add ivars to classes at any time!
    self.lt_nav_button = c.frame.addIconButton(
        image=self.lt_nav_disabled_image,
        command=c.frame.OnGoPrevVisitedNode)
        
    &lt;&lt; define callbacks &gt;&gt;

    self.sections_button = c.frame.addIconButton(
        text="Recent",command=onRecentButton)
        
    self.marks_button = c.frame.addIconButton(
        text="Marks",command=onMarksButton)
    
    self.rt_nav_button = c.frame.addIconButton(
        image=self.rt_nav_disabled_image,
        command=c.frame.OnGoNextVisitedNode)
        
    # Don't dim the button when it is inactive.
    for b in (self.lt_nav_button,self.rt_nav_button):
        fg = b.cget("foreground")
        b.configure(disabledforeground=fg)
        
    # Package these buttons for the recentSectionsDialog class in leoDialog.py
    self.nav_buttons = (self.lt_nav_button, self.rt_nav_button)</t>
<t tx="rodrigob.121403173614.660"># These are functions, not methods, so we must bind self at definition time.

def onMarksButton(self=self):

    self.marksButtonCallback()
    
def onRecentButton(self=self):

    self.recentButtonCallback()</t>
<t tx="rodrigob.121403173614.661">def createImage (self,path):
    
    path = os.path.join(app().loadDir,path)
    path = os.path.normpath(path)
    
    try:
        image = Tkinter.PhotoImage(master=app().root,file=path)
    except:
        es("can not load icon: " + shortFileName(path))
        image = None
    return image

</t>
<t tx="rodrigob.121403173614.662">def updateNavButtons (self):	

    d = self ; c = self.c
    
    # Make sure we have initialized properly.
    if not hasattr(d,"lt_nav_button") or not hasattr(d,"rt_nav_button"):
        return
        
    if not d.lt_nav_button or not d.rt_nav_button: # 6/30/03
        return
    
    b = d.lt_nav_button
    if c.beadPointer &gt; 0:
        image = self.lt_nav_enabled_image
        state = "normal"
    else:
        image = d.lt_nav_disabled_image
        state = "normal" # "disabled" makes the icon look bad.
    b.configure(image=image,state=state)
    
    b = d.rt_nav_button
    if c.beadPointer + 1 &lt; len(c.beadList):
        image =self.rt_nav_enabled_image
        state = "normal"
    else:
        image = self.rt_nav_disabled_image
        state = "normal" # "disabled" makes the icon look bad.
    b.configure(image=image,state=state)
</t>
<t tx="rodrigob.121403173614.663"></t>
<t tx="rodrigob.121403173614.664">def marksButtonCallback(self,event=None):
    
    c = self.c ; d = self.marksDialog

    if d:
        d.top.deiconify()
    else:
        # Create and run the dialog.
        title = "Marks"
        label = "Marks: " + shortFileName(c.frame.mFileName)
        d = marksDialog(c,title,label)
        self.marksDialog = d
        d.root.wait_window(d.top)
</t>
<t tx="rodrigob.121403173614.665">def recentButtonCallback(self,event=None):
    
    c = self.c ; d = self.recentSectionsDialog
    
    if d:
        d.top.deiconify()
        d.fillbox()
    else:
        # Create and run the dialog.]
        title = "Recent Nodes"
        label = "Recent nodes: " + shortFileName(c.frame.mFileName)
        d = recentSectionsDialog(c,self.nav_buttons,title,label)
        self.recentSectionsDialog = d
        d.root.wait_window(d.top)
</t>
<t tx="rodrigob.121403173614.666">class globalInfoClass:
    @others</t>
<t tx="rodrigob.121403173614.667">def __init__ (self):
    
    self.commanderInfo = {} # keys are commanders, values are navCommanderInfo objects
</t>
<t tx="rodrigob.121403173614.668">def addNavWidgets(self,tag,keywords):
    
    c = keywords.get("c")
    
    # Create the commanderInfo object.
    d = commanderInfoClass(c,self)
    self.commanderInfo[c] = d
    
    # Add the widgets.
    d.addWidgets()
    
</t>
<t tx="rodrigob.121403173614.669">def destroyAllFrames(self,tag,keywords):
    
    for d in self.commanderInfo.values():
        self.destroyOneFrame(d)
        
def destroyFrame(self,tag,keywords):

    c = keywords.get("c")
    d = self.commanderInfo.get(c)
    if d:
        self.destroyOneFrame(d)
        
def destroyOneFrame(self,d):

    if d.marksDialog:
        d.marksDialog.top.destroy()
    if d.recentSectionsDialog:
        d.recentSectionsDialog.top.destroy()
    del self.commanderInfo[d.c]</t>
<t tx="rodrigob.121403173614.670">def updateRecentSections (self,tag,keywords):
    
    c = keywords.get("c")
    info = self.commanderInfo.get(c)

    if info:
        info.updateNavButtons()
        d = info.recentSectionsDialog
        if d:
            d.fillbox()
</t>
<t tx="rodrigob.121403173614.671">def updateMarksAfterCommand (self,tag,keywords):
    
    """Update the marks dialog when a new window is opened."""
    
    name = keywords.get("label")
    
    if name and name.lower() in ("open","new"):
        self.updateMarks(tag,keywords)
    
def updateMarks (self,tag,keywords):
    
    """Update the marks dialog."""
    
    c = keywords.get("c")
    # trace()
    info = self.commanderInfo.get(c)
    if info and info.marksDialog:
        info.marksDialog.fillbox()</t>
<t tx="rodrigob.121403173614.672">def updateNavButtons (self,tag,keywords):

    """Update the colors of c's nav buttons"""
    
    c = keywords.get("c")
    info = self.commanderInfo.get(c)
    
    if info:
        info.updateNavButtons()
</t>
<t tx="rodrigob.121403173614.673">class marksDialog (listBoxDialog):
    
    """A class to create the marks dialog"""

    @others</t>
<t tx="rodrigob.121403173614.674">def __init__ (self,c,title,label):
    
    """Create a Marks listbox dialog."""

    listBoxDialog.__init__(self,c,title,label)
</t>
<t tx="rodrigob.121403173614.675">def createFrame(self):
    
    """Create the frame for a Marks listbox dialog."""

    listBoxDialog.createFrame(self)
    self.addButtons()</t>
<t tx="rodrigob.121403173614.676">def addButtons (self):
    
    """Add buttons to a Marks listbox dialog."""
    
    f = Tk.Frame(self.outerFrame)
    f.pack()
    self.addStdButtons(f)</t>
<t tx="rodrigob.121403173614.677">def fillbox(self,event=None):

    """Update a Marks listbox dialog and update the listbox and update vnodeList &amp; tnodeList ivars"""

    self.box.delete(0,"end")
    self.vnodeList = []
    self.tnodeList = []

    # Make sure the node still exists.
    # Insert only the last cloned node.
    c = self.c ; v = c.rootVnode()
    i = 0
    while v:
        if v.isMarked() and v.t not in self.tnodeList:
            self.box.insert(i,v.headString().strip())
            self.tnodeList.append(v.t)
            self.vnodeList.append(v)
            i += 1
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.678">class recentSectionsDialog (listBoxDialog):
    
    """A class to create the recent sections dialog"""

    @others</t>
<t tx="rodrigob.121403173614.679">def __init__ (self,c,buttons,title,label):
    
    """Create a Recent Sections listbox dialog."""
    
    self.lt_nav_iconFrame_button, self.rt_nav_iconFrame_button = buttons

    listBoxDialog.__init__(self,c,title,label)

</t>
<t tx="rodrigob.121403173614.680">def addButtons (self):
    
    """Add buttons for a Recent Sections listbox dialog."""

    self.buttonFrame = f = Tk.Frame(self.outerFrame)
    f.pack()
    
    row1 = Tk.Frame(f)
    row1.pack()
    
    # Create the back and forward buttons, cloning the images &amp; commands of the already existing buttons.
    image   = self.lt_nav_iconFrame_button.cget("image")
    command = self.lt_nav_iconFrame_button.cget("command")

    self.lt_nav_button = b = Tk.Button(row1,image=image,command=command)
    b.pack(side="left",pady=2,padx=5)
    
    image   = self.rt_nav_iconFrame_button.cget("image")
    command = self.rt_nav_iconFrame_button.cget("command")

    self.rt_nav_button = b = Tk.Button(row1,image=image,command=command)
    b.pack(side="left",pady=2,padx=5)
    
    row2 = Tk.Frame(f)
    row2.pack()
    self.addStdButtons(row2)
    
    row3 = Tk.Frame(f)
    row3.pack()
    
    self.clear_button = b =  Tk.Button(row3,text="Clear All",
        width=6,command=self.clearAll)
    b.pack(side="left",pady=2,padx=5)
    
    self.delete_button = b =  Tk.Button(row3,text="Delete",
        width=6,command=self.deleteEntry)
    b.pack(side="left",pady=2,padx=5)
</t>
<t tx="rodrigob.121403173614.681">def clearAll (self,event=None):

    """Handle clicks in the "Delete" button of the Recent Sections listbox dialog."""

    self.c.visitedList = []
    self.vnodeList = []
    self.fillbox()
</t>
<t tx="rodrigob.121403173614.682">def createFrame(self):
    
    """Create the frame of a Recent Sections listbox dialog."""
    
    listBoxDialog.createFrame(self)	
    self.addButtons()
</t>
<t tx="rodrigob.121403173614.683">def deleteEntry (self,event=None):

    """Handle clicks in the "Delete" button of a Recent Sections listbox dialog."""
    
    c = self.c ; box = self.box
    
    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        v = self.vnodeList[n]
        del self.vnodeList[n]
        if v in c.visitedList:
            c.visitedList.remove(v)
        self.fillbox()
</t>
<t tx="rodrigob.121403173614.684">def destroy (self,event=None):
    
    """Hide a Recent Sections listbox dialog and mark it inactive.
    
    This is an escape from possible performace penalties"""
        
    # This is enough to disable fillbox.
    self.top.withdraw()
</t>
<t tx="rodrigob.121403173614.685">def fillbox(self,event=None):

    """Update a Recent Sections listbox dialog and update vnodeList &amp; tnodeList ivars"""

    # Only fill the box if the dialog is visible.
    # This is an important protection against bad performance.

    if self.top.state() == "normal":
        &lt;&lt; reconstruct the contents of self.box &gt;&gt;
        self.synchButtons()</t>
<t tx="rodrigob.121403173614.686">c = self.c

self.box.delete(0,"end")
self.vnodeList = []
self.tnodeList = []

# Make sure the node still exists.
# Insert only the last cloned node.
i = 0
for v in c.visitedList:
    if v.exists(self.c) and v.t not in self.tnodeList:
        self.box.insert(i,v.headString().strip())
        self.tnodeList.append(v.t)
        self.vnodeList.append(v)
        i += 1
</t>
<t tx="rodrigob.121403173614.687">def synchButtons (self):
    
    """Synchronize the arrow boxes of a Recent Sections listbox dialog."""

    image = self.lt_nav_iconFrame_button.cget("image")
    self.lt_nav_button.configure(image=image)
    
    image = self.rt_nav_iconFrame_button.cget("image")
    self.rt_nav_button.configure(image=image)</t>
<t tx="rodrigob.121403173614.688"></t>
<t tx="rodrigob.121403173614.689">"""Create menu for Open With command and handle the resulting commands"""

from leoPlugins import *
from leoGlobals import *

@others

if 1: # Register the handlers...

    app().hasOpenWithMenu = true
    registerHandler("idle", on_idle)
    registerHandler(("start2","open2","command2"), create_open_with_menu)

    __version__ = "1.4" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.690"># frame.OnOpenWith creates the dict with the following entries:
# "body", "c", "encoding", "f", "path", "time" and "v".

def on_idle (tag,keywords):

    import os
    a = app()
    for dict in a.openWithFiles:
        path = dict.get("path")
        c = dict.get("c")
        encoding = dict.get("encoding",None)
        v = dict.get("v")
        old_body = dict.get("body")
        if path and os.path.exists(path):
            try:
                time = os.path.getmtime(path)
                if time and time != dict.get("time"):
                    dict["time"] = time # inhibit endless dialog loop.
                    # The file has changed.
                    &lt;&lt; update v's body text &gt;&gt;
            except:
                es_exception() ## testing
                pass</t>
<t tx="rodrigob.121403173614.691">&lt;&lt; set s to the file text &gt;&gt;

# Convert body to whatever encoding is in effect.
body = v.bodyString()
body = toEncodedString(body,encoding,reportErrors=true)

conflict = body != old_body and body != s

# Set update if we should update the outline from the file.
if conflict:
    # See how the user wants to resolve the conflict.
    import leoDialog
    es("conflict in " + shortFileName(path),color="red")
    message = "Replace changed outline with external changes?"
    result = leoDialog.askYesNo("Conflict!",message).run(modal=true)
    update = result.lower() == "yes"
else:
    update = s != body

if update:
    es("updated from: " + shortFileName(path),color="blue")
    v.setBodyStringOrPane(s)
    c.selectVnode(v)
    dict["body"] = s
elif conflict:
    es("not updated from: " + shortFileName(path),color="blue")</t>
<t tx="rodrigob.121403173614.692">try:
    # Update v from the changed temp file.
    f=open(path)
    s=f.read()
    f.close()
except:
    es("can not open " + shortFileName(path))
    break
</t>
<t tx="rodrigob.121403173614.693">def create_open_with_menu (tag,keywords):

    if  (tag in ("start2","open2") or
        (tag=="command2" and keywords.get("label")=="new")):

        &lt;&lt; create the Open With menu &gt;&gt;
        # Enable the idle-time hook so we can check temp files created by Open With.
        from leoGlobals import enableIdleTimeHook
        enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="rodrigob.121403173614.694">@ Entries in the following table are the tuple (commandName,shortcut,data).

- data is the tuple (command,arg,ext).
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
    table = (
        # Opening idle this way doesn't work so well.
        # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
        ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
        ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
elif 1: # Test table.
    table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
else: # David McNab's table.
    table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

top().frame.createOpenWithMenuFromTable(table)</t>
<t tx="rodrigob.121403173614.695">"""vim handler"""

# Contributed by Andrea Galimberti.

#  To use this plugin do the following:
#
# - Start VIM as server: vim --servername "VIM"
#   The name of the server *must* be "VIM".
#
# - Single-click on a node's icon to open that node in VIM.
#
# - Leo will update the node in the outline when you save the file in VIM.

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("iconclick2", open_in_vim)
    
    __version__ = "1.3" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.696">def open_in_vim (tag,keywords):
    if not top():
        return

    v=keywords['v']
    # Find dictionary with infos about this node
    this=filter(lambda x: id(x['v'])==id(v), app().openWithFiles)
    
    # Retrieve the name of the temporary file (if any).
    if this != []:
        path=this[0]['path']
    else:
        path=''

    if os.path.exists(path):
        # Get previous node contents.
        try:
            old=v.OpenWithOldBody
        except AttributeError:
            old=''

    if v.bodyString() != old:
        # delete old temp file
        os.remove(path)
        # remove old temp file from list
        app().openWithFiles=filter(lambda x: x['path']!=path,app().openWithFiles)
        # update old body with new contents
        v.OpenWithOldBody=v.bodyString()
        # open the node in vim (note the space after --remote)
        top().frame.OnOpenWith(("os.system", "vim --remote ", None),) # 6/27/03: add comma.</t>
<t tx="rodrigob.121403173614.697">"""emacs handler"""

from leoPlugins import *
from leoGlobals import *

def open_in_emacs (tag,keywords):
    if top():
        top().frame.OnOpenWith(("os.spawnl", "/usr/bin/gnuclient", None),) # 6/27/03: add comma.

if 0: # Register the handlers...
    registerHandler(("iconclick2","select2"), open_in_emacs)
    
    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.698"></t>
<t tx="rodrigob.121403173614.699">"""Open any empty file as a minimal .leo file"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; define minimal .leo file &gt;&gt;
@others

if 0: # Register the handlers...
    registerHandler("open1", onOpen)
    
    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.700">empty_leo_file = """&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5"&gt;
    &lt;global_window_position top="145" left="110" height="24" width="80"/&gt;
    &lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0"&gt;
&lt;/preferences&gt;
&lt;find_panel_settings&gt;
    &lt;find_string&gt;&lt;/find_string&gt;
    &lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes&gt;
&lt;v a="V"&gt;&lt;vh&gt;NewHeadline&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;"""</t>
<t tx="rodrigob.121403173614.701">def onOpen (tag,keywords):

    import os
    file_name = keywords.get('fileName')

    if file_name and os.path.getsize(file_name)==0:
        # Rewrite the file before really opening it.
        es("rewriting empty .leo file: %s" % (file_name))
        file = open(file_name,'w')
        file.write(empty_leo_file)
        file.flush()
        file.close()

</t>
<t tx="rodrigob.121403173614.702">@language python

"""Opens up cmd and explorer window to same directory 
as @file nodes or children ..."""

&lt;&lt; about the open shell plugin &gt;&gt;

import leo,os,os.path,sys
from leoPlugins import *
from leoGlobals import *

pathToExplorer = 'c:/windows/explorer.exe'
pathToCmd = 'c:/windows/system32/cmd.exe'

@others

if 0: # Register the plugin

    registerHandler("after-create-leo-frame", load_menu)
    __version__ = "1.3"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.703">@ Written by Ed Taekema.  Modified by E.K.Ream

Please submit bugs / feature requests to etaekema@earthlink.net"""

This is a simple plugin for leo 3.12 that allows the user to open either an xterm on linux or a cmd windows/explorer window on win32 in the directory of the current @file.  This allows quick navigation to facilitate testing and navigating large systems with complex direcgtories.

Current limitations ...

1. Not tested on Mac OS X ...
2. On win32, the cmd window will not open in the right directory if the @file location is on a different drive than the .leo file that is being edited.
3. On linux, xterm must be in your path.
</t>
<t tx="rodrigob.121403173614.704">def load_menu(tag,keywords):
    
    if sys.platform=="win32":
        table = (
            ("&amp;Open Console Window",None,launchCmd),
            ("Open &amp;Explorer",None,launchExplorer)) 
    else:
        table = ( ("Open &amp;xterm",None,launchxTerm), ) 
    
    top().frame.createNewMenu("E&amp;xtensions","top")
    top().frame.createMenuItemsFromTable("Extensions",table)
</t>
<t tx="rodrigob.121403173614.705">def _getpath(c,v):
    dict = scanDirectives(c,v)
    d = dict.get("path")

    if d == None:

        if v.isAtFileNode():
            filename = v.atFileNodeName()
        if v.isAtNoSentinelsFileNode():
            filename = v.atNoSentinelsFileNodeName()
        if v.isAtRawFileNode():
            filename = v.atRawFileNodeName()
        if v.isAtSilentFileNode():
            filename = v.atSilentFileNodeName()

        d = os.path.dirname(filename)

    d = os.path.normpath(d)
    return d
</t>
<t tx="rodrigob.121403173614.706">def _getCurrentNodePath():
    c = leo.top()
    v = c.currentVnode()
    f = v.atFileNodeName()
    d = _getpath(c,v)
    return d
</t>
<t tx="rodrigob.121403173614.707">def launchCmd(not_used):
    
    global pathToCmd

    d = _getCurrentNodePath()
    myCmd = 'cd ' + d
    os.spawnl(os.P_NOWAIT, pathToCmd, '/k ', myCmd)</t>
<t tx="rodrigob.121403173614.708">def launchExplorer(not_used):
    
    global pathToExplorer

    d = _getCurrentNodePath()
    os.spawnl(os.P_NOWAIT,pathToExplorer, ' ', d)

</t>
<t tx="rodrigob.121403173614.709">def launchxTerm(not_used):

    d = _getCurrentNodePath()
    curdir = os.getcwd()
    os.chdir(d)
    os.spawnlp(os.P_NOWAIT, 'xterm', '-title Leo')
    os.chdir(curdir)</t>
<t tx="rodrigob.121403173614.710"></t>
<t tx="rodrigob.121403173614.711">"""Translate a few menu items into French"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler(("start1","menu1"), onMenu)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.712">@ The translation table used by setRealMenuNamesFromTable has entries of the form:

    ("official name","translated name"),

Ampersands in the translated name indicate that the following character is to be underlined.

The official name can be any name equivalent to the standard English menu names.  Leo "canonicalizes" the official name by converting to lower case and removing any non-letters.  Thus, the following are  equivalent:
    ("Open...","&amp;Ouvre"),
    ("open",   "&amp;Ouvre"),
    ("&amp;Open",  "&amp;Ouvre"),
@c
def onMenu (tag,keywords):
    table = (
        ("Open...","&amp;Ouvre"),
        ("OpenWith","O&amp;uvre Avec..."),
        ("close","&amp;Ferme"),
        ("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
        ("Redo Typing","French &amp;Redo Typing"),
        ("Can't Undo", "French Can't Undo"),
        ("Can't Redo", "French Can't Redo"))
    # Call the convenience routine to do the work.
    app().setRealMenuNamesFromTable(table)
</t>
<t tx="rodrigob.121403173614.713">@language python

"""traduit les menus en Français"""

# French translation completed by Frédéric Momméja, Spring 2003

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler(("start1","menu1"), onMenu)
    
    __version__ = "1.4" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.714">def onMenu (tag,keywords):
    table = (
        ("File","&amp;Fichier"),
            ("New","&amp;Nouveau"),
            ("Open...","&amp;Ouvrir"),
            ("OpenWith","Ouvrir Ave&amp;c..."),
            ("Close","&amp;Fermer"),
            ("Save","Enregi&amp;strer"),
            ("Save As","Enre&amp;gistrer sous..."),
            ("Save To","Enregistrer une co&amp;pie..."),
            ("Revert To Saved","&amp;Version Enregistrée"),
            ("Recent Files...","&amp;Fichiers récents..."),
            ("Read/Write...", "&amp;Lire/Écrire..."),
                ("Read Outline Only", "Relire &amp;Arborescence seule"),
                ("Read @file Nodes", "Relire Structure @&amp;file seule"),
                ("Write missing @file Nodes", "Écrire @file &amp;manquants sur Disque"),
                ("Write Outline Only", "Écrire Arborescence &amp;seule"),
                ("Write @file Nodes", "Écrire &amp;Noeuds @file seuls"),
            ("Tangle...", "&amp;Transférer (Tangle)..."),
                ("Tangle All", "&amp;Tout"),
                ("Tangle Marked", "Noeuds &amp;Marqués"),
                ("Tangle", "&amp;Sélection"),
            ("Untangle...", "&amp;Ramener (Untangle)..."),
                ("Untangle All", "&amp;Tout"),
                ("Untangle Marked", "Noeuds &amp;Marqués"),
                ("Untangle", "&amp;Sélection"),
            ("Import...", "&amp;Importer..."),
                ("Import To @file", "Dans Structure @&amp;file"),
                ("Import To @root", "Dans Structure @&amp;root"),
                ("Import CWEB Files", "Fichier &amp;CWEB"),
                ("Import noweb Files", "Fichier &amp;Noweb"),
                ("Import Flattened Outline", "Fichier &amp;MORE"),
            ("Export...", "&amp;Exporter..."),
                ("Export Headlines", "&amp;Entêtes Noeuds descendants vers .txt"),
                ("Outline To CWEB", "Arborescence vers &amp;CWEB"),
                ("Outline To Noweb", "Arborescence vers &amp;Noweb"),
                ("Flatten Outline", "Arborescence vers &amp;MORE"),
                ("Remove Sentinels", "En supprimant &amp;Sentinelles"),
                ("Weave", "&amp;Arborescence descendante vers .txt"),
            ("Exit","&amp;Quitter"),
        ("Edit","&amp;Edition"),
            ("Undo Typing","Ann&amp;uler saisie"),
            ("Redo Typing","&amp;Répèter saisie"),
            ("Can't Undo", "Impossible d'annuler"),
            ("Can't Redo", "Impossible de répéter"),
            ("Cut", "C&amp;ouper"),
            ("Copy", "Co&amp;pier"),
            ("Paste", "Co&amp;ller"),
            ("Delete", "&amp;Supprimer"),
            ("Select All", "&amp;Tout Sélectionner"),
            ("Edit Body...", "Éditer &amp;Contenu..."),
                ("Extract Section", "E&amp;xtraire Section"),
                ("Extract Names", "Extraire &amp;Noms de Sections"),
                ("Extract", "&amp;Extraire Sélection"),
                ("Convert All Blanks", "Convertir Espaces &amp;Arborescence"),
                ("Convert All Tabs", "Convertir Tabulations Ar&amp;borescence"),
                ("Convert Blanks", "Convertir &amp;Espaces"),
                ("Convert Tabs", "Convertir &amp;Tabulations"),
                ("Insert Body Time/Date", "Insérer la &amp;Date/Heure"),
                ("Reformat Paragraph", "Reformater &amp;Paragraphe"),
                ("Indent", "&amp;Indenter"),
                ("Unindent", "Dé&amp;sindenter"),
                ("Match Brackets", "&amp;Vérifier Parité des Signes"), #  &lt;({["), #EKR
            ("Edit Headline...", "Éditer &amp;Entête..."),
                ("Edit Headline", "&amp;Modifier l'Entête"),
                ("End Edit Headline", "Modification &amp;Terminée"),
                ("Abort Edit Headline", "&amp;Annuler Modification"),
                ("Insert Headline Time/Date", "Insérer la &amp;Date/Heure"),
                ("Toggle Angle Brackets", "Ajouter/supprimer Marques de &amp;Section"),
            ("Find...", "C&amp;hercher..."),
                ("Find Panel", "Dialogue de Re&amp;cherche"),
                ("Find Next", "Chercher &amp;Suivant"),
                ("Find Previous", "Chercher &amp;Précédent"),
                ("Replace", "&amp;Remplacer"),
                ("Replace, Then Find", "Remplacer Chercher à &amp;Nouveau"),
            ("Go To Line Number", "&amp;Atteindre Ligne No..."),
            ("Execute Script", "E&amp;xécuter un Script Python"),
            ("Set Font...", "&amp;Définir les Polices..."),
            ("Set Colors...", "Dé&amp;finir les Couleurs..."),
            ("Show Invisibles", "Afficher Caractères &amp;invisibles"),
            ("Hide Invisibles", "Masquer Caractères &amp;invisibles"),
            ("Preferences", "Préfére&amp;nces"),
        ("Outline", "Arb&amp;orescence"),
            ("Cut Node", "Co&amp;uper le Noeud"),
            ("Copy Node", "C&amp;opier le Noeud"),
            ("Paste Node", "Co&amp;ller le Noeud"),
            ("Delete Node", "&amp;Supprimer le Noeud"),
            ("Insert Node", "Insé&amp;rer un Noeud"),
            ("Clone Node", "Clo&amp;ner le Noeud"),
            ("Sort Children", "&amp;Trier les Noeuds Enfants"),
            ("Sort Siblings", "Trier le Ni&amp;veau"),
            ("Expand/Contract...", "&amp;Déployer/Refermer"),
                ("Contract All", "&amp;Tout Refermer"),
                ("Contract Node", "&amp;Refermer Noeud"),
                ("Contract Parent", "Refermer Noeud &amp;Parent"),
                ("Expand Prev Level", "Déployer Niveau pré&amp;cédent"),
                ("Expand Next Level", "Déployer Niveau &amp;suivant"),
                ("Expand To Level 1", "Déployer &amp;1 Niveau"),
                ("Expand To Level 2", "Déployer &amp;2 Niveaux"),
                ("Expand To Level 3", "Déployer &amp;3 Niveaux"),
                ("Expand To Level 4", "Déployer &amp;4 Niveaux"),
                ("Expand To Level 5", "Déployer &amp;5 Niveaux"),
                ("Expand To Level 6", "Déployer &amp;6 Niveaux"),
                ("Expand To Level 7", "Déployer &amp;7 Niveaux"),
                ("Expand To Level 8", "Déployer &amp;8 Niveaux"),
                ("Expand All", "Tout &amp;Déployer"),
                ("Expand Node", "Déplo&amp;yer Noeud"),
            ("Move...", "Dé&amp;placer..."),
                ("Move Down", "Vers le &amp;Bas"),
                ("Move Left", "Vers la &amp;Gauche"),
                ("Move Right", "Vers la &amp;Droite"),
                ("Move Up", "Vers le &amp;Haut"),
                ("Promote", "&amp;Enfants vers la Gauche"),
                ("Demote", "&amp;Noeuds suivants vers la Droite"),
            ("Mark/Unmark...", "Mar&amp;quage..."),
                ("Mark", "&amp;Marquer/Effacer Marque"),
                ("Mark Subheads", "Marquer En&amp;fants"),
                ("Mark Changed Items", "Marquer &amp;Noeuds modifiés"),
                ("Mark Changed Roots", "Marquer @&amp;root modifiés"),
                ("Mark Clones", "Marquer &amp;Clones"),
                ("Unmark All", "&amp;Effacer toutes les Marques"),
            ("Go To...", "Se Dépla&amp;cer vers..."),
                ("Go To Next Marked", "&amp;Marque suivante"),
                ("Go To Next Changed", "M&amp;odification suivante"),
                ("Go To Next Clone", "&amp;Clone suivant"),
                ("Go To First Node", "&amp;Premier Noeud"),
                ("Go To Last Node", "&amp;Dernier Noeud"),
                ("Go To Parent", "&amp;Noeud Parent"),
                ("Go To Prev Sibling", "Noe&amp;ud précédent"),
                ("Go To Next Sibling", "Noeud &amp;suivant"),
                ("Go To Prev Visible", "Noeud &amp;Visible précédent"),
                ("Go To Next Visible", "Noeud V&amp;isible suivant"),
                ("Go Back", "De&amp;rnière Position"),
                ("Go Next", "Posi&amp;tion suivante"),
        ("Window", "Fenê&amp;tre"),
            ("Equal Sized Panes", "Panneaux de &amp;même taille"),
            ("Toggle Active Pane", "&amp;Bascule Panneau actif"),
            ("Toggle Split Direction", "Bascule &amp;Horiz/Vert"),
            ("Cascade", "Fenêtres Leo en &amp;Cascade"),
            ("Minimize All", "&amp;Réduit toutes les Fenêtres"),
            ("Open Compare Window", "Ouvrir Fenêtre de Com&amp;paraison..."),
            ("Open Python Window", "Ouvrir Fenêtre Python (IDLE)..."),
        ("Help", "&amp;Aide"),
            ("About Leo...", "Au &amp;sujet de Leo..."),
            ("Online Home Page", "&amp;Page d'Accueil en ligne"),
            ("Open Online Tutorial", "Ouvrir &amp;Tutoriel en ligne"),
            ("Open LeoDocs.leo", "Ouvrir Leo&amp;Docs.leo"),
            ("Open LeoConfig.leo", "Ouvrir Leo&amp;Config.leo"),
            ("Apply Settings", "Appliquer les &amp;Réglages"))
    # Call the convenience routine to do the work.
    app().setRealMenuNamesFromTable(table)
</t>
<t tx="rodrigob.121403173614.715"></t>
<t tx="rodrigob.121403173614.716">"""Rebind up/down arrow keys"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("open2", onOpen)
    
    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.717"># Warning: the bindings created this way conflict with shift-arrow keys.

def onOpen (tag,keywords):

    c = keywords.get("new_c")
    body = c.frame.body
    tree = c.frame.tree

    # Add "hard" bindings to have up/down arrows move by visual lines.
    old_binding = body.bind("&lt;Up&gt;")
    if len(old_binding) == 0:
        body.bind("&lt;Up&gt;",tree.OnUpKey)

    old_binding = body.bind("&lt;Down&gt;")
    if len(old_binding) == 0:
        body.bind("&lt;Down&gt;",tree.OnDownKey)
</t>
<t tx="rodrigob.121403173614.718"></t>
<t tx="rodrigob.121403173614.719"></t>
<t tx="rodrigob.121403173614.720">"""Create a Plugins menu"""

# Written by Paul A. Paterson.  Revised by Edward K. Ream.

## To do: confine the imports to the plugins directory.
## This does _not_ happen now!  import test gets a module from the Python directory!

## To do: add Revert button to each dialog.

from leoPlugins import *
from leoGlobals import *
import ConfigParser,glob,os,sys,Tkinter

Tk = Tkinter

@others

if 1: # Register the handlers...
    registerHandler("create-optional-menus",createPluginsMenu)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.721">class PlugIn:

    """A class to hold information about one plugin"""

    @others
    
</t>
<t tx="rodrigob.121403173614.722">def __init__(self, filename):

    """Initialize the plug-in"""

    # Import the file to find out some interesting stuff
    # Do not use the imp module: we only want to import these files once!
    self.mod = self.doc = self.version = None
    try:
        self.mod = __import__(os.path.splitext(os.path.basename(filename))[0])
        if not self.mod:
            return
        self.name = self.mod.__name__
        self.doc = self.mod.__doc__
        self.version = self.mod.__dict__.get("__version__") # "&lt;unknown&gt;")
        # if self.version: print self.version,shortFileName(filename)
    except: return

    &lt;&lt; Check if this can be configured &gt;&gt;
    &lt;&lt; Check if this has an apply &gt;&gt;
    &lt;&lt; Look for additional commands &gt;&gt;</t>
<t tx="rodrigob.121403173614.723"># Look for a configuration file
self.configfilename = "%s.ini" % os.path.splitext(filename)[0]
self.hasconfig = os.path.isfile(self.configfilename)
</t>
<t tx="rodrigob.121403173614.724">@ Look for an apply function ("applyConfiguration") in the module.

This is used to apply changes in configuration from the properties window
@c

self.hasapply = hasattr(self.mod, "applyConfiguration")
</t>
<t tx="rodrigob.121403173614.725">@ Additional commands can be added to the plugin menu by having functions in the module called "cmd_whatever". These are added to the main menu and will be called when clicked
@c

self.othercmds = {}

for item in self.mod.__dict__.keys():
    if item.startswith("cmd_"):
        self.othercmds[item[4:]] = self.mod.__dict__[item]
</t>
<t tx="rodrigob.121403173614.726">def about(self, arg):
    
    """Put up an "about" dialog for this plugin"""

    PluginAbout(self.name, self.version, self.doc)</t>
<t tx="rodrigob.121403173614.727">def properties(self, arg):
    
    """Create a modal properties dialog for this plugin"""

    PropertiesWindow(self.configfilename, self)
</t>
<t tx="rodrigob.121403173614.728">class PropertiesWindow:

    """A class to create and run a Properties dialog for a plugin"""

    @others</t>
<t tx="rodrigob.121403173614.729">def __init__(self, filename, plugin):

    """Initialize the property window"""
    
    &lt;&lt; initialize all ivars &gt;&gt;
    &lt;&lt; create the frame from the configuration data &gt;&gt;</t>
<t tx="rodrigob.121403173614.730"># config stuff.
config = ConfigParser.ConfigParser()
config.read(filename)
self.filename = filename
self.config = config
self.plugin = plugin

# self.entries is a list of tuples (section, option, e),
# where section and options are strings and e is a Tk.Entry widget.
# This list is used by writeConfiguration to write all settings.
self.entries = []
</t>
<t tx="rodrigob.121403173614.731">root = app().root

&lt;&lt; Create the top level and the main frame &gt;&gt;
&lt;&lt; Create widgets for each section and option &gt;&gt;
&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;

center_dialog(top) # Do this after packing.
top.grab_set() # Make the dialog a modal dialog.
top.focus_force() # Get all keystrokes.
root.wait_window(top)</t>
<t tx="rodrigob.121403173614.732">self.top = top = Tk.Toplevel(root)
attachLeoIcon(self.top)
top.title("Properties of "+ plugin.name)
top.resizable(0,0) # neither height or width is resizable.
    
self.frame = frame = Tk.Frame(top)
frame.pack(side="top")</t>
<t tx="rodrigob.121403173614.733"># Create all the entry boxes on the screen to allow the user to edit the properties
sections = config.sections()
sections.sort()
for section in sections:
    # Create a frame for the section.
    f = Tk.Frame(top, relief="groove",bd=2)
    f.pack(side="top",padx=5,pady=5)
    Tk.Label(f, text=section.capitalize()).pack(side="top")
    # Create an inner frame for the options.
    b = Tk.Frame(f)
    b.pack(side="top",padx=2,pady=2)
    # Create a Tk.Label and Tk.Entry for each option.
    options = config.options(section)
    options.sort()
    row = 0
    for option in options:
        e = Tk.Entry(b)
        e.insert(0, config.get(section, option))
        Tk.Label(b, text=option).grid(row=row, col=0, sticky="e", pady=4)
        e.grid(row=row, col=1, sticky="ew", pady = 4)
        row += 1
        self.entries.append((section, option, e))</t>
<t tx="rodrigob.121403173614.734">box = Tk.Frame(top, borderwidth=5)
box.pack(side="bottom")

list = [("OK",self.onOk),("Cancel",top.destroy)]
if plugin.hasapply:
    list.append(("Apply",self.onApply),)

for text,f in list:
    Tk.Button(box,text=text,width=6,command=f).pack(side="left",padx=5)</t>
<t tx="rodrigob.121403173614.735">def onApply(self):
    
    """Event handler for Apply button"""
    self.writeConfiguration()
    self.plugin.mod.applyConfiguration(self.config)

def onOk(self):

    """Event handler for Ok button"""
    self.writeConfiguration()
    self.top.destroy()</t>
<t tx="rodrigob.121403173614.736">def writeConfiguration(self):
    
    """Write the configuration to disk"""

    # Set values back into the config item.
    for section, option, entry in self.entries:
        self.config.set(section, option, entry.get())

    # Write out to the file.
    f = open(self.filename, "w")
    self.config.write(f)
    f.close()
</t>
<t tx="rodrigob.121403173614.737">class PluginAbout:
    
    """A class to create and run an About Plugin dialog"""
    
    @others
</t>
<t tx="rodrigob.121403173614.738">def __init__(self, name, version, about):
    
    """# Create and run a modal dialog giving the name,
    version and description of a plugin.
    """

    root = app().root
    self.top = top = Tk.Toplevel(root)
    attachLeoIcon(self.top)
    top.title("About " + name)
    top.resizable(0,0) # neither height or width is resizable.
    
    frame = Tk.Frame(top)
    frame.pack(side="top")
    &lt;&lt; Create the contents of the about box &gt;&gt;
    &lt;&lt; Create the close button &gt;&gt;
    
    center_dialog(top) # Do this after packing.
    top.grab_set() # Make the dialog a modal dialog.
    top.focus_force() # Get all keystrokes.
    root.wait_window(top)</t>
<t tx="rodrigob.121403173614.739">if 0: # The name is now in the window's title.
    Tk.Label(frame, text="Name:").grid(row=0, col=0, sticky="E")
    Tk.Label(frame, text=name).grid(row=0, col=1, sticky="W")
    Tk.Label(frame, text="Version").grid(row=1, col=0, sticky="E")
    Tk.Label(frame, text=version).grid(row=1, col=1, sticky="W")
    Tk.Label(frame, text=about, borderwidth=10, justify="left").grid(columnspan=2)
else:
    Tk.Label(frame, text="Version " + version).pack()
    Tk.Label(frame, text=about, borderwidth=10).pack()</t>
<t tx="rodrigob.121403173614.740">buttonbox = Tk.Frame(top, borderwidth=5)
buttonbox.pack(side="bottom")

self.button = Tk.Button(buttonbox, text="Close", command=top.destroy)
self.button.pack(side="bottom")</t>
<t tx="rodrigob.121403173614.741">def createPluginsMenu (tag,keywords):

    c = keywords.get("c")
    old_path = sys.path[:] # Make a _copy_ of the path.

    path = os.path.join(app().loadDir,"..","plugins")
    sys.path = path
    
    if os.path.exists(path):
        # Create a list of all active plugins.
        files = glob.glob(os.path.join(path,"*.py"))
        files.sort()
        plugins = [PlugIn(file) for file in files]
        items = [(p.name,p) for p in plugins if p.version]
        if items:
            items.sort()
            c.pluginsMenu = pluginMenu = c.frame.createNewMenu("&amp;Plugins")
            &lt;&lt; add items to the plugins menu &gt;&gt;
            
    sys.path = old_path


</t>
<t tx="rodrigob.121403173614.742">for name,p in items:
    if p.hasconfig:
        m = c.frame.createNewMenu(p.name, "&amp;Plugins")
        table = [("About...", None, p.about),
                 ("Properties...", None, p.properties)]
        if p.othercmds:
            table.append(("-", None, None))
            items = [(cmd,None,fn) for cmd,fn in p.othercmds.iteritems()]
            items.sort()
            table.extend(items)
        c.frame.createMenuEntries(m, table)
    else:
        table = ((p.name, None, p.about),)
        c.frame.createMenuEntries(pluginMenu, table)</t>
<t tx="rodrigob.121403173614.743">@ignore
@language python

"""Test file for Plugins menu protocols"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...

    registerHandler("select2", onSelect)
    registerHandler("unselect1", onUnselect)
    
    __version__ = "1.1"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.744">def applyConfiguration(config):
    
    sections = config.sections()
    sections.sort()

    for section in sections:
        options = config.options(section)
        options.sort()
        for option in options:
            print section, option, config.get(section, option)
</t>
<t tx="rodrigob.121403173614.745">def cmd_fn1(x):
    es("Fn1",color="blue")

def cmd_fn2(x):
    es("Fn2",color="blue")

def cmd_fn3(x):
    es("Fn3",color="blue")
</t>
<t tx="rodrigob.121403173614.746">def onSelect (tag,keywords):

    import Tkinter,os

    new_v = keywords.get("new_v")
    h = new_v.headString()
    if h[:7] == "@image ":
        filename = h[7:]
        &lt;&lt; Select Image &gt;&gt;</t>
<t tx="rodrigob.121403173614.747"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
    try:
        # Note that Tkinter only understands GIF
        photo = Tkinter.PhotoImage(master=a.root, file=filename)
    except:
        es("error: cannot load image")
        return
    # Nicely display the image at the center top and push the text below.
    a.gsphoto = photo # This is soooo important.
    photoWidth = photo.width()
    bodyWidth = body.winfo_width()
    padding = int((bodyWidth - photoWidth - 16) / 2)
    padding = max(0,padding)
    a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
    es("warning: missing image file")</t>
<t tx="rodrigob.121403173614.748">def onUnselect (tag,keywords):

    import Tkinter, os.path
    a = app()
    c = keywords.get("c")
    old_v = keywords.get("old_v")

    if old_v:
        h = old_v.headString()
        if h[:7] == "@image ":
            &lt;&lt; Unselect Image &gt;&gt;
    else: # Leo is initializing.
        a.gsphoto = None # Holds our photo file
        a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="rodrigob.121403173614.749"># Erase image if it was previously displayed
if a.gsimage:
    try:
         c.frame.body.delete(a.gsimage)
    except:
        es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="rodrigob.121403173614.750">@nocolor</t>
<t tx="rodrigob.121403173614.751">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
    Added top ivar and removed root/master params and ivars.
    Added Leo icon and title.
    Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="rodrigob.121403173614.752">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
    val = present value of settings: Use parent setting if this does not exist.
    help = help string (displayed near setting if it exists)
    prompt = prompt string (defaults to setting name, i.e., the section name)
    group = name of group dialog containing this item (use general section if this does not exist)
    type = one of the following:
        value			meaning
        bool			followed by true/false prompts for radio buttons
        color			color picker
        font			font picker
        parent			name of parent config file (set/get setting in that file)
        entry			followed by arbitrary text in an entry widget
        text			followed by arbitrary text in a text widget
        number			any number, or followed by a range of valid values for an entry widget.
        numberlist  followed by a list valid values for a listbox.
        list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="rodrigob.121403173614.753">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does....
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x...." entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="rodrigob.121403173614.754">"""Create a Scripts menu for LeoPy.leo"""

from leoPlugins import *
from leoGlobals import *
import glob,os

@others

if 1: # Register the handlers...
    registerHandler("create-optional-menus",createScriptsMenu)
    
    __version__ = "1.4"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.755">def createScriptsMenu (tag,keywords):

    c = keywords.get("c")
    path = os.path.join(app().loadDir,"..","scripts")
    
    if os.path.exists(path):

        # Create lists of scripts and subdirectories.
        entries = glob.glob(os.path.join(path,"*"))
        top_scripts = glob.glob(os.path.join(path,"*.py"))
        dirs = [f for f in entries if os.path.isdir(f)]
        &lt;&lt; Return if no scripts exist anywhere &gt;&gt;
    
        scriptsMenu = c.frame.createNewMenu("&amp;Scripts")
        table = []
        &lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;
        for dir in dirs:
            files = glob.glob(os.path.join(dir,"*.py"))
            if files:
                &lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</t>
<t tx="rodrigob.121403173614.756">if not top_scripts:
    found = false
    for dir in dirs:
        scripts = glob.glob(os.path.join(dir,"*.py"))
        if scripts:
            found = true ; break
    if not found:
        return
</t>
<t tx="rodrigob.121403173614.757">table = []
top_scripts.sort()
for script in top_scripts:
    name = shortFileName(script)
    def doScript(event=None,name=name):
        executeScript(name)
    table.append((name,None,doScript),)
    
c.frame.createMenuEntries(scriptsMenu, table)
</t>
<t tx="rodrigob.121403173614.758"># Create the submenu.
name = os.path.join("scripts",shortFileName(dir))
menu = c.frame.createNewMenu(name,"&amp;Scripts")

# Populate the submenu.
table = []
for file in files:
    name = shortFileName(file)
    def doScript(event=None,name=name):
        from leoGlobals import executeScript
        executeScript(name)
    table.append((name,None,doScript),)

c.frame.createMenuEntries(menu, table)</t>
<t tx="rodrigob.121403173614.759"></t>
<t tx="rodrigob.121403173614.760">"""Synchronize @folder nodes with folders"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
@others

def onSelect (tag,keywords):
    v = keywords.get("new_v")
    h = v.headString()
    if match_word(h,0,"@folder"):
        sync_node_to_folder(v,h[8:])

if 0: # Register the handlers...
    registerHandler("select1", onSelect)

    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.761">@ If a node is named '@folder path_to_folder', the content (filenames) of the
folder and the children of that node will be sync. Whenever a new file is put
there, a new node will appear on top of the children list (with mark). So that
I can put my description (ie. annotation) as the content of that node. In this
way, I can find any files much easier from leo.

Moreover, I add another feature to allow you to group files(in leo) into
children of another group. This will help when there are many files in that
folder. You can logically group it in leo (or even clone it to many groups),
while keep every files in a flat/single directory on your computer.
</t>
<t tx="rodrigob.121403173614.762">def sync_node_to_folder(parent,d):

    oldlist = {}
    newlist = []
    #get children info
    v = parent
    after_v = parent.nodeAfterTree()
    while v != after_v:
        if not v.hasChildren():
            oldlist[v.headString()] = v.bodyString()
        v = v.threadNext()
    #compare folder content to children
    for name in os.listdir(d):
        if name in oldlist:
            del oldlist[name]
        else:
            newlist.append(name)
    #insert newlist
    newlist.sort()
    newlist.reverse()
    for name in newlist:
        v = parent.insertAsNthChild(0)
        v.setHeadStringOrHeadline(name)
        v.setMarked()
    #warn for orphan oldlist
    if len(oldlist)&gt;0:
        es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="rodrigob.121403173614.763">"""Inhibit changes to @read-only nodes"""

# Contributed by Davide Salomoni &lt;dsalomoni@yahoo.com&gt;

from leoPlugins import *
from leoGlobals import *
import ftplib, urllib, urlparse, os, cStringIO, tkFileDialog
from formatter import AbstractFormatter, DumbWriter
from htmllib import HTMLParser

@others

if 0: # Register the handlers...
    registerHandler(("start2","open2"), on_open2)
    registerHandler("bodykey1", on_bodykey1)
    registerHandler("headkey2", on_headkey2)
    if 0: # doesn't work: the cursor stops blinking.
        registerHandler("select1", on_select1)
        registerHandler("select2", on_select2)

    __version__ = "1.5" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.764">@ Dear Leo users,

Here's my first attempt at customizing leo. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only
be read by leo (not tangled), and also kept in sync with the content on the
drive.

The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't
want leo to tangle or in any way modify them. At the same time, I want them
to be up-to-date in the leo outline.

So I coded the directive plugin. It has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
on disk has changed from what is stored in the outline, it marks the node as
changed and prints a "changed" message to the log window; if, on the other hand,
the file content has _not_ changed, the file is simply read and the node is
not marked as changed.

- When you write a @read-only directive, the file content is added to the node
immediately, i.e. as soon as you press Enter (no need to call a menu
entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
and press Enter. The file is reloaded, and if in the meantime it has changed,
a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

Davide Salomoni
</t>
<t tx="rodrigob.121403173614.765">@ The syntax to access files in @read-only via ftp/http is the following:

@read-only http://www.ietf.org/rfc/rfc0791.txt
@read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows:

@read-only ftp://username:password@ftp.someserver.org/filepath

For more details, see the doc string for the class FTPurl.
</t>
<t tx="rodrigob.121403173614.766">class FTPurl:
    """An FTP wrapper class to store/retrieve files using an FTP URL.

    To create a connection, call the class with the constructor:

        FTPurl(url[, mode])

    The url should have the following syntax:
    
        ftp://[username:password@]remotehost/filename
    
    If username and password are left out, the connection is made using
    username=anonymous and password=realuser@host (for more information,
    see the documentation of module ftplib).
    
    The mode can be '' (default, for ASCII mode) or 'b' (for binary mode).
    This class raises an IOError exception if something goes wrong.
    """
    
    @others
</t>
<t tx="rodrigob.121403173614.767">def __init__(self, ftpURL, mode=''):
    parse = urlparse.urlparse(ftpURL)
    if parse[0] != 'ftp':
        raise IOError, "error reading %s: malformed ftp URL" % ftpURL

    # ftp URL; syntax: ftp://[username:password@]hostname/filename
    self.mode = mode
    authIndex = parse[1].find('@')
    if authIndex == -1:
        auth = None
        ftphost = parse[1]
    else:
        auth = parse[1][:authIndex]
        ftphost = parse[1][authIndex+1:]
    self.ftp = ftplib.FTP(ftphost)
    if auth == None:
        self.ftp.login()
    else:
        # the URL has username/password
        pwdIndex = auth.find(':')
        if pwdIndex == -1:
            raise IOError, "error reading %s: malformed ftp URL" % ftpURL
        user = auth[:pwdIndex]
        password = auth[pwdIndex+1:]
        self.ftp.login(user, password)
    self.path = parse[2][1:]
    self.filename = os.path.basename(self.path)
    self.dirname = os.path.dirname(self.path)
    self.isConnectionOpen = 1
    self.currentLine = 0
</t>
<t tx="rodrigob.121403173614.768"></t>
<t tx="rodrigob.121403173614.769">def read(self):
    """Read the filename specified in the constructor and return it as a string.
    If the constructor specifies no filename, or if the URL ends with '/',
    return the list of files in the URL directory.
    """
    self.checkParams()
    if self.filename=='' or self.path[-1]=='/':
        return self.dir()

    try:
        if self.mode == '':  # mode='': ASCII mode
            slist = []
            self.ftp.retrlines('RETR %s' % self.path, slist.append)
            s = '\n'.join(slist)
        else: # mode='b': binary mode
            file = cStringIO.StringIO()
            self.ftp.retrbinary('RETR %s' % self.path, file.write)
            s = file.getvalue()
            file.close()
        return s
    except:
        exception, msg, tb = sys.exc_info()
        raise IOError, msg

</t>
<t tx="rodrigob.121403173614.770">def readline(self):
    """Read one entire line from the remote file."""
    try:
        self.lst
    except AttributeError:
        self.lst = self.read().splitlines(1)
    
    if self.currentLine &lt; len(self.lst):
        s = self.lst[self.currentLine]
        self.currentLine = self.currentLine + 1
        return s
    else:
        return ''
</t>
<t tx="rodrigob.121403173614.771"></t>
<t tx="rodrigob.121403173614.772">def write(self, s):
    """write(s) stores the string s to the filename specified in the
    constructor."""
    self.checkParams()
    if self.filename == '':
        raise IOError, 'filename not specified'
    
    try:
        file = cStringIO.StringIO(s)
        if self.mode == '':  # mode='': ASCII mode
            self.ftp.storlines('STOR %s' % self.path, file)
        else: # mode='b': binary mode
            self.ftp.storbinary('STOR %s' % self.path, file)
        file.close()
    except:
        exception, msg, tb = sys.exc_info()
        raise IOError, msg
</t>
<t tx="rodrigob.121403173614.773"></t>
<t tx="rodrigob.121403173614.774">def seek(offset=0):
    self.currentLine = 0  # we don't support fancy seeking via FTP
</t>
<t tx="rodrigob.121403173614.775">def flush():
    pass # no fancy stuff here.</t>
<t tx="rodrigob.121403173614.776">def dir(self, path=None):
    """Issue a LIST command passing the specified argument and return output as a string."""
    s = []

    if path == None:
        path = self.dirname
    try:
        listcmd = 'LIST %s' % path
        self.ftp.retrlines(listcmd.rstrip(), s.append)
        return '\n'.join(s)
    except:
        exception, msg, tb = sys.exc_info()
        raise IOError, msg
</t>
<t tx="rodrigob.121403173614.777">def exists(self, path=None):
    """Return 1 if the specified path exists. If path is omitted, the current file name is tried."""
    if path == None:
        path = self.filename

    s = self.dir(path)
    if s.lower().find('no such file') == -1:
        return 1
    else:
        return 0
</t>
<t tx="rodrigob.121403173614.778">def checkParams(self):
    if self.mode not in ('','b'):
        raise IOError, 'invalid mode: %s' % self.mode
    if not self.isConnectionOpen:
        raise IOError, 'ftp connection closed'
</t>
<t tx="rodrigob.121403173614.779">def close(self):
    """Close an existing FTPurl connection."""
    try:
        self.ftp.quit()
    except:
        self.ftp.close()
    del self.ftp
    self.isConnectionOpen = 0</t>
<t tx="rodrigob.121403173614.780"># Alas, these do not seem to work on XP:
# disabling the body text _permanently_ stops the cursor from blinking.

def enable_body(body):
    global insertOnTime,insertOffTime
    if body.cget("state") == "disabled":
        try:
            es("enable")
            print insertOffTime,insertOnTime
            body.configure(state="normal")
            body.configure(insertontime=insertOnTime,insertofftime=insertOffTime)
        except: es_exception()
            
def disable_body(body):
    global insertOnTime,insertOffTime
    if body.cget("state") == "normal":
        try:
            es("disable")
            insertOnTime = body.cget("insertontime")
            insertOffTime = body.cget("insertofftime")
            print insertOffTime,insertOnTime
            body.configure(state="disabled")
        except: es_exception()
</t>
<t tx="rodrigob.121403173614.781"># Sets v's body text from the file with the given name.
# Returns true if the body text changed.
def insert_read_only_node (c,v,name):
    if name=="":
        name = tkFileDialog.askopenfilename(
            title="Open",
            filetypes=[("All files", "*")]
            )
        c.beginUpdate()
        v.setHeadString("@read-only %s" % name)
        c.endUpdate()
    parse = urlparse.urlparse(name)
    try:
        if parse[0] == 'ftp':
            file = FTPurl(name)  # FTP URL
        elif parse[0] == 'http':
            file = urllib.urlopen(name)  # HTTP URL
        else:
            file = open(name,"r")  # local file
        # es("..." + name)
        new = file.read()
        file.close()
    except IOError,msg:
        # es("error reading %s: %s" % (name, msg))
        # es("...not found: " + name)
        v.setBodyStringOrPane("") # Clear the body text.
        return true # Mark the node as changed.
    else:
        ext = os.path.splitext(parse[2])[1]
        if ext.lower() in ['.htm', '.html']:
            &lt;&lt; convert HTML to text &gt;&gt;
        previous = v.t.bodyString
        v.setBodyStringOrPane(new)
        changed = (toUnicode(new,'ascii') != toUnicode(previous,'ascii'))
        if changed and previous != "":
            es("changed: %s" % name) # A real change.
        return changed


</t>
<t tx="rodrigob.121403173614.782">fh = cStringIO.StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
    hyperlist = ['\n\n--Hyperlink list follows--']
    for i in xrange(numlinks):
        hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
    new = new + ''.join(hyperlist)</t>
<t tx="rodrigob.121403173614.783">#  scan the outline and process @read-only nodes.
def on_open2 (tag,keywords):
    
    
    if tag == "start2":
        c = top()
    else:
        c = keywords.get("new_c")

    v = c.rootVnode()
    es("scanning for @read-only nodes...",color="blue")
    c.beginUpdate()
    while v:
        h = v.headString()
        if match_word(h,0,"@read-only"):
            changed = insert_read_only_node(c,v,h[11:])
            if changed:
                if not v.isDirty():
                    v.setDirty()
                if not c.isChanged():
                    c.setChanged(changed)
        v = v.threadNext()
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.784"># override the body key handler if we are in an @read-only node.

def on_bodykey1 (tag,keywords):

    c = keywords.get("c")
    v = keywords.get("v")
    h = v.headString()
    if match_word(h,0,"@read-only"):
        # The following code causes problems with scrolling and syntax coloring.
        # Its advantage is that it makes clear that the text can't be changed,
        # but perhaps that is obvious anyway...
        if 0: # Davide Salomoni requests that this code be eliminated.
            # An @read-only node: do not change its text.
            body = c.frame.body
            body.delete("1.0","end")
            body.insert("1.0",v.bodyString())
        return 1 # Override the body key event handler.</t>
<t tx="rodrigob.121403173614.785"># update the body text when we press enter

def on_headkey2 (tag,keywords):

    c = keywords.get("c")
    v = keywords.get("v")
    h = v.headString()
    ch = keywords.get("ch")
    if ch == '\r' and match_word(h,0,"@read-only"):
        # on-the-fly update of @read-only directives
        changed = insert_read_only_node(c,v,h[11:])
        c.setChanged(changed)</t>
<t tx="rodrigob.121403173614.786">def on_select1 (tag,keywords):

    # Doesn't work: the cursor doesn't start blinking.
    # Enable the body text so select will work properly.
    c = keywords.get("c")
    enable_body(c.frame.body)
</t>
<t tx="rodrigob.121403173614.787">def on_select2 (tag,keywords):

    c = keywords.get("c")
    v = c.currentVnode()
    h = v.headString()
    if match_word(h,0,"@read-only"):
        disable_body(c.frame.body)
    else:
        enable_body(c.frame.body)
</t>
<t tx="rodrigob.121403173614.788">"""If a headline starts with @rst &lt;filename&gt;, double-clicking on it will 
write a file in outline order, with the headlines converted to reStructuredText 
section headings.
If the name of the &lt;filename&gt; has the extension .html or .htm, and if you have
docutils installed, it will generate HTML."""

# By Josef Dalcolmo: contributed under the same licensed as Leo.py itself.

# EKR: The code now lets other plugins handle @folder and @url nodes.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
    registerHandler("icondclick1",onIconDoubleClick)
    
    __version__ = "1.5" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.789">@ This plugin writes out @rst nodes as a reStructuredText file.

If the filename ends in .html or .htm and if you have docutils_ (a Python
module) installed, then it will be written as HTML. The HTML converter is far
from bug-free, but remember, docutils is alpha software. (Perhaps a future
version will allow automatic translation to other formats, like OpenOffice.org
as well).

Headlines are translated into reStructuredText headlines, e.g. underlined
depending on the level and empty line separated from body text otherwise, text
is written as it is. The "#" character is not used for underlining, so it may
be used for a title as in::

    #####
    Title
    #####

Otherwise, section underlining is discouraged, since it is automatically generated.

.. _docutils: http://docutils.sourceforge.net
</t>
<t tx="rodrigob.121403173614.790">@ Change log:

- New tree types: @rst has been added.

- EKR: The code now lets other plugins handle @folder and @url nodes.

- HTML generation: @rst nodes can now generate HTML, if Python docutils_ are
  installed. Simply give the filename an extension .htm or .html. You can try
  this out by renaming the filename in this @rst tree.

- underlines: I changed the order of the underline characters again. The "&gt;" is
  doesn't really look good as an underline in my opinion, so I moved it to a very
  low level.

- JD 2003-03-10 (rev 1.3): some more corrections to the unicode-&gt; encoding translation.
  No only check for missing docutils (doesn't mask other errors any more).

- JD 2003-03-11 (rev 1.4): separated out the file launching code to a different pluging.



</t>
<t tx="rodrigob.121403173614.791"># by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

    import os
    v = keywords.get("v")
    commands = keywords.get("c")
    h = v.headString().strip()
    if match_word(h,0,"@rst"):
        fname = h[5:]
        ext = os.path.splitext(fname)[1].lower()
        if ext in ('.htm','.html'):
            &lt;&lt; write rST as HTML &gt;&gt;
        else:
            &lt;&lt; write rST file &gt;&gt;
</t>
<t tx="rodrigob.121403173614.792">try:
    import docutils
except:
    docutils = None
    es('HTML generation requires docutils')
if docutils:
    import StringIO
    rstFile = StringIO.StringIO()
    writeTreeAsRst(rstFile, fname, v, commands)
    rstText = rstFile.getvalue()
    &lt;&lt; convert rST to HTML &gt;&gt;
    htmlFile = file(fname,'w')
    htmlFile.write(output)
    htmlFile.close()
    rstFile.close()
    es('written: '+`fname`)</t>
<t tx="rodrigob.121403173614.793"># this code snipped has been taken from code contributed by Paul Paterson 2002-12-05
from docutils.core import Publisher
from docutils.io import StringOutput, StringInput

pub = Publisher()
# Initialize the publisher
pub.source = StringInput(pub.settings, source=rstText)
pub.destination = StringOutput(pub.settings, encoding="utf-8")
pub.set_reader('standalone', None, 'restructuredtext')
pub.set_writer('html')
output = pub.publish()</t>
<t tx="rodrigob.121403173614.794">rstFile = file(fname,'w')
writeTreeAsRst(rstFile, fname, v, commands)
rstFile.close()
es('written: '+`fname`)</t>
<t tx="rodrigob.121403173614.795">def writeTreeAsRst(rstFile, fname, vnode, commands):
    'Writes the tree under vnode to the file rstFile (fname is the filename)'
    # we don't write a title, so the titlepage can be customized
    # use '#' for title under/overline
    # 3/7/03
    dict = scanDirectives(commands,v=vnode)
    encoding = dict.get("encoding",None)
    if encoding == None:
        encoding = app().config.default_derived_file_encoding
    # 3/7/03
    s = toEncodedString(fname,encoding,reportErrors=true)
    rstFile.write('.. filename: '+s+'\n')
    rstFile.write('\n')
    # 3/7/03
    s = vnode.bodyString()
    s = toEncodedString(s,encoding,reportErrors=true)
    rstFile.write(s+'\n')		# write body of titlepage
    rstFile.write('\n')
    
    toplevel = vnode.level()
    stopHere = vnode.nodeAfterTree()
    v = vnode.threadNext()
    # repeat for all nodes in this tree
    while v != stopHere:
        # 3/7/03
        h = v.headString()
        h = toEncodedString(h,encoding,reportErrors=true)
        rstFile.write(h+'\n')
        rstFile.write(underline(h,v.level()-toplevel))
        rstFile.write('\n')
        # 3/7/03
        s = v.bodyString()
        s = toEncodedString(s,encoding,reportErrors=true)
        rstFile.write(s+'\n')
        rstFile.write('\n')
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.796"># note the first character is intentionally unused, to serve as the underline
# character in a title (in the body of the @rst node)
def underline(h,level):
    str = """#=+*^~"'`-:&gt;&lt;_"""[level]
    return str*max(len(h),4)+'\n'</t>
<t tx="rodrigob.121403173614.797">"""Lauches (starts) a file with the name of the headline on double-clicking it.
Uses the @folder path if the headline is under an @folder headline.
Otherwise the path is relative to the Leo file.
Headlines starting with an '@' are ignored.
This does not work on Linux (yet)."""

# By Josef Dalcolmo: contributed under the same license as Leo.py itself.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
    registerHandler("icondclick1",onIconDoubleClick)
    
    __version__ = "1.1" # Set version for the plugin handler.
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.798">@ This plugin starts a file with the name of a headline.


</t>
<t tx="rodrigob.121403173614.799">@ Change log

- JD: 2003-03-11 separated out from rst plugin



</t>
<t tx="rodrigob.121403173614.800"># @folder behavior after an idea and sample code by:
# korakot ( Korakot Chaovavanich ) @folder for files annotation 2002-11-27 02:39
# 
# open file (double-click = startfile) behavior added 
# nodes with @url, @folder, @rst are treated special
#
# by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

    import os
    v = keywords.get("v")
    commands = keywords.get("c")
    h = v.headString().strip()
    if len(h)==0 or h[0]=='@':
        return # Let other plugins handle these
    else:
        # open file with associated application
        &lt;&lt; find path and start file &gt;&gt;</t>
<t tx="rodrigob.121403173614.801"># Set the base directory by searching for @folder directives in ancestors.
try:
    basedir = os.curdir	# use current dir as default.
    parv = v.parent()	# start with parent
    while parv:	# stop when no more parent found
        p = parv.headString().strip()
        if match_word(p,0,'@folder'):
            basedir = p[8:]	# take rest of headline as pathname
            break	# we found the closest @folder
        else:
            parv = parv.parent()	# try the parent of the parent
    fname = os.path.join(basedir,h) # join path and filename
    os.startfile(fname)	# Try to open the file; it may not work for all file types.
except:
    es(os.path.join(os.getcwd(),fname)+' - file or application not found')
    es_exception()
</t>
<t tx="rodrigob.121403173614.802"></t>
<t tx="rodrigob.121403173614.803">from leoPlugins import *
from leoGlobals import *

Tk = Tkinter

@others

if 0: # Override classes &amp; methods...

    if 0:
        &lt;&lt; override the LeoFrame class &gt;&gt;

    if 0:
        &lt;&lt; override methods of the LeoApp class &gt;&gt;

    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.804"># print "overriding LeoFrame class"

import leoFrame

assert(leoFrame.leoCoreFrame.instances==0)

class myLeoFrame(leoFrame.leoCoreFrame):
    
    pass
    
    if 0:
        def __init__(self,title=None):
            print "myLeoFrame ctor",title
            leoFrame.leoCoreFrame.__init__(self,title)

leoFrame.LeoFrame = myLeoFrame</t>
<t tx="rodrigob.121403173614.805">import leoApp

# print "overriding app.closeLeoWindow"

oldAppCloseLeoWindow = app().closeLeoWindow

def myAppCloseLeoWindow(self,frame):
    
    global oldAppCloseLeoWindow

    oldAppCloseLeoWindow(frame)
    print "after closeLeoWindow"

funcToMethod(myAppCloseLeoWindow,leoApp.LeoApp,"closeLeoWindow")</t>
<t tx="rodrigob.121403173614.806">"""Override the Equal Sized Pane command"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("command1", onCommand)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.807">def onCommand (tag,keywords):

    if keywords.get("label")=="equalsizedpanes":
        es("over-riding Equal Sized Panes")
        return "override" # Anything other than None overrides.</t>
<t tx="rodrigob.121403173614.808">"""Redefine the "put" and "put_nl" methods"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("start2", onStart)
    
    __version__ = "1.2"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.809">@ This code illustrates how to redefine _any_ method of Leo.
Python makes this is almost too easy :-)
@c

def onStart (tag,keywords):

    import leoFrame
    
    # Replace frame.put with newPut.
    funcToMethod(newPut,leoFrame.LeoFrame,"put")
    
    # Replace frame.putnl with newPutNl.
    funcToMethod(newPutNl,leoFrame.LeoFrame,"putnl")
</t>
<t tx="rodrigob.121403173614.810"># Contrived examples of how to redefine frame.put and frame.putnl

# Same as frame.put except converts everything to upper case.
def newPut (self,s,color="black"):
    # print "newPut",s,
    if app().quitting &gt; 0: return
    s = s.upper()
    if self.log:
            self.log.insert("end",s)
            self.log.see("end")
            self.log.update_idletasks()
    else: print s,

# Same as frame.putnl except writes two newlines.
def newPutNl (self):
    # print "newPutNl"
    if app().quitting &gt; 0: return
    if self.log:
        self.log.insert("end","\n\n")
        self.log.see("end")
        self.log.update_idletasks()
    else: print</t>
<t tx="rodrigob.121403173614.811">"""Send all output to the log pane"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
    from leoGlobals import redirectStdout,redirectStderr
    redirectStdout() # Redirect stdout
    redirectStderr() # Redirect stderr

if 1: # Register the handlers...
    registerHandler("start2", onStart)

    __version__ = "1.3" # Set version for the plugin handler.
    plugin_signon(__name__)

</t>
<t tx="rodrigob.121403173614.812">"""Send output from the Execute Script command to the end of the body pane"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
    registerHandler("start1", onStart)

    __version__ = "1.2" # Set version for the plugin handler.
    plugin_signon(__name__)
</t>
<t tx="rodrigob.121403173614.813">def onStart (tag,keywords):
    
    import leoFrame
    
    # Replace frame.put with newPut.
    funcToMethod(newExecuteScript,leoFrame.LeoFrame,"OnExecuteScript")
</t>
<t tx="rodrigob.121403173614.814"># Execute the _selected_ body text as a Python script and sends the output to the end of the body pane.

def newExecuteScript(self,event=None,v=None):
    
    c = self.commands ; body = self.body ; s = None
    if v == None:
        v = c.currentVnode() 

    # Assume any selected body text is a script.
    start,end = getTextSelection(body)
    if start and end and start != end: # 7/7/03
        s = body.get(start,end)
    else:
        s = ""
    s = s.strip()
    if s and len(s) &gt; 0:
        s += '\n' # Make sure we end the script properly.
        try:
            # Switch output.
            import leoFrame,leoGlobals
            oldput = leoFrame.LeoFrame.put
            oldputnl = leoFrame.LeoFrame.putnl
            oldes = leoGlobals.es
            oldenl = leoGlobals.enl
            oldecnl = leoGlobals.ecnl
            oldecnls = leoGlobals.ecnls
            leoGlobals.es = newEs
            leoGlobals.enl = newEnl
            leoGlobals.ecnl = newEcnl
            leoGlobals.ecnls = newEcnls
            funcToMethod(newPut,leoFrame.LeoFrame,"put")
            funcToMethod(newPutNl,leoFrame.LeoFrame,"putNl")
            redirectStderr()
            redirectStdout()
            exec s in {} # Use {} to get a pristine environment!
            # Restore output.
            funcToMethod(oldput,leoFrame.LeoFrame,"put")
            funcToMethod(oldputnl,leoFrame.LeoFrame,"putNl")
            leoGlobals.es = oldes
            leoGlobals.enl = oldenl
            leoGlobals.ecnl = oldecnl
            leoGlobals.ecnls = oldecnls
            restoreStderr()
            restoreStdout()
        except:
            es("exception executing script")
            es_exception(full=false)
    else:
        es("no script selected")
</t>
<t tx="rodrigob.121403173614.815"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s):
    if self.body:
            self.body.insert("end",s)
            # self.body.see("end")
            c = self.commands ; v = c.currentVnode()
            self.tree.onBodyChanged(v,"Typing")
    else: print s,

# Same as frame.putnl exceptsends output to the end of the body text.
def newPutNl (self):
    newPut (self,'\n')</t>
<t tx="rodrigob.121403173614.816">def newEnl():
    print
    
def newEcnl():
    print
    
def newEcnls(n):
    while n &gt; 0:
        n -= 1
        print

def newEs(s,*args,**keys):
    newline = keys.get("newline",true)
    if type(s) != type("") and type(s) != type(u""):
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""):
            arg = repr(arg)
        s = s + ", " + arg
    if newline:
        print s
    else:
        print s,
</t>
<t tx="rodrigob.121403173614.817"></t>
<t tx="rodrigob.121403173614.818">colour
colourful
coloured
</t>
<t tx="rodrigob.121403173614.819"># Configuration file for mod_spelling plugin.

[main]

aspell_dir=c:\aspell\bin\aspell.exe

local_leo_dictionary=c:\prog\leoCVS\leo\plugins\mod_spelling.txt

local_language_code=en</t>
<t tx="rodrigob.121403173614.820">"""Spell Checker Plugin

- Perfoms spell checking on nodes within a Leo document.
- Uses aspell.exe to do the checking and suggest alternatives."""

import leoFind,os,popen2,re,sys,Tkinter,traceback
from leoPlugins import *
from leoGlobals import *

Tk = Tkinter

@others

if 0: # Register the handlers...

    spellFrame = spellDialog()
    spellFrame.top.withdraw()
    app().globalWindows.append(spellFrame)
    
    registerHandler("create-optional-menus",createSpellMenu)
    registerHandler("select2",onSelect)
    registerHandler("command2",onCommand) # For any command that might change the text.
    registerHandler("bodykey2",onSelect) # For updating buttons.
    registerHandler(("bodyclick2","bodydclick2","bodyrclick2"),onSelect) # These affect selection.
    
    __version__ = "0.2.0"
    plugin_signon(__name__)</t>
<t tx="rodrigob.121403173614.821"></t>
<t tx="rodrigob.121403173614.822">def createSpellMenu(tag,keywords):
    
    """Create the Check Spelling menu item in the Edit menu."""
    
    c = keywords.get("c")

    table = (
        ("-",None,None),
        ("Check Spelling","Alt+Shift+A",spellFrame.checkSpelling))

    c.frame.createMenuItemsFromTable("Edit",table)</t>
<t tx="rodrigob.121403173614.823">def onSelect (tag,keywords):
    
    """A new vnode has just been selected.  Update the Spell Check window."""

    c = keywords.get("c")
    v = keywords.get("new_v")
    global spellFrame
    
    if top() and c and c.currentVnode():
        if c.currentVnode() != spellFrame.v:
            # print "onSelect",tag,`c.currentVnode()`,`spellFrame.v`
            spellFrame.update(show=false,fill=true)
        else:
            spellFrame.updateButtons()</t>
<t tx="rodrigob.121403173614.824">def onCommand (tag,keywords):
    
    """Update the Spell Check window after any command that might change text."""

    global spellFrame
    
    if top() and top().currentVnode():
        
        # print "onCommand",tag
        spellFrame.update(show=false,fill=false)</t>
<t tx="rodrigob.121403173614.825">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others
</t>
<t tx="rodrigob.121403173614.826"></t>
<t tx="rodrigob.121403173614.827">def __init__(self,local_dictionary_file,local_language_code):
    
    """Ctor for the Aspell class."""
    
    self.altre = re.compile(".\s(.+)\s(\d+)\s(\d+):(.*)")
    self.attached = None
    self.input,self.output = None,None
    self.signonGiven = false
    
    self.aspell_exe_loc = self.getAspellDirectory()
    self.local_language_code = local_language_code
    
    if local_dictionary_file:
        self.local_dictionary_file = local_dictionary_file
        self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
    else:
        print "failed to set aspell.local_dictionary"
        self.local.dictionary_file = None
        self.local_dictionary = None</t>
<t tx="rodrigob.121403173614.828">def getAspellDirectory(self):
    
    """Get the directory containing aspell.exe from mod_spelling.ini"""

    import ConfigParser

    try:
        fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
        config = ConfigParser.ConfigParser()
        config.read(fileName)
        return config.get("main","aspell_dir")
    except:
        es_exception()
        return None</t>
<t tx="rodrigob.121403173614.829">def openPipes (self):
    
    """Open the pipes to aspell.exe"""
    
    if self.input or self.output:
        print "pipes already open!"
        self.closePipes()
    
    &lt;&lt; Ensure local dictionary is present &gt;&gt;
    cmd = "%s pipe %s" % (self.aspell_exe_loc, add_dicts)
    if not self.local_dictionary:
        print "openPipes: command = " + cmd
    
    try:
        self.input, self.output = popen2.popen2(cmd)
    except:
        print "exception opening pipe"
        self.input = self.output = None
    
    if self.input:
        self.attached = self.input.readline()
    else:
        self.attached = None
        
    if not self.signonGiven:
        self.signonGiven = true
        if self.attached:
            print self.attached
            es(self.attached,color="blue")
        else:
            print "can not open aspell"
            es("can not open aspell",color="red")</t>
<t tx="rodrigob.121403173614.830">add_dicts = ""

if self.local_dictionary:
    if self.updateDictionary():
        add_dicts = "--add-extra-dicts %s" % self.local_dictionary


</t>
<t tx="rodrigob.121403173614.831">def closePipes (self):
    
    """Close the pipes to aspell.exe"""
    
    # if self.input or self.output: print "closePipes"
    
    if self.input:
        self.input.close()
        self.input = None

    if self.output:
        self.output.close()
        self.output = None</t>
<t tx="rodrigob.121403173614.832">def listAlternates(self, aspell_return):
    
    """Return a list of alternates from aspell."""
    
    match = self.altre.match(aspell_return)

    if match:
        return [item.strip() for item in match.groups()[3].split(",")]
    else:
        return []</t>
<t tx="rodrigob.121403173614.833">def processWord(self, word):

    """Pass a word to aspell and return the list of alternatives."""
    
    if not self.attached:
        return None

    # print "processWord",`word`,`self.output`
    
    self.output.write("%s\n" % word)
    
    ret,junk = self.input.readline(),self.input.readline()

    if ret == "*\n":
        return None
    else:
        return self.listAlternates(ret)</t>
<t tx="rodrigob.121403173614.834">def updateDictionary(self):
    
    """Update the aspell dictionary from a list of words.
    
    Return true if the dictionary was update correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_exe_loc,self.local_language_code,basename,basename))
        os.popen(cmd)
        return true

    except Exception, err:
        es("Unable to update local aspell dictionary: %s" % err)
        print err
        add_dicts = ""
        return false</t>
<t tx="rodrigob.121403173614.835">class spellDialog (leoFind.leoFindBase):
    
    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="rodrigob.121403173614.836"></t>
<t tx="rodrigob.121403173614.837">def __init__ (self):
    
    """Ctor for the Leo Spelling dialog."""
    
    # Call the base ctor to create the dialog.
    leoFind.leoFindBase.__init__(self,"Leo Spell Checking",resizeable=false)
    
    self.local_dictionary_file = self.getLocalDictionary()
    self.local_language_code = self.getLocalLanguageCode("en")
    self.aspell = Aspell(self.local_dictionary_file,self.local_language_code)
    &lt;&lt; set self.dictionary &gt;&gt;
    
    self.createFrame()
    self.fillbox([])
    
    # State variables.
    self.currentWord = None
    self.suggestions = []
    self.c = None
    self.v = None
    self.body = None
    self.work = Tk.Text(None) # A text widget for scanning.

    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="rodrigob.121403173614.838">if self.local_dictionary_file:

    self.dictionary = self.readLocalDictionary(self.local_dictionary_file)
    if self.dictionary:
        # print "Local dictionary:", self.local_dictionary_file
        es("Local dictionary: %s" % shortFileName(self.local_dictionary_file),color="blue")
        if 0:
            keys = self.dictionary.keys()
            keys.sort()
            print "local dict:", keys
    else:
        self.dictionary = {}
        self.local_dictionary_file = None
else:
    self.dictionary = {}</t>
<t tx="rodrigob.121403173614.839">def getLocalDictionary(self):
    
    """Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

    import ConfigParser

    try:
        fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
        config = ConfigParser.ConfigParser()
        config.read(fileName)
        return config.get("main","local_leo_dictionary",None)
    except:
        es_exception()
        return None</t>
<t tx="rodrigob.121403173614.840">def getLocalLanguageCode(self,defaultLanguageCode):
    
    """Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

    import ConfigParser

    try:
        fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
        config = ConfigParser.ConfigParser()
        config.read(fileName)
        return config.get("main","local_language_code",defaultLanguageCode)
    except:
        es_exception()
        return defaultLanguageCode</t>
<t tx="rodrigob.121403173614.841">def readLocalDictionary (self,local_dictionary):
    
    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    try:
        f = open(local_dictionary,"r")
    except IOError:
        es("Unable to open local dictionary '%s' - using a blank one instead" % local_dictionary)
        return None
    
    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        dct = {}
        for word in f.readlines():
            dct[word.strip().lower()] = 0
    finally:
        f.close()

    return dct</t>
<t tx="rodrigob.121403173614.842">def createFrame (self):
    
    """Create the Spelling dialog."""
    
    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2,expand=1,fill="both")

    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
</t>
<t tx="rodrigob.121403173614.843">f = outer

f2 = Tk.Frame(f)
f2.pack(expand=1,fill="x")
self.wordLabel = Tk.Label(f2, text="Suggestions for:")
self.wordLabel.pack(side="left")

fpane = Tk.Frame(f,bd=2)
fpane.pack(side="top", expand=1, fill="x")

self.listBox = Tk.Listbox(fpane,height=30,selectmode="single")
self.listBox.pack(side="left", expand=1, fill="both")

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

for bar,txt in ((listBoxBar,self.listBox),):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")
</t>
<t tx="rodrigob.121403173614.844"># Create the button panes
buttons1  = Tk.Frame(outer,bd=1)
buttons1.pack (anchor="n",expand=1,fill="x")

buttons2  = Tk.Frame(outer,bd=1)
buttons2.pack (anchor="n",expand=1,fill="none")

buttonList = []
for text,command in (
    ("Find",self.onFindButton),
    ("Change",self.onChangeButton),
    ("Change, Find",self.onChangeThenFindButton),
    ("Add",self.onAddButton)):
    width = max(6,len(text))
    b=Tk.Button(buttons1,width=width,text=text,command=command)
    b.pack(side="left",fill="none",expand=1)
    buttonList.append(b)
        
for text,command in (
    ("Undo",self.onUndoButton),
    ("Redo",self.onRedoButton),
    ("Ignore",self.onIgnoreButton),
    ("Hide",self.onHideButton)):
    width = max(6,len(text))
    b=Tk.Button(buttons2,width=width,text=text,command=command)
    b.pack(side="left",fill="none",expand=0)
    buttonList.append(b)

# We need these to enable or disable buttons.
(self.findButton, self.changeButton,
 self.changeFindButton, self.addButton, 
 self.undoButton, self.redoButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="rodrigob.121403173614.845"></t>
<t tx="rodrigob.121403173614.846">def onAddButton (self):
    
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
    self.closePipes()

</t>
<t tx="rodrigob.121403173614.847">def onIgnoreButton (self):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
    self.closePipes()</t>
<t tx="rodrigob.121403173614.848">def onChangeButton (self):
    
    """Handle a click in the Change button in the Check Spelling dialog."""

    self.change()
    self.closePipes()
    self.updateButtons()
    
# Event needed for double-click event.
def onChangeThenFindButton (self,event=None): 
        
    """Handle a click in the "Change, Find" button in the Check Spelling dialog."""

    if self.change():
        self.find()
    self.closePipes()
    self.updateButtons()</t>
<t tx="rodrigob.121403173614.849">def onFindButton (self):
    
    """Handle a click in the Find button in the Check Spelling dialog."""

    self.find()
    self.updateButtons()
    self.closePipes()</t>
<t tx="rodrigob.121403173614.850">def onHideButton (self):
    
    """Handle a click in the Hide button in the Check Spelling dialog."""

    self.closePipes()
    self.top.withdraw()
</t>
<t tx="rodrigob.121403173614.851">def onRedoButton (self):
    
    """Handle a click in the Redo button in the Check Spelling dialog."""

    self.c.undoer.redo() # Not a command, so command hook doesn't fire.
    self.update(show=false,fill=false)
    self.c.frame.body.focus_force()
    
def onUndoButton (self):
    
    """Handle a click in the Undo button in the Check Spelling dialog."""

    self.c.undoer.undo() # Not a command, so command hook doesn't fire.
    self.update(show=false,fill=false)
    self.c.frame.body.focus_force()</t>
<t tx="rodrigob.121403173614.852"></t>
<t tx="rodrigob.121403173614.853">def add (self):

    """Add the selected suggestion to the dictionary."""
    
    if not self.local_dictionary_file:
        return
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.local_dictionary_file,"r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.local_dictionary_file,"w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            es("Adding ",color="blue",newline=false) ; es('%s' % self.currentWord)
        except IOError:
            es("Can not add %s to dictionary" % self.currentWord,color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    
    # Restart aspell so that it re-reads its dictionary.
    self.aspell.closePipes()
    self.aspell.openPipes()
    
    self.onFindButton()</t>
<t tx="rodrigob.121403173614.854">def change(self):
    
    """Make the selected change to the text"""

    c = self.c ; v = self.v ; t = self.body
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            setTextSelection(t,start,start + "+%dc" % (len(selection)))
            newSel = getTextSelection(t)

            # update node, undo status, dirty flag, changed mark &amp; recolor
            c.beginUpdate()
            c.tree.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)
            c.endUpdate(true)
            t.focus_set()
            return true

    # The focus must never leave the body pane.
    t.focus_set()
    return false</t>
<t tx="rodrigob.121403173614.855">def checkSpelling (self,event=None):
    
    """Open the Check Spelling dialog."""

    self.top.deiconify()
    self.top.lift()
    self.update(show=true,fill=false)</t>
<t tx="rodrigob.121403173614.856">def find(self):
    
    """Find the next unknown word."""
    
    # Reload the work pane from the present node.
    s = self.body.get("1.0","end").rstrip()
    self.work.delete("1.0","end")
    self.work.insert("end",s)
    
    # Reset the insertion point of the work widget.
    ins = self.body.index("insert")
    self.work.mark_set("insert",ins)

    alts,word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'
    
    if alts:
        self.fillbox(alts,word)
        self.body.focus_set()
                    
        # Copy the working selection range to the body pane
        start,end = getTextSelection (self.work)
        setTextSelection (self.body,start,end)
    else:
        es("no more misspellings")
        self.fillbox([])</t>
<t tx="rodrigob.121403173614.857">def ignore (self):
    
    """Ignore the incorrect word for the duration of this spell check session."""
    
    es("Ignoring ",color="blue",newline=false) ; es('%s' % self.currentWord)
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="rodrigob.121403173614.858"></t>
<t tx="rodrigob.121403173614.859">def closePipes(self):
    
    self.aspell.closePipes()</t>
<t tx="rodrigob.121403173614.860">def fillbox(self,alts,word=None):

    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text = "Suggestions for: " + word)
    self.listBox.delete(0,"end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i,self.suggestions[i])
    
    if len(self.suggestions):
        self.listBox.select_set(1) # This doesn't show up because we don't have focus.</t>
<t tx="rodrigob.121403173614.861">def findNextMisspelledWord(self):
    
    """Find the next unknown word."""
    
    aspell = self.aspell ; alts = None ; word = None
    c = self.c ; v = self.v
    try:
        aspell.openPipes()
        try:
            while 1:
                v,word = self.findNextWord(v) 
                if not v or not word:
                    alts = None
                    break
                &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
                alts = aspell.processWord(word)
                if alts:
                    self.v = v
                    c.beginUpdate()
                    c.tree.expandAllAncestors(v)
                    c.selectVnode(v)
                    c.endUpdate()
                    break
        except:
            es_exception()
    finally:
        aspell.closePipes()
        return alts, word</t>
<t tx="rodrigob.121403173614.862">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not true and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    
    # print "Ignored", word
    continue
    
# print "Didn't ignore '%s'" % word</t>
<t tx="rodrigob.121403173614.863">def findNextWord (self,v):
    
    """Scan for the next word, leaving the result in the work widget"""

    t = self.work
    word_start = string.letters + '_'
    t.mark_set("insert","insert wordend + 1c")
    while 1:
        # print `t.index("insert")`,`t.index("end-1c")`
        if t.compare("insert","&gt;=","end - 1c"):
            v = v.threadNext()
            if not v: return None,None
            t.delete("1.0","end")
            t.insert("end",v.bodyString())
            t.mark_set("insert","1.0")
        elif t.compare("insert","&gt;=","insert lineend - 1c"):
            t.mark_set("insert","insert lineend + 1line")
        else:
            ch = t.get("insert")
            if ch in word_start:
                word = t.get("insert wordstart","insert wordend")
                setTextSelection(t,"insert wordstart","insert wordend")
                # print "findNextWord:",`word`
                return v,word
            elif ch:
                t.mark_set("insert","insert + 1c")</t>
<t tx="rodrigob.121403173614.864">def getSuggestion (self):
    
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="rodrigob.121403173614.865">def onMap (self,event=None):
    
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show=false,fill=false)</t>
<t tx="rodrigob.121403173614.866">def onSelectListBox (self,event=None):
    
    """Respond to a click in the selection listBox."""
    
    self.updateButtons()
    self.body.focus_set()
</t>
<t tx="rodrigob.121403173614.867">def update (self,show=true,fill=false):
    
    """Update the Spell Check dialog."""
    
    # print "update(show=%d,fill=%d)" % (show,fill)
    
    # Always assume that the user has changed text.
    self.c = c = top()
    self.v = c.currentVnode()
    self.body = c.frame.body
    if fill:
        self.fillbox([])
    self.updateButtons()
    if show:
        self.top.deiconify()
        # Don't interfere with Edit Headline commands.
        self.body.focus_set()
        
    # Give the signon if it hasn't been given yet.
    if not self.aspell.signonGiven:
        self.aspell.openPipes()
        self.aspell.closePipes()</t>
<t tx="rodrigob.121403173614.868">def updateButtons (self):
    
    """Enable or disable buttons in the Check Spelling dialog."""
    
    start,end = getTextSelection(self.body)
    state = choose(self.suggestions and start,"normal","disabled")
    
    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    state = choose(self.c.undoer.canRedo(),"normal","disabled")
    self.redoButton.configure(state=state)
    
    state = choose(self.c.undoer.canUndo(),"normal","disabled")
    self.undoButton.configure(state=state)
    
    state = choose(self.local_dictionary_file,"normal","disabled")
    self.addButton.configure(state=state)

    self.ignoreButton.configure(state="normal")</t>
<t tx="rodrigob.121403173614.869">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="rodrigob.121403173614.870">def idle_body_key (self,v,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    c = self.commands
    if not c or not v or v != c.currentVnode():
        return "break"
    if doHook("bodykey1",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = v.bodyString()
    if not newSel:
        newSel = getTextSelection(c.body)
    if oldText != None:
        s = oldText
    else:
        &lt;&lt; set s to the widget text &gt;&gt;
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\n','\r'):
        &lt;&lt; Do auto indent &gt;&gt;
    elif ch == '\t' and c.tab_width &lt; 0:
        &lt;&lt; convert tab to blanks &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType:
        c.undoer.setUndoTypingParams(v,undoType,body,s,oldSel,newSel,oldYview=oldYview)
    v.t.setTnodeText(s)
    v.t.insertSpot = c.body.index("insert")
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(true)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    doHook("bodykey2",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"</t>
<t tx="rodrigob.121403173614.871">s = c.body.get("1.0", "end")

if s == None:
    s = u""

if type(s) == type(""):
    s = toUnicode(s,app().tkEncoding) # 2/25/03
    # if len(ch) &gt; 0: print `s`</t>
<t tx="rodrigob.121403173614.872"># 6/22/03: Make sure we handle delete key properly.

if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"
    
    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
    
# print `ch`,len(body),len(s)</t>
<t tx="rodrigob.121403173614.873">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    # trace("false: no newline to remove")
    removeTrailing = false
elif len(old) == 0:
    # Ambigous case.
    # trace("false: empty old")
    removeTrailing = ch != '\n' # false
elif old == new[:-1]:
    # A single trailing character has been added.
    # trace("false: only changed trailing.")
    removeTrailing = false
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misreprented the user's intentions slightly.
    # trace("true")
    removeTrailing = true
    
# trace(`ch`+","+`removeTrailing`)


</t>
<t tx="rodrigob.121403173614.874"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.colorizer.useSyntaxColoring(v) and undoType != "Change":
    # Get the previous line.
    s=c.body.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = skip_leading_ws_with_indent(s,0,c.tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(v) == "python":
            width += abs(c.tab_width)
    if app().config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += c.tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = computeLeadingWhitespace (width,c.tab_width)
    if ws and len(ws) &gt; 0:
        c.body.insert("insert", ws)
        removeTrailing = false # bug fix: 11/18</t>
<t tx="rodrigob.121403173614.875"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.body.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = computeWidth(prev,c.tab_width)
        w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
        # print "prev w:" + `w` + ", prev chars:" + `prev`
        c.body.delete("insert -1c")
        c.body.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.body.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = true
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = false
        if all_ws:
            w = computeWidth(prev,c.tab_width)
            w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
            # print "prev w:" + `w` + ", prev chars:" + `prev`
            c.body.delete("insert -1c")
            c.body.insert("insert",' ' * w2)</t>
<t tx="rodrigob.121403173614.876">s = c.body.get("1.0", "end")
s = toUnicode(s,app().tkEncoding) #2/25/03
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]</t>
<t tx="rodrigob.121403173614.877">self.scanForTabWidth(v)
incremental = undoType not in ("Cut","Paste")
self.recolor_now(v,incremental=incremental)</t>
<t tx="rodrigob.121403173614.878">redraw_flag = false

c.beginUpdate()

# Update dirty bits.
if not v.isDirty() and v.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = true
    
# Update icons.
val = v.computeIcon()
if val != v.iconVal:
    v.iconVal = val
    redraw_flag = true

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="rodrigob.121403173614.879"># Called by command handlers that have already changed the text.

def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.commands
    if not v:
        v = c.currentVnode()

    if not oldSel:
        oldSel = getTextSelection(c.body)

    self.idle_body_key(v,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
</t>
<t tx="rodrigob.121403173614.880">def OnBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.commands ; v = c.currentVnode() ; ch = event.char
    oldSel = getTextSelection(c.body)
    
    if 0:
        self.keyCount += 1
        if ch and len(ch)&gt;0: print "%4d %s" % (self.keyCount,repr(ch))
        
    # We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
    self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)</t>
<t tx="rodrigob.121403173614.881"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,v,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.commands
    if not v: v = c.currentVnode()
    if not oldSel:
        oldSel = getTextSelection(c.body)
      
    self.commands.body.after_idle(self.idle_body_key,v,oldSel,undoType,oldYview)

</t>
<t tx="rodrigob.121403173614.882">@language python

from leoGlobals import *

# Import the subcommanders.
import leoAtFile,leoFileCommands,leoImport,leoNodes,leoTangle,leoUndo

class baseCommands:
    """The base class for Leo's main commander."""
    @others

class Commands (baseCommands):
    """A class that implements most of Leo's commands."""
    pass</t>
<t tx="rodrigob.121403173614.883"></t>
<t tx="rodrigob.121403173614.884">def __init__(self,frame):

    # trace("__init__", "c.__init__")
    self.frame = frame
    self.initIvars(frame)

    # initialize the sub-commanders
    self.fileCommands = leoFileCommands.fileCommands(self)
    self.atFileCommands = leoAtFile.atFile(self)
    self.importCommands = leoImport.leoImportCommands(self)
    self.tangleCommands = leoTangle.tangleCommands(self)
    self.undoer = leoUndo.undoer(self)

def initIvars(self, frame):
    &lt;&lt; initialize ivars &gt;&gt;</t>
<t tx="rodrigob.121403173614.885"># per-document info...
self.hookFunction = None
self.openDirectory = None # 7/2/02

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = false # true if any data has been changed since the last save.
self.loading = false # true if we are loading a file: disables c.setChanged()

# copies of frame info
self.body = frame.body
self.log = frame.log
self.tree = frame.tree
self.canvas = frame.canvas

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = 4
self.tangle_batch_flag = false
self.untangle_batch_flag = false
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = false
self.output_doc_flag = false
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

self.setIvarsFromFind()

# New in 3.12
# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.</t>
<t tx="rodrigob.121403173614.886">def __repr__ (self):
    
    try:
        return "Commander: " + self.frame.mFileName
    except:
        return "Commander: bad mFileName"
        
__str__ = __repr__
</t>
<t tx="rodrigob.121403173614.887"># This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):

    c = self ; find = app().findFrame
    if find:
        find.set_ivars(c)
</t>
<t tx="rodrigob.121403173614.888">@ This should be called whenever we need to use preference:
i.e., before reading, writing, tangling, untangling.

7/2/02: We no longer need this now that the Prefs dialog is modal.
@c

def setIvarsFromPrefs (self):

    pass</t>
<t tx="rodrigob.121403173614.889"></t>
<t tx="rodrigob.121403173614.890">def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteHeadline("Cut Node")
        c.recolor()</t>
<t tx="rodrigob.121403173614.891">def copyOutline(self):

    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices() # Revert to 3.11.1 code.
    s = c.fileCommands.putLeoOutline()
    # trace(`s`)
    app().root.clipboard_clear()
    app().root.clipboard_append(s)
    # Copying an outline has no undo consequences.
</t>
<t tx="rodrigob.121403173614.892">@ To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.
@c

def pasteOutline(self):

    a = app() ; c = self ; current = c.currentVnode()
    
    try:
        s = a.root.selection_get(selection="CLIPBOARD")
    except:
        s = None # This should never happen.

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = match(s,0,a.prolog_prefix_string)

    # trace(`s`)
    if isLeo:
        v = c.fileCommands.getLeoOutline(s)
    else:
        v = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if v:
        c.endEditing()
        c.beginUpdate()
        if 1: # inside update...
            v.createDependents()# To handle effects of clones.
            c.validateOutline()
            c.selectVnode(v)
            v.setDirty()
            c.setChanged(true)
            # paste as first child if back is expanded.
            back = v.back()
            if back and back.isExpanded():
                v.moveToNthChildOf(back,0)
            c.undoer.setUndoParams("Paste Node",v)
        c.endUpdate()
        c.recolor()
    else:
        es("The clipboard is not a valid " + choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="rodrigob.121403173614.893"></t>
<t tx="rodrigob.121403173614.894">def beginUpdate(self):

    self.tree.beginUpdate()
    
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="rodrigob.121403173614.895">def bringToFront(self):

    self.frame.top.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="rodrigob.121403173614.896">def endUpdate(self, flag=true):
    
    self.tree.endUpdate(flag)
    
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="rodrigob.121403173614.897">def recolor(self):

    tree = self.tree
    tree.recolor(tree.currentVnode)</t>
<t tx="rodrigob.121403173614.898">def redraw(self):

    self.tree.redraw()
    
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="rodrigob.121403173614.899"></t>
<t tx="rodrigob.121403173614.900">def convertAllBlanks (self):
    
    c = self ; v = current = c.currentVnode()
    next = v.nodeAfterTree()
    dict = scanDirectives(c)
    tabWidth  = dict.get("tabwidth")
    # Create copy for undo.
    v_copy = v.copyTree()
    oldText = c.body.get("1.0","end") # 7/11/03
    oldSel = getTextSelection(c.body) # 7/11/03
    anyChanged = false
    while v and v != next:
        if v == current:
            if c.convertBlanks():
                anyChanged = true # 7/11/03
        else:
            result = [] ; changed = false
            text = v.t.bodyString
            lines = string.split(text, '\n')
            for line in lines:
                s = optimizeLeadingWhitespace(line,tabWidth)
                if s != line:
                    changed = true ; anyChanged = true
                result.append(s)
            if changed:
                result = string.join(result,'\n')
                v.t.setTnodeText(result)
        v.setDirty()
        v = v.threadNext()
    if anyChanged:
        newText = c.body.get("1.0","end") # 7/11/03
        newSel = getTextSelection(c.body) # 7/11/03
        c.undoer.setUndoParams("Convert All Blanks",
            current,select=current,oldTree=v_copy,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel)
    else:
        es("nothing changed")</t>
<t tx="rodrigob.121403173614.901">def convertAllTabs (self):

    c = self ; v = current = c.currentVnode()
    next = v.nodeAfterTree()
    dict = scanDirectives(c)
    tabWidth  = dict.get("tabwidth")
    # Create copy for undo.
    v_copy = v.copyTree()
    oldText = c.body.get("1.0","end") # 7/11/03
    oldSel = getTextSelection(c.body) # 7/11/03
    anyChanged = false
    while v and v != next:
        if v == current:
            if self.convertTabs():
                anyChanged = true # 7/11/03
        else:
            result = [] ; changed = false
            text = v.t.bodyString
            lines = string.split(text, '\n')
            for line in lines:
                i,w = skip_leading_ws_with_indent(line,0,tabWidth)
                s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                if s != line:
                    changed = true ; anyChanged = true
                result.append(s)
            if changed:
                result = string.join(result,'\n')
                v.t.setTnodeText(result)
        v.setDirty()
        v = v.threadNext()
    if anyChanged:
        newText = c.body.get("1.0","end") # 7/11/03
        newSel = getTextSelection(c.body) # 7/11/03
        c.undoer.setUndoParams("Convert All Tabs",
            current,select=current,oldTree=v_copy,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel)
    else:
        es("nothing changed")</t>
<t tx="rodrigob.121403173614.902">def convertBlanks (self):

    c = self ; v = current = c.currentVnode()
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    result = [] ; changed = false

    # DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
    dict = scanDirectives(c)
    tabWidth  = dict.get("tabwidth")

    if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
        for line in lines:
            s = optimizeLeadingWhitespace(line,c.tab_width)
            if s != line: changed = true
            result.append(s)
    else: # DTHEIN 3-NOV-2002: use relative @tabwidth (tabWidth)
        for line in lines:
            s = optimizeLeadingWhitespace(line,tabWidth)
            if s != line: changed = true
            result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Convert Blanks",oldSel,oldYview) # Handles undo
        setTextSelection(c.body,"1.0","1.0")
        
    return changed
</t>
<t tx="rodrigob.121403173614.903">def convertTabs (self):

    c = self
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = [] ; changed = false
    
    # DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
    dict = scanDirectives(c)
    tabWidth  = dict.get("tabwidth")

    if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
        for line in lines:
            i,w = skip_leading_ws_with_indent(line,0,c.tab_width)
            s = computeLeadingWhitespace(w,-abs(c.tab_width)) + line[i:] # use negative width.
            if s != line: changed = true
            result.append(s)
    else: # DTHEIN 3-NOV-2002: use the relative @tabwidth (tabWidth)
        for line in lines:
            i,w = skip_leading_ws_with_indent(line,0,tabWidth)
            s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = true
            result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Convert Tabs",oldSel,oldYview) # Handles undo
        setTextSelection(c.body,"1.0","1.0")
        
    return changed</t>
<t tx="rodrigob.121403173614.904">def createLastChildNode (self,parent,headline,body):
    
    c = self
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""
    v = parent.insertAsLastChild()
    v.initHeadString(headline)
    v.t.setTnodeText(body)
    v.createDependents() # To handle effects of clones.
    v.setDirty()
    c.validateOutline()</t>
<t tx="rodrigob.121403173614.905">def dedentBody (self):

    c = self
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = [] ; changed = false
    for line in lines:
        i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
        s = computeLeadingWhitespace(width-abs(c.tab_width),c.tab_width) + line[i:]
        if s != line: changed = true
        result.append(s)
    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Undent",oldSel,oldYview)</t>
<t tx="rodrigob.121403173614.906">def extract(self):

    c = self ; current = v = c.currentVnode()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0] ; del lines[0]
    junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
    # Create copy for undo.
    v_copy = v.copyTree()
    oldText = c.body.get("1.0","end") # 7/11/03
    oldSel = getTextSelection(c.body) # 7/11/03
    &lt;&lt; Set headline for extract &gt;&gt;
    # Remove leading whitespace from all body lines.
    result = []
    for line in lines:
        # Remove the whitespace on the first line
        line = removeLeadingWhitespace(line,ws,c.tab_width)
        result.append(line)
    # Create a new node from lines.
    body = string.join(result,'\n')
    if head and len(head) &gt; 0:
        head = string.rstrip(head)
    c.beginUpdate()
    if 1: # update range...
        c.createLastChildNode(v,headline,body)
        undoType =  "Can't Undo" # 12/8/02: None enables further undoes, but there are bugs now.
        c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview)
        newText = c.body.get("1.0","end") # 7/11/03
        newSel = getTextSelection(c.body) # 7/11/03
        c.undoer.setUndoParams("Extract",
            v,select=current,oldTree=v_copy,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.907">headline = string.strip(headline)
while len(headline) &gt; 0 and headline[0] == '/':
    headline = headline[1:]
headline = string.strip(headline)</t>
<t tx="rodrigob.121403173614.908">def extractSection(self):

    c = self ; current = v = c.currentVnode()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0] ; del lines[0]
    junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
    line1 = "\n" + headline
    # Create copy for undo.
    v_copy = v.copyTree()
    # trace("v:     " + `v`)
    # trace("v_copy:" + `v_copy`)
    oldText = c.body.get("1.0","end") # 7/11/03
    oldSel = getTextSelection(c.body) # 7/11/03
    &lt;&lt; Set headline for extractSection &gt;&gt;
    # Remove leading whitespace from all body lines.
    result = []
    for line in lines:
        # Remove the whitespace on the first line
        line = removeLeadingWhitespace(line,ws,c.tab_width)
        result.append(line)
    # Create a new node from lines.
    body = string.join(result,'\n')
    if head and len(head) &gt; 0:
        head = string.rstrip(head)
    c.beginUpdate()
    if 1: # update range...
        c.createLastChildNode(v,headline,body)
        undoType = None # Set undo params later.
        c.updateBodyPane(head,line1,tail,undoType,oldSel,oldYview)
        newText = c.body.get("1.0","end") # 7/11/03
        newSel = getTextSelection(c.body) # 7/11/03
        c.undoer.setUndoParams("Extract Section",v,
            select=current,oldTree=v_copy,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.909">while len(headline) &gt; 0 and headline[0] == '/':
    headline = headline[1:]
headline = string.strip(headline)

# Make sure we have a @&lt; or &lt;&lt;
if headline[0:2] != '&lt;&lt;' and headline[0:2] != '@&lt;': return</t>
<t tx="rodrigob.121403173614.910">def extractSectionNames(self):

    c = self ; current = v = c.currentVnode()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    # Create copy for undo.
    v_copy = v.copyTree()
    # No change to body or selection of this node.
    oldText = newText = c.body.get("1.0","end") # 7/11/03
    i, j = oldSel = newSel = self.getBodySelection()
    c.beginUpdate()
    if 1: # update range...
        for s in lines:
            &lt;&lt; Find the next section name &gt;&gt;
            if name: self.createLastChildNode(v,name,None)
        c.selectVnode(v)
        c.validateOutline()
    c.endUpdate()
    # No change to body or selection
    c.undoer.setUndoParams("Extract Names",
        v,select=current,oldTree=v_copy,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel)
    # Restore the selection.
    setTextSelection(c.body,i,j)
    set_focus(c,c.body)</t>
<t tx="rodrigob.121403173614.911">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]</t>
<t tx="rodrigob.121403173614.912">def getBodyLines (self):
    
    c = self
    oldYview = c.frame.body.yview()
    i, j = oldSel = getTextSelection(c.body)
    # if selection was made from back to front, then i and j are reversed
    if i and j and i != j: # 7/7/03
        # Convert all lines containing any part of the selection.
        if c.body.compare(i,"&gt;",j): i,j = j,i
        i = c.body.index(i + "linestart")
        # 12-SEP-2002 DTHEIN: don't include following line in selection
        endSel = j # position of last character of selection
        trailingNewline = ""
        line,col = j.split(".")
        if col == "0":  # DTHEIN: selection ends at start of next line
            endSel = c.body.index(j + "- 1 chars")
            trailingNewline = '\n'
        else: # DTHEIN: selection ends in the midst of a line
            endSel = c.body.index(j + "lineend")
            j = endSel
        head = c.body.get("1.0",i)
        tail = c.body.get(j,"end")
    else: # Convert the entire text.
        i = "1.0" ; j = "end" ; head = tail = ""
        endSel = c.body.index(j + "- 1 chars") # 14-SEP-2002 DTHEIN
        trailingNewline = ""
    if i == endSel:
        head = tail = None ; lines = []
    else:
        lines = c.body.get(i,endSel)
        lines = string.split(lines, '\n')
        lines[-1] += trailingNewline # DTHEIN: add newline if needed
    return head,lines,tail,oldSel,oldYview</t>
<t tx="rodrigob.121403173614.913">def getBodySelection (self):

    c = self
    i, j = getTextSelection(c.body)
    if i and j and c.body.compare(i,"&gt;",j):
        i,j = j,i
    return i, j</t>
<t tx="rodrigob.121403173614.914">def indentBody (self):

    c = self
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = [] ; changed = false
    for line in lines:
        i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
        s = computeLeadingWhitespace(width+abs(c.tab_width),c.tab_width) + line[i:]
        if s != line: changed = true
        result.append(s)
    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Indent",oldSel,oldYview)</t>
<t tx="rodrigob.121403173614.915">def reformatParagraph(self):
    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting.
Leading tabs are sized to present tab width setting.
First and second line of original text is used to determine leading whitespace
in reformatted text.  Hanging indentation is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@".  Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    x = body.index("current")
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []

    dict = scanDirectives(c)
    pageWidth = dict.get("pagewidth")
    tabWidth  = dict.get("tabwidth")
    # trace(`tabWidth`+","+`pageWidth`)

    # If active selection, then don't attempt a reformat.
    selStart, selEnd = getTextSelection(body)
    if selStart != selEnd: return

    # Find the paragraph range.
    data = bound_paragraph(body)
    if data:
        start, end, endsWithNL = data
        firstLine = int(float(start)) - 1 # subtract 1 to get on zero basis
        lastLine = int(float(end)) - 1
    else: return
    
    # Compute the leading whitespace.
    indents = [0,0] ; leading_ws = ["",""] # Bug fix: 11/16/02
    for i in (0,1):
        if firstLine + i &lt; len(lines):
            # Use the original, non-optimized leading whitespace.
            leading_ws[i] = ws = get_leading_ws(lines[firstLine+i])
            indents[i] = computeWidth(ws,tabWidth)
    indents[1] = max(indents)
    # 11/17/02: Bug fix suggested by D.T.Hein.
    if 1 == (lastLine - firstLine):
        leading_ws[1] = leading_ws[0]

    # Put the leading unchanged lines.
    for i in range(0,firstLine):
        result.append(lines[i])
        
    # Wrap the lines, decreasing the page width by indent.
    wrapped_lines = wrap_lines(
        lines[firstLine:lastLine],
        pageWidth-indents[1],
        pageWidth-indents[0])
    lineCount = len(wrapped_lines)
        
    i = 0
    for line in wrapped_lines:
        result.append(leading_ws[i] + line)
        if i &lt; 1: i += 1

    # Put the trailing unchanged lines.
    for i in range(lastLine,len(lines)):
        result.append(lines[i])

    # Replace the text if it changed.
    for i in range(firstLine,lineCount+firstLine):
        if i &gt;= lastLine or lines[i] != result[i]:
            result = string.join(result,'\n')
            c.updateBodyPane(head,result,tail,"Reformat Paragraph",oldSel,oldYview) # Handles undo
            break

    &lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;

    # Make sure we can see the new cursor.
    body.see("insert-5l")
</t>
<t tx="rodrigob.121403173614.916">lastLine = firstLine + lineCount
if not endsWithNL:
    insPos = str(lastLine) + ".0lineend"
else:
    endPos = body.index("end")
    endLine = int(float(endPos))
    lastLine += 1
    insPos = str(lastLine) + ".0"
    while lastLine &lt; endLine:
        s = body.get(insPos,insPos + "lineend")
        if s and (0 &lt; len(s)) and not s.isspace():
            break;
        lastLine += 1
        insPos = str(lastLine) + ".0"
setTextSelection(body,insPos,insPos)</t>
<t tx="rodrigob.121403173614.917">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):
    
    c = self ; v = c.currentVnode()
    # trace(v)
    # Update the text and set start, end.
    c.body.delete("1.0","end")
    # The caller must do rstrip.head if appropriate.
    if head and len(head) &gt; 0:
        c.body.insert("end",head)
        start = c.body.index("end-1c")
    else: start = "1.0"
    if middle and len(middle) &gt; 0:
        c.body.insert("end",middle)
        end = c.body.index("end-1c")
    else: end = start
    if tail and len(tail) &gt; 0:
        tail = string.rstrip(tail)
    if tail and len(tail) &gt; 0:
        c.body.insert("end",tail)
    # Activate the body key handler by hand.
    c.tree.onBodyChanged(v,undoType,oldSel=oldSel,oldYview=oldYview)
    # Update the changed mark.
    if not c.isChanged():
        c.setChanged(true)
    # Update the icon.
    c.beginUpdate()
    if not v.isDirty():
        v.setDirty()
    c.endUpdate()
    # Update the selection.
    # trace(`start` + "," + `end`)
    setTextSelection(c.body,start,end)
    if oldYview:
        first,last=oldYview
        c.body.yview("moveto",first)
    else:
        c.body.see("insert")
    set_focus(c,c.body)
    c.recolor() # 7/5/02</t>
<t tx="rodrigob.121403173614.918"></t>
<t tx="rodrigob.121403173614.919">def canContractAllHeadlines (self):

    c = self ; v = c.rootVnode()
    if not v: return false
    while v:
        if v.isExpanded():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.920">def canContractAllSubheads (self):

    c = self
    v = c.currentVnode()
    if not v: return false
    next = v.nodeAfterTree()
    v = v.threadNext()
    while v and v != next:
        if v.isExpanded():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.921">def canContractParent (self):

    c = self ; v = c.currentVnode()
    return v.parent() != None</t>
<t tx="rodrigob.121403173614.922">def canContractSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return false
    v = v.firstChild()
    while v:
        if v.isExpanded():
            return true
        v = v.next()
    return false</t>
<t tx="rodrigob.121403173614.923">def canDeleteHeadline (self):

    c = self ; v = c.currentVnode()
    if not v: return false
    if v.parent(): # v is below the top level.
        return true
    else: # v is at the top level.  We can not delete the last node.
        return v.threadBack() or v.next()

canCutOutline = canDeleteHeadline</t>
<t tx="rodrigob.121403173614.924">def canDemote (self):

    c = self
    v = c.currentVnode()
    if not v: return false
    return v.next() != None</t>
<t tx="rodrigob.121403173614.925">def canExpandAllHeadlines (self):

    c = self ; v = c.rootVnode()
    if not v: return false
    while v:
        if not v.isExpanded():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.926">def canExpandAllSubheads (self):

    c = self
    v = c.currentVnode()
    if not v: return false
    next = v.nodeAfterTree()
    v = v.threadNext()
    while v and v != next:
        if not v.isExpanded():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.927">def canExpandSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return false
    v = v.firstChild()
    while v:
        if not v.isExpanded():
            return true
        v = v.next()
    return false</t>
<t tx="rodrigob.121403173614.928">def canExtract (self):

    c = self
    if c.body:
        i, j = getTextSelection(c.body)
        return i and j and c.body.compare(i, "!=", j)
    else:
        return false

canExtractSection = canExtract
canExtractSectionNames = canExtract</t>
<t tx="rodrigob.121403173614.929">def canFindMatchingBracket (self):
    
    c = self ; body = c.body
    brackets = "()[]{}"
    c1 = body.get("insert -1c")
    c2 = body.get("insert")
    # Bug fix: 2/11/03
    return (c1 and c1 in brackets) or (c2 and c2 in brackets)</t>
<t tx="rodrigob.121403173614.930">def canGoToNextDirtyHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return false

    v = c.rootVnode()
    while v:
        if v.isDirty()and v != current:
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.931">def canGoToNextMarkedHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return false

    v = c.rootVnode()
    while v:
        if v.isMarked()and v != current:
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.932">def canMarkChangedHeadlines (self):

    c = self ; v = c.rootVnode()
    while v:
        if v.isDirty():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.933">def canMarkChangedRoots (self):

    c = self ; v = c.rootVnode()
    while v:
        if v.isDirty():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.934">def canMoveOutlineDown (self):

    c = self
    if 1: # The permissive way
        current = c.currentVnode()
        if not current: return false
        v = current.visNext()
        while v and current.isAncestorOf(v):
            v = v.visNext()
        return v != None
    else: # The MORE way.
        return c.currentVnode().next() != None</t>
<t tx="rodrigob.121403173614.935">def canMoveOutlineLeft (self):

    c = self ; v = c.currentVnode()
    if 0: # Old code: assumes multiple leftmost nodes.
        return v and v.parent()
    else: # Can't move a child of the root left.
        return v and v.parent() and v.parent().parent()</t>
<t tx="rodrigob.121403173614.936">def canMoveOutlineRight (self):

    c = self ; v = c.currentVnode()
    return v and v.back()</t>
<t tx="rodrigob.121403173614.937">def canMoveOutlineUp (self):

    c = self ; v = c.currentVnode()
    if 1: # The permissive way.
        return v and v.visBack()
    else: # The MORE way.
        return v and v.back()</t>
<t tx="rodrigob.121403173614.938">def canPasteOutline (self,s=None):

    a = app() ; c = self
    if s == None:
        try:
            s = a.root.selection_get(selection="CLIPBOARD")
        except:
            return false

    # trace(s)
    if match(s,0,a.prolog_prefix_string):
        return true
    elif len(s) &gt; 0:
        return c.importCommands.stringIsValidMoreFile(s)
    else:
        return false</t>
<t tx="rodrigob.121403173614.939">def canPromote (self):

    c = self ; v = c.currentVnode()
    return v and v.hasChildren()</t>
<t tx="rodrigob.121403173614.940">def canRevert (self):

    # c.mFileName will be "untitled" for unsaved files.
    c = self
    return (c.frame and c.frame.mFileName and
        len(c.frame.mFileName) &gt; 0 and c.isChanged())</t>
<t tx="rodrigob.121403173614.941"># 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
    v = self.currentVnode()
    return v and v.threadBack()
    
def canSelectThreadNext (self):
    v = self.currentVnode()
    return v and v.threadNext()

def canSelectVisBack (self):
    v = self.currentVnode()
    return v and v.visBack()
    
def canSelectVisNext (self):
    v = self.currentVnode()
    return v and v.visNext()</t>
<t tx="rodrigob.121403173614.942">def canShiftBodyLeft (self):

    c = self
    if c.body:
        s = c.body.GetValue()
        return len(s) &gt; 0
    else:
        return false
        
def canShiftBodyRight (self):

    c = self
    if c.body:
        s = c.body.GetValue()
        return len(s) &gt; 0
    else:
        return false</t>
<t tx="rodrigob.121403173614.943">def canSortChildren (self):

    c = self ; v = c.currentVnode()
    return v and v.hasChildren()
    
def canSortSiblings (self):

    c = self ; v = c.currentVnode()
    return v.next() or v.back()</t>
<t tx="rodrigob.121403173614.944">def canUndo (self):

    c = self
    return c.undoer.canUndo()
    
def canRedo (self):

    c = self
    return c.undoer.canRedo()</t>
<t tx="rodrigob.121403173614.945"># Returns true if any node is marked.

def canUnmarkAll (self):

    c = self ; v = c.rootVnode()
    while v:
        if v.isMarked():
            return true
        v = v.threadNext()
    return false</t>
<t tx="rodrigob.121403173614.946"></t>
<t tx="rodrigob.121403173614.947"></t>
<t tx="rodrigob.121403173614.948">def contractAllHeadlines (self):

    c = self ; current = c.currentVnode()
    v = c.rootVnode()
    c.beginUpdate()

    while v:
        c.contractSubtree(v)
        v = v.next()

    if not current.isVisible():
        # 1/31/03: Select the topmost ancestor of the presently selected node.
        v = current
        while v and v.parent():
            v = v.parent()
        c.selectVnode(v)

    c.endUpdate()
    c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="rodrigob.121403173614.949">def contractNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    v.contract()
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.950">def contractParent (self):
    
    c = self ; v = c.currentVnode()
    parent = v.parent()
    if not parent: return
    
    c.beginUpdate()
    c.selectVnode(parent)
    parent.contract()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.951">def expandAllHeadlines(self):

    c = self ; v = root = c.rootVnode()
    c.beginUpdate()
    while v:
        c.expandSubtree(v)
        v = v.next()
    c.selectVnode(root)
    c.endUpdate()
    c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="rodrigob.121403173614.952">def expandAllSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    c.expandSubtree(v)
    while child:
        c.expandSubtree(child)
        child = child.next()
    c.selectVnode(v)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.953">def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
</t>
<t tx="rodrigob.121403173614.954">def expandNextLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="rodrigob.121403173614.955">def expandNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    v.expand()
    c.endUpdate()

</t>
<t tx="rodrigob.121403173614.956">def expandPrevLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="rodrigob.121403173614.957"></t>
<t tx="rodrigob.121403173614.958">def contractSubtree (self,v):

    last = v.lastNode()
    while v and v != last:
        v.contract()
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.959">def expandSubtree (self,v):

    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.tree.redraw()</t>
<t tx="rodrigob.121403173614.960">def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    if 1: # 1/31/03: The expansion is local to the present node.
        v = c.currentVnode() ; n = v.level()
        after = v.nodeAfterTree()
        while v and v != after:
            if v.level() - n + 1 &lt; level:
                v.expand()
            else:
                v.contract()
            v = v.threadNext()
    else: # The expansion is global
        # Start the recursion.
        # First contract everything.
        c.contractAllHeadlines()
        v = c.rootVnode()
        while v:
            c.expandTreeToLevelFromLevel(v,level,1)
            v = v.next()
    c.expansionLevel = level
    c.expansionNode = c.currentVnode()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.961"></t>
<t tx="rodrigob.121403173614.962"># Compatibility with scripts

def currentVnode (self):

    return self.tree.currentVnode
</t>
<t tx="rodrigob.121403173614.963">def clearAllMarked (self):

    c = self ; v = c.rootVnode()
    while v:
        v.clearMarked()
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.964">def clearAllVisited (self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        # tick("clearAllVisited loop")
        v.clearVisited()
        if v.t:
            v.t.clearVisited()
        v = v.threadNext()
    c.endUpdate(false) # never redraw the tree.</t>
<t tx="rodrigob.121403173614.965"># Compatibility with scripts

def fileName (self):

    return self.frame.mFileName
</t>
<t tx="rodrigob.121403173614.966">def isChanged (self):

    return self.changed</t>
<t tx="rodrigob.121403173614.967"># Compatibility with scripts

def rootVnode (self):

    return self.tree.rootVnode
</t>
<t tx="rodrigob.121403173614.968">def setChanged (self,changedFlag):

    c = self
    if not c.frame: return
    # Clear all dirty bits _before_ setting the caption.
    # 9/15/01 Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        v = c.rootVnode()
        while v:
            if v.isDirty() and not (v.isAtFileNode() or v.isAtRawFileNode()):
                v.clearDirtyJoined()
            v = v.threadNext()
    # Update all derived changed markers.
    c.changed = changedFlag
    s = c.frame.top.title()
    if len(s) &gt; 2 and not c.loading: # don't update while loading.
        if changedFlag:
            # import traceback ; traceback.print_stack()
            if s [0] != '*': c.frame.top.title("* " + s)
        else:
            if s[0:2]=="* ": c.frame.top.title(s[2:])


</t>
<t tx="rodrigob.121403173614.969"></t>
<t tx="rodrigob.121403173614.970"># Returns false if any node of tree is a clone of parent or any of parents ancestors.

def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    clone_message = "Illegal move or drag: no clone may contain a clone of itself"
    drag_message  = "Illegal drag: Can't drag a node into its own tree"

    # 10/25/02: Create dictionaries for faster checking.
    parents = {} ; clones = {}
    while parent:
        parents [parent.t] = parent.t
        if parent.isCloned():
            clones [parent.t] = parent.t
        parent = parent.parent()
    
    # 10/25/02: Scan the tree only once.
    v = root ; next = root.nodeAfterTree()
    while v and v != next:
        ct = clones.get(v.t)
        if ct != None and ct == v.t:
            if warningFlag:
                alert(clone_message)
            return false
        v = v.threadNext()

    pt = parents.get(root.t)
    if pt == None:
        return true
    else:
        if warningFlag:
            alert(drag_message)
        return false
</t>
<t tx="rodrigob.121403173614.971"># Deletes the current vnode and dependent nodes. Does nothing if the outline would become empty.

def deleteHeadline (self,op_name="Delete Outline"):

    c = self ; v = c.currentVnode()
    if not v: return
    vBack = v.visBack()
    # Bug fix: 1/18/00: if vBack is NULL we are at the top level,
    # the next node should be v.next(), _not_ v.visNext();
    if vBack: newNode = vBack
    else: newNode = v.next()
    if not newNode: return
    c.endEditing()# Make sure we capture the headline for Undo.
    c.beginUpdate()
    v.setDirtyDeleted() # 8/3/02: Mark @file nodes dirty for all clones in subtree.
    # Reinsert v after back, or as the first child of parent, or as the root.
    c.undoer.setUndoParams(op_name,v,select=newNode)
    v.doDelete(newNode) # doDelete destroys dependents.
    c.setChanged(true)
    c.endUpdate()
    c.validateOutline()</t>
<t tx="rodrigob.121403173614.972"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Outline"):

    c = self ; current = c.currentVnode()
    if not current: return

    c.beginUpdate()
    if 1: # inside update...
        if current.hasChildren() and current.isExpanded():
            v = current.insertAsNthChild(0)
        else:
            v = current.insertAfter()
        c.undoer.setUndoParams(op_name,v,select=current)
        v.createDependents() # To handle effects of clones.
        c.selectVnode(v)
        c.editVnode(v)
        v.setDirty() # Essential in Leo2.
        c.setChanged(true)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.973">def clone (self):

    c = self ; v = c.currentVnode()
    if not v: return
    c.beginUpdate()
    clone = v.clone(v)
    clone.setDirty() # essential in Leo2
    c.setChanged(true)
    if c.validateOutline():
        c.selectVnode(clone)
        c.undoer.setUndoParams("Clone",clone)
    c.endUpdate() # updates all icons</t>
<t tx="rodrigob.121403173614.974">def initAllCloneBits (self):
    
    """Initialize all clone bits in the entire outline"""
    # trace()

    c=self
    c.clearAllVisited()
    v = self.tree.rootVnode
    c.beginUpdate()
    while v:
        if not v.t.isVisited():
            v.t.setVisited() # Inhibit visits to all joined nodes.
            c.initJoinedCloneBits(v)
        v = v.threadNext()
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.975"># Initializes all clone bits in the all nodes joined to v.

def initJoinedCloneBits (self,v):

    c = self
    c.beginUpdate()
    mark = v.shouldBeClone()
    if mark:
        # Set clone bit in v and all joined nodes.
        v.setClonedBit()
        for v2 in v.t.joinList:
            v2.setClonedBit()
    else:
        # Set clone bit in v and all joined nodes.
        v.clearClonedBit()
        for v2 in v.t.joinList:
            v2.clearClonedBit()
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.976"># Makes sure all nodes are valid.

def validateOutline (self):

    c = self ; root = c.rootVnode()
    if root:
        return root.validateOutlineWithParent(None)
    else:
        return true</t>
<t tx="rodrigob.121403173614.977"></t>
<t tx="rodrigob.121403173614.978">def goToNextDirtyHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isDirty():
        v = v.threadNext()
    if not v:
        v = c.rootVnode()
        while v and not v.isDirty():
            v = v.threadNext()
    if v:
        c.selectVnode(v)</t>
<t tx="rodrigob.121403173614.979">def goToNextMarkedHeadline(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isMarked():
        v = v.threadNext()
    if v:
        c.beginUpdate()
        c.endEditing()
        c.selectVnode(v)
        c.endUpdate()</t>
<t tx="rodrigob.121403173614.980">def goToNextClone(self):

    c = self ; current = c.currentVnode()
    if not current: return
    if not current.isCloned(): return

    v = current.threadNext()
    while v and v.t != current.t:
        v = v.threadNext()
        
    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and v != current and v.t != current.t:
            v = v.threadNext()

    if v:
        c.beginUpdate()
        c.endEditing()
        c.selectVnode(v)
        c.endUpdate()</t>
<t tx="rodrigob.121403173614.981">def markChangedHeadlines (self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.isDirty()and not v.isMarked():
            v.setMarked()
            c.setChanged(true)
        v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.982">def markChangedRoots (self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.isDirty()and not v.isMarked():
            s = v.bodyString()
            flag, i = is_special(s,0,"@root")
            if flag:
                v.setMarked()
                c.setChanged(true)
        v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.983">def markAllAtFileNodesDirty (self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.isAtFileNode()and not v.isDirty():
            v.setDirty()
            v = v.nodeAfterTree()
        else: v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.984">def markAtFileNodesDirty (self):

    c = self
    v = c.currentVnode()
    if not v: return
    after = v.nodeAfterTree()
    c.beginUpdate()
    while v and v != after:
        if v.isAtFileNode() and not v.isDirty():
            v.setDirty()
            v = v.nodeAfterTree()
        else: v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.985">def markClones (self):

    c = self ; current = v = c.currentVnode()
    if not v: return
    if not v.isCloned(): return
    
    v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.t == current.t:
            v.setMarked()
        v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.986">def markHeadline (self):

    c = self ; v = c.currentVnode()
    if not v: return

    c.beginUpdate()
    if v.isMarked():
        v.clearMarked()
    else:
        v.setMarked()
        v.setDirty()
        c.setChanged(true)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.987">def markSubheads(self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    while child:
        if not child.isMarked():
            child.setMarked()
            child.setDirty()
            c.setChanged(true)
        child = child.next()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.988">def unmarkAll(self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.isMarked():
            v.clearMarked()
            v.setDirty()
            c.setChanged(true)
        v = v.threadNext()
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.989"></t>
<t tx="rodrigob.121403173614.990">def dragAfter(self,v,after):

    # es("dragAfter")
    c = self
    if not c.checkMoveWithParentWithWarning(v,after.parent(),true): return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        v.moveAfter(after)
        c.undoer.setUndoParams("Drag",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        v.setDirty()
        c.selectVnode(v)
        c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="rodrigob.121403173614.991">def dragCloneToNthChildOf (self,v,parent,n):

    c = self
    c.beginUpdate()
    # trace("v,parent,n:"+v.headString()+","+parent.headString()+","+`n`)
    clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
    if not c.checkMoveWithParentWithWarning(clone,parent,true):
        clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
        c.endUpdate(false) # Nothing has changed.
        return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.endEditing()
    clone.setDirty()
    clone.moveToNthChildOf(parent,n)
    c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
    c.undoer.setUndoParams("Drag &amp; Clone",clone,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
    clone.setDirty()
    c.selectVnode(clone)
    c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="rodrigob.121403173614.992">def dragToNthChildOf(self,v,parent,n):

    # es("dragToNthChildOf")
    c = self
    if not c.checkMoveWithParentWithWarning(v,parent,true): return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        v.moveToNthChildOf(parent,n)
        c.undoer.setUndoParams("Drag",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        v.setDirty()
        c.selectVnode(v)
        c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="rodrigob.121403173614.993">def sortChildren(self):

    c = self ; v = c.currentVnode()
    if not v or not v.hasChildren(): return
    &lt;&lt; Set the undo info for sortChildren &gt;&gt;
    c.beginUpdate()
    c.endEditing()
    v.sortChildren()
    v.setDirty()
    c.setChanged(true)
    c.endUpdate()
    
def sortSiblings (self):
    
    c = self ; v = c.currentVnode()
    if not v: return
    parent = v.parent()
    if not parent:
        c.sortTopLevel()
    else:
        &lt;&lt; Set the undo info for sortSiblings &gt;&gt;
        c.beginUpdate()
        c.endEditing()
        parent.sortChildren()
        parent.setDirty()
        c.setChanged(true)
        c.endUpdate()</t>
<t tx="rodrigob.121403173614.994"># Get the present list of children.
children = []
child = v.firstChild()
while child:
    children.append(child)
    child = child.next()
c.undoer.setUndoParams("Sort Children",v,sort=children)</t>
<t tx="rodrigob.121403173614.995"># Get the present list of siblings.
sibs = []
sib = parent.firstChild()
while sib:
    sibs.append(sib)
    sib = sib.next()
c.undoer.setUndoParams("Sort Siblings",v,sort=sibs)</t>
<t tx="rodrigob.121403173614.996">def sortTopLevel (self):
    
    # Create a list of vnode, headline tuples
    c = self ; v = root = c.rootVnode()
    if not v: return
    &lt;&lt; Set the undo info for sortTopLevel &gt;&gt;
    pairs = []
    while v:
        pairs.append((v.headString().lower(), v))
        v = v.next()
    # Sort the list on the headlines.
    pairs.sort()
    sortedNodes = pairs
    # Move the nodes
    c.beginUpdate()
    h,v = sortedNodes[0]
    if v != root:
        v.moveToRoot(oldRoot=root)
    for h,next in sortedNodes[1:]:
        next.moveAfter(v)
        v = next
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.997"># Get the present list of children.
sibs = []
sib = c.rootVnode()
while sib:
    sibs.append(sib)
    sib = sib.next()
c.undoer.setUndoParams("Sort Top Level",v,sort=sibs)</t>
<t tx="rodrigob.121403173614.998">def demote(self):

    c = self ; v = c.currentVnode()
    if not v or not v.next(): return
    last = v.lastChild() # EKR: 3/19/03
    # Make sure all the moves will be valid.
    child = v.next()
    while child:
        if not c.checkMoveWithParentWithWarning(child,v,true):
            return
        child = child.next()
    c.beginUpdate()
    if 1: # update range...
        c.mInhibitOnTreeChanged = true
        c.endEditing()
        while v.next():
            child = v.next()
            child.moveToNthChildOf(v,v.numberOfChildren())
        v.expand()
        c.selectVnode(v)
        v.setDirty()
        c.setChanged(true)
        c.mInhibitOnTreeChanged = false
        c.initAllCloneBits() # 7/6/02
    c.endUpdate()
    c.undoer.setUndoParams("Demote",v,lastChild=last)
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="rodrigob.121403173614.999">@ Moving down is more tricky than moving up; we can't move v to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

    c = self
    v = c.currentVnode()
    if not v: return
    # Set next to the node after which v will be moved.
    next = v.visNext()
    while next and v.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        &lt;&lt; Move v down &gt;&gt;
        v.setDirty() # This second call is essential.
        c.selectVnode(v)# 4/23/01
        c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="rodrigob.121403173614.1000"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if next.hasChildren() and next.isExpanded():
    # Attempt to move v to the first child of next.
    if c.checkMoveWithParentWithWarning(v,next,true):
        v.moveToNthChildOf(next,0)
        c.undoer.setUndoParams("Move Down",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
    # Attempt to move v after next.
    if c.checkMoveWithParentWithWarning(v,next.parent(),true):
        v.moveAfter(next)
        c.undoer.setUndoParams("Move Down",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="rodrigob.121403173614.1001">def moveOutlineLeft(self):
    
    # clear_stats() ; # stat()
    c = self
    v = c.currentVnode()
    if not v: return
    parent = v.parent()
    if not parent: return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        v.moveAfter(parent)
        c.undoer.setUndoParams("Move Left",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        v.setDirty()
        c.selectVnode(v)
        c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.
    # print_stats()</t>
<t tx="rodrigob.121403173614.1002">def moveOutlineRight(self):
    
    # clear_stats() ; # stat()
    c = self
    v = c.currentVnode()
    if not v: return
    back = v.back()
    if not back: return
    if not c.checkMoveWithParentWithWarning(v,back,true): return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        n = back.numberOfChildren()
        v.moveToNthChildOf(back,n)
        c.undoer.setUndoParams("Move Right",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        v.setDirty()
        c.selectVnode(v)
        c.setChanged(true)
        c.initJoinedCloneBits(v) # 7/6/02
    c.endUpdate()
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.
    # print_stats()</t>
<t tx="rodrigob.121403173614.1003">def moveOutlineUp(self):

    c = self
    v = c.currentVnode()
    if not v: return
    back = v.visBack()
    if not back: return
    back2 = back.visBack()
    c = self
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setDirty()
        &lt;&lt; Move v up &gt;&gt;
        v.setDirty()
        c.selectVnode(v)
        c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="rodrigob.121403173614.1004"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if not back2:
    # v will be the new root node
    v.moveToRoot(c.tree.rootVnode) # 3/16/02, 5/17/02
    c.undoer.setUndoParams("Move Up",v,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(v,back2,true):
        v.moveToNthChildOf(back2,0)
        c.undoer.setUndoParams("Move Up",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(v,back2.parent(),true):
    # Insert after back2.
    v.moveAfter(back2)
    c.undoer.setUndoParams("Move Up",v,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="rodrigob.121403173614.1005">def promote(self):

    c = self
    v = c.currentVnode()
    if not v or not v.hasChildren(): return
    last = v.lastChild() # EKR: 3/19/03
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        after = v
        while v.hasChildren():
            child = v.firstChild()
            child.moveAfter(after)
            after = child
        v.setDirty()
        c.setChanged(true)
        c.selectVnode(v)
    c.endUpdate()
    c.undoer.setUndoParams("Promote",v,lastChild=last)
    c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="rodrigob.121403173614.1006">def dragCloneAfter (self,v,after):

    c = self
    c.beginUpdate()
    clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
    # trace("v,after:"+v.headString()+","+after.headString())
    if not c.checkMoveWithParentWithWarning(clone,after.parent(),true):
        trace("invalid clone move")
        clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
        c.endUpdate(false) # Nothing has changed.
        return
    # Remember both the before state and the after state for undo/redo
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.endEditing()
    clone.setDirty()
    clone.moveAfter(after)
    c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
    c.undoer.setUndoParams("Drag &amp; Clone",clone,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
    clone.setDirty()
    c.selectVnode(clone)
    c.setChanged(true)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="rodrigob.121403173614.1007"></t>
<t tx="rodrigob.121403173614.1008"># Selects v: sets the focus to v and edits v.

def editVnode(self,v):

    c = self
    # trace(v)
    if v:
        c.selectVnode(v)
        c.tree.editLabel(v)</t>
<t tx="rodrigob.121403173614.1009"># Ends the editing in the outline.

def endEditing(self):

    self.tree.endEditLabel()
</t>
<t tx="rodrigob.121403173614.1010">def selectThreadBack(self):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.threadBack()
    if v:
        c.beginUpdate()
        c.selectVnode(v)
        c.endUpdate()
</t>
<t tx="rodrigob.121403173614.1011">def selectThreadNext(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    if v:
        c.beginUpdate()
        c.selectVnode(v)
        c.endUpdate()</t>
<t tx="rodrigob.121403173614.1012"># This has an up arrow for a control key.

def selectVisBack(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.visBack()
    if v:
        c.beginUpdate()
        c.selectVnode(v)
        c.endUpdate()</t>
<t tx="rodrigob.121403173614.1013">def selectVisNext(self):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.visNext()
    if v:
        c.beginUpdate()
        c.selectVnode(v)
        c.endUpdate()
</t>
<t tx="rodrigob.121403173614.1014"># This is called inside commands to select a new vnode.

def selectVnode(self,v,updateBeadList=true):

    # All updating and "synching" of nodes are now done in the event handlers!
    c = self
    c.tree.endEditLabel()
    c.tree.select(v,updateBeadList)
    # trace(v)
    set_focus(c,c.body)
    self.editing = false</t>
<t tx="rodrigob.121403173614.1015"># Selects the given node and enables editing of the headline if editFlag is true.

def selectVnodeWithEditing(self,v,editFlag):

    c = self
    if editFlag:
        c.editVnode(v)
    else:
        c.selectVnode(v)
</t>
<t tx="rodrigob.121403173614.1016">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="rodrigob.121403173614.1017">def updateSyntaxColorer(self,v):

    self.tree.colorizer.updateSyntaxColorer(v)
</t>
<t tx="rodrigob.121403173614.1018">@language python

&lt;&lt; about the tree classes &gt;&gt;

from leoGlobals import *
import leoColor
import os,string,Tkinter,tkFont,types

&lt;&lt; about drawing and events &gt;&gt;
&lt;&lt; drawing constants &gt;&gt;

class baseLeoTree:
    """The base class of the Leo's tree class."""
    @others
    
class leoTree (baseLeoTree):
    """A class that draws and handles events in an outline."""
    pass</t>
<t tx="rodrigob.121403173614.1019">@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.
</t>
<t tx="rodrigob.121403173614.1020">@ Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.  These topics are interrelated.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is true.  This allows code to suppress redrawing entirely when needed.  For example, study the idle_body_key event handler to see how Leo conditionally redraws the outline pane.

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.

Handling events. Besides redrawing the screen, Leo must handle events or commands that change the text in the outline or body panes.  It is surprisingly difficult to ensure that headline and body text corresponds to the vnode and tnode corresponding to presently selected outline, and vice versa. For example, when the user selects a new headline in the outline pane, we must ensure that 1) the vnode and tnode of the previously selected node have up-to-date information and 2) the body pane is loaded from the correct data in the corresponding tnode.  Early versions of Leo attempted to satisfy these conditions when the user switched outline nodes.  Such attempts never worked well; there were too many special cases.  Later versions of Leo, including leo.py, use a much more direct approach.  The event handlers make sure that the vnode and tnode corresponding to the presently selected node are always kept up-to-date.  In particular, every keystroke in the body pane causes the presently selected tnode to be updated immediately.  There is no longer any need for the c.synchVnode method, though that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline panes.  The actual work is done in the idle_head_key and idle_body_key methods.  These routines are surprisingly complex; they must handle all the tasks mentioned above, as well as others. The idle_head_key and idle_body_key methods should not be called outside the leoTree class.  However, it often happens that code that handles user commands must simulate an event.  That is, the code needs to indicate that headline or body text has changed so that the screen may be redrawn properly.   The leoTree class defines the following simplified event handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders and subcommanders call these event handlers to indicate that a command has changed, or will change, the headline or body text.  Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that the outline pane is redrawn only when needed.
</t>
<t tx="rodrigob.121403173614.1021">box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = true # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height</t>
<t tx="rodrigob.121403173614.1022"></t>
<t tx="rodrigob.121403173614.1023">def __init__(self,commands,canvas):

    # Objects associated with this tree.
    self.colorizer = leoColor.colorizer(commands)
    self.commands = commands
    self.canvas = canvas
    self.rootVnode = None
    self.topVnode = None
    
    # Miscellaneous info.
    self.iconimages = {} # Image cache set by getIconImage().
    self.active = false # true if tree is active
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # Set self.font and self.fontName.
    self.setFontFromConfig()
    
    # Recycling bindings.
    self.bindings = [] # List of bindings to be unbound when redrawing.
    self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
    self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
    self.edit_text_dict = {} # New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
    self.widgets = [] # Widgets that must be destroyed when redrawing.

    # Controlling redraws
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.redrawCount = 0 # For traces
    self.redrawScheduled = false # true if redraw scheduled.

    # Selection ivars.
    self.currentVnode = None # The presently selected vnode.
    self.editVnode = None # The vnode being edited.
    self.initing = false # true: opening file.
    
    # Drag and drop
    self.drag_v = None
    self.dragging = false # true: presently dragging.
    self.controlDrag = false # true: control was down when drag started.
    self.drag_id = None # To reset bindings after drag
    self.keyCount = 0 # For debugging.
    
    # 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
    #                     behavior better on Linux
    # Context menu
    self.popupMenu = None
    
    # Incremental redraws:
    self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
    self.trace = false # true enabling of various traces.
    self.prevMoveToFrac = None
    self.visibleArea = None
    self.expandedVisibleArea = None
    
    self.allocatedNodes = 0 # A crucial statistic.
        # Incremental drawing allocates visible nodes at most twice.
        # Non-incremetal drawing allocates all visible nodes once.
        
    if self.allocateOnlyVisibleNodes:
        self.commands.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="rodrigob.121403173614.1024">def deleteBindings (self):
    
    """Delete all tree bindings and all references to tree widgets."""
    
    # print "deleteBindings: %d, %d" % (len(self.tagBindings),len(self.bindings))

    count = 0
    # Unbind all the tag bindings.
    for id,id2,binding in self.tagBindings:
        self.canvas.tag_unbind(id,binding,id2)
        count += 1
    self.tagBindings = []
    # Unbind all the text bindings.
    for t,id,binding in self.bindings:
        t.unbind(binding,id)
        count += 1
    self.bindings = []
    # print("bindings freed:"+`count`)</t>
<t tx="rodrigob.121403173614.1025"># canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
    
    """Delete all widgets in the canvas"""
    
    self.icon_id_dict = {} # Delete all references to icons.
    self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
        
    # Fixes a _huge_ memory leak.
    for w in self.widgets:
        w.destroy() 
    self.widgets = []</t>
<t tx="rodrigob.121403173614.1026"></t>
<t tx="rodrigob.121403173614.1027">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="rodrigob.121403173614.1028">def beginUpdate (self):

    self.updateCount += 1</t>
<t tx="rodrigob.121403173614.1029">def drawBox (self,v,x,y):
    
    y += 7 # draw the box at x, y+7

    iconname = choose(v.isExpanded(),"minusnode.gif", "plusnode.gif")
    image = self.getIconImage(iconname)
    id = self.canvas.create_image(x,y,image=image)

    id1 = self.canvas.tag_bind(id, "&lt;1&gt;", v.OnBoxClick)
    id2 = self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)
    
    # Remember the bindings so deleteBindings can delete them.
    self.tagBindings.append((id,id1,"&lt;1&gt;"),)
    self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
</t>
<t tx="rodrigob.121403173614.1030"># Draws icon for v at x,y

def drawIcon(self,v,x,y):

    v.iconx, v.icony = x,y
    y += 2 # draw icon at y + 2

    # Always recompute icon.
    val = v.iconVal = v.computeIcon()
    assert(0 &lt;= val &lt;= 15)
    
    # Compute the image name
    imagename = "box"
    if val &lt; 10: imagename += "0"
    imagename += `val`

    # Get the image
    image = self.getIconImage(imagename + ".GIF")
    id = self.canvas.create_image(x,y,anchor="nw",image=image)
    self.icon_id_dict[id] = v # Remember which vnode belongs to the icon.

    id1 = self.canvas.tag_bind(id,"&lt;1&gt;",v.OnIconClick)
    id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",v.OnIconDoubleClick)
    id3 = self.canvas.tag_bind(id,"&lt;3&gt;",v.OnIconRightClick)
    
    # Remember the bindings so deleteBindings can delete them.
    self.tagBindings.append((id,id1,"&lt;1&gt;"),)
    self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
    self.tagBindings.append((id,id3,"&lt;3&gt;"),)

    return 0 # dummy icon height</t>
<t tx="rodrigob.121403173614.1031"></t>
<t tx="rodrigob.121403173614.1032"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    # trace()
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = true
        self.canvas.after_idle(self.idle_redraw)
        
</t>
<t tx="rodrigob.121403173614.1033"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):

    # trace()

    if not self.redrawScheduled:
        self.redrawScheduled = true
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="rodrigob.121403173614.1034"># Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.
def redraw_now (self):

    # trace()

    self.idle_redraw()</t>
<t tx="rodrigob.121403173614.1035">def idle_redraw (self):
    
    self.redrawScheduled = false # 7/10/03: Always do this here.

    frame = self.commands.frame
    if frame not in app().windowList or app().quitting:
        # trace("no frame")
        return
        
    if self.drag_v:
        # trace("dragging",self.drag_v)
        return

    # trace()

    self.expandAllAncestors(self.currentVnode)
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"
    self.allocatedNodes = 0
    if not doHook("redraw-entire-outline",c=self.commands):
        # Erase and redraw the entire tree.
        self.topVnode = None
        self.deleteBindings()
        self.canvas.delete("all")
        self.deleteWidgets()
        self.setVisibleAreaToFullCanvas()
        self.drawTree(self.rootVnode,root_left,root_top,0,0)
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        self.canvas.after_idle(self.idle_scrollTo)
        if self.trace:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount, self.allocatedNodes
        doHook("after_redraw-outline",c=self.commands)

    self.canvas['cursor'] = oldcursor</t>
<t tx="rodrigob.121403173614.1036">def idle_second_redraw (self):
    
    # trace()
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    self.topVnode = None
    args = self.canvas.yview()
    self.setVisibleArea(args)
    self.deleteBindings()
    self.canvas.delete("all")
    self.drawTree(self.rootVnode,root_left,root_top,0,0)
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes</t>
<t tx="rodrigob.121403173614.1037">def drawNode(self,v,x,y):

    """Draw horizontal line from vertical line to icon"""

    self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")

    if self.inVisibleArea(y):
        return self.force_draw_node(v,x,y)
    else:
        return self.line_height
    
def force_draw_node(self,v,x,y):

    self.allocatedNodes += 1
    if v.firstChild():
        self.drawBox(v,x,y)
    icon_height = self.drawIcon(v,x+box_width,y)
    text_height = self.drawText(v,x+box_width+icon_width,y)
    return max(icon_height, text_height)</t>
<t tx="rodrigob.121403173614.1038"># draws text for v at x,y

def drawText(self,v,x,y):
    
    x += text_indent

    t = Tkinter.Text(self.canvas,
        font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)
    self.edit_text_dict[v] = t # Remember which text widget belongs to v.
    
    # Remember the widget so deleteBindings can delete it.
    self.widgets.append(t) # Fixes a _huge_ memory leak.

    t.insert("end", v.headString())
    &lt;&lt; configure the text depending on state &gt;&gt;

    id1 = t.bind("&lt;1&gt;", v.OnHeadlineClick)
    id2 = t.bind("&lt;3&gt;", v.OnHeadlineRightClick) # 9/11/02.
    if 0: # 6/15/02: Bill Drissel objects to this binding.
        t.bind("&lt;Double-1&gt;", v.OnBoxClick)
    id3 = t.bind("&lt;Key&gt;", v.OnHeadlineKey)
    id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
        # 10/16/02: Stamp out the erroneous control-t binding.
        
    # Remember the bindings so deleteBindings can delete them.
    self.bindings.append((t,id1,"&lt;1&gt;"),)
    self.bindings.append((t,id2,"&lt;3&gt;"),)
    self.bindings.append((t,id3,"&lt;Key&gt;"),)
    self.bindings.append((t,id4,"&lt;Control-t&gt;"),)

    id = self.canvas.create_window(x,y,anchor="nw",window=t)
    self.canvas.tag_lower(id)

    return self.line_height</t>
<t tx="rodrigob.121403173614.1039">if v == self.currentVnode:
    # trace("editVnode",self.editVnode)
    if v == self.editVnode:
        self.setNormalLabelState(v) # 7/7/03
    else:
        self.setDisabledLabelState(v) # selected, disabled
else:
    self.setUnselectedLabelState(v) # unselected</t>
<t tx="rodrigob.121403173614.1040">def drawTree(self,v,x,y,h,level):
    
    # Recursive routine, stat() not useful.
    yfirst = ylast = y
    if level==0: yfirst += 10
    while v:
        # trace(`x` + ", " + `y` + ", " + `v`)
        h = self.drawNode(v,x,y)
        y += h ; ylast = y
        if v.isExpanded() and v.firstChild():
            y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
        v = v.next()
    &lt;&lt; draw vertical line &gt;&gt;
    return y</t>
<t tx="rodrigob.121403173614.1041">id = self.canvas.create_line(
    x, yfirst-hline_y+4,
    x, ylast+hline_y-h,
    fill="gray50", # stipple="gray50"
    tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="rodrigob.121403173614.1042">def endUpdate (self, flag=true):

    assert(self.updateCount &gt; 0)
    self.updateCount -= 1
    if flag and self.updateCount == 0:
        self.redraw()</t>
<t tx="rodrigob.121403173614.1043">@ Returns the proper width of the entry widget for the headline. This has been a problem.
@c

def headWidth(self,v):

    return max(10,5 + len(v.headString()))</t>
<t tx="rodrigob.121403173614.1044">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return false
    else:
        return true # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return false</t>
<t tx="rodrigob.121403173614.1045"># Returns the last visible node of the screen.

def lastVisible (self):

    v = self.rootVnode
    while v:
        last = v
        if v.firstChild():
            if v.isExpanded():
                v = v.firstChild()
            else:
                v = v.nodeAfterTree()
        else:
            v = v.threadNext()
    return last</t>
<t tx="rodrigob.121403173614.1046">def setLineHeight (self,font):
    
    try:
        metrics = font.metrics()
        linespace = metrics ["linespace"]
        self.line_height = linespace + 5 # Same as before for the default font on Windows.
        # print metrics
    except:
        self.line_height = line_height # was 17 + 2
        es("exception setting outline line height")
        es_exception()</t>
<t tx="rodrigob.121403173614.1047">def getFont (self):

    return self.font
        
# Called by leoFontPanel.
def setFont (self, font=None, fontName=None):
    
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

    font = app().config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight")

    self.setFont(font)</t>
<t tx="rodrigob.121403173614.1048">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = os.path.join(app().loadDir,"..","Icons",name)
        fullname = os.path.normpath(fullname)
        image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
        self.iconimages[name] = image
        return image
    except:
        es("Exception loading: " + fullname)
        es_exception()
        return None</t>
<t tx="rodrigob.121403173614.1049">@ This scrolls the canvas so that v is in view.  This is done at idle time after a redraw so that treeBar.get() will return proper values.
@c

def idle_scrollTo(self,v=None):

    frame = self.commands.frame
    last = self.lastVisible()
    nextToLast = last.visBack()
    # print 'v,last',`v`,`last`
    if v == None:
        v = self.currentVnode
    h1 = self.yoffset(v)
    h2 = self.yoffset(last)
    if nextToLast: # 2/2/03: compute approximate line height.
        lineHeight = h2 - self.yoffset(nextToLast)
    else:
        lineHeight = 20 # A reasonable default.
    # Compute the fractions to scroll down/up.
    lo, hi = frame.treeBar.get()
    if h2 &gt; 0.1:
        frac = float(h1)/float(h2) # For scrolling down.
        frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
        frac2 = frac2 - (hi - lo)
    else:
        frac = frac2 = 0.0 # probably any value would work here.
    # 2/2/03: new logic for scrolling up.
    frac =  max(min(frac,1.0),0.0)
    frac2 = max(min(frac2,1.0),0.0)

    if frac &lt;= lo:
        if self.prevMoveToFrac != frac:
            self.prevMoveToFrac = frac
            self.canvas.yview("moveto",frac)
    elif frac2 + (hi - lo) &gt;= hi:
        if self.prevMoveToFrac != frac2:
            self.prevMoveToFrac = frac2
            self.canvas.yview("moveto",frac2)
            
    if self.allocateOnlyVisibleNodes:
        self.canvas.after_idle(self.idle_second_redraw)

    # print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)</t>
<t tx="rodrigob.121403173614.1050">def numberOfVisibleNodes(self):
    
    n = 0 ; v = self.rootVnode
    while v:
        n += 1
        v = v.visNext()
    return n</t>
<t tx="rodrigob.121403173614.1051">def recolor(self,v,incremental=0):

    body = self.commands.frame.body
    
    if 0: # Do immediately
        self.colorizer.colorize(v,body,incremental)
    else: # Do at idle time
        self.colorizer.schedule(v,body,incremental)

def recolor_now(self,v,incremental=0):

    body = self.commands.frame.body
    self.colorizer.colorize(v,body,incremental)
    
def recolor_range(self,v,leading,trailing):

    body = self.commands.frame.body
    self.colorizer.recolor_range(v,body,leading,trailing)</t>
<t tx="rodrigob.121403173614.1052">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

    # if not v1.isVisible(): print "yoffset not visible:", `v1`
    root = self.rootVnode
    h, flag = self.yoffsetTree(root,v1)
    # flag can be false during initialization.
    # if not flag: print "yoffset fails:", h, `v1`
    return h

# Returns the visible height of the tree and all sibling trees, stopping at v1

def yoffsetTree(self,v,v1):

    h = 0
    while v:
        # print "yoffsetTree:", `v`
        if v == v1:
            return h, true
        h += self.line_height
        child = v.firstChild()
        if v.isExpanded() and child:
            h2, flag = self.yoffsetTree(child,v1)
            h += h2
            if flag: return h, true
        v = v.next()
    return h, false</t>
<t tx="rodrigob.121403173614.1053">@ Important note: most hooks are created in the vnode callback routines, _not_ here.
</t>
<t tx="rodrigob.121403173614.1054">def OnActivate (self,v,event=None):

    try:
        c = self.commands
        &lt;&lt; activate this window &gt;&gt;
    except:
        es_event_exception("activate tree")</t>
<t tx="rodrigob.121403173614.1055">c = self.commands
# trace(`v`)

if v == self.currentVnode:
    if self.active:
        self.editLabel(v)
    else:
        self.undimEditLabel()
        set_focus(c,self.canvas) # Essential for proper editing.
else:
    self.select(v)
    if v.t.insertSpot != None: # 9/1/02
        c.body.mark_set("insert",v.t.insertSpot)
        c.body.see(v.t.insertSpot)
    else:
        c.body.mark_set("insert","1.0")
    set_focus(c,c.body)

self.active = true</t>
<t tx="rodrigob.121403173614.1056"># Called on click in box and double-click in headline.

def OnBoxClick (self,v):

    # Note: "boxclick" hooks handled by vnode callback routine.
    c = self.commands

    if v.isExpanded():
        v.contract()
    else:
        v.expand()

    self.active = true
    self.select(v)
    set_focus(c,c.body) # 7/12/03
    self.redraw()</t>
<t tx="rodrigob.121403173614.1057">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""

    c = self.commands
    focus = get_focus(c.frame.top)

    # Bug fix: 7/13/03: Only do this as needed.
    # Doing this on every click would interfere with the double-clicking.
    if focus not in (c.frame.body, c.frame.log):
        try:
            # trace(focus)
            self.endEditLabel()
            self.dimEditLabel()
        except:
            es_event_exception("deactivate tree")</t>
<t tx="rodrigob.121403173614.1058">def findVnodeWithIconId (self,id):
    
    # Due to an old bug, id may be a tuple.
    try:
        return self.icon_id_dict.get(id[0])
    except:
        return self.icon_id_dict.get(id)
</t>
<t tx="rodrigob.121403173614.1059">def OnContinueDrag(self,v,event):

    try:
        &lt;&lt; continue dragging &gt;&gt;
    except:
        es_event_exception("continue drag")</t>
<t tx="rodrigob.121403173614.1060"># trace(`v`)
assert(v == self.drag_v)

c = self.commands 
canvas = self.canvas
frame = self.commands.frame

if event:
    x,y = event.x,event.y
else:
    x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
    if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
    &lt;&lt; scroll the canvas as needed &gt;&gt;</t>
<t tx="rodrigob.121403173614.1061"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # es("lo,hi,frac:" + `lo` + " " + `hi` + " " + `frac`)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.OnContinueDrag,v,None) # Don't propagate the event.</t>
<t tx="rodrigob.121403173614.1062"># This works around an apparent Tk bug.

def OnControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="rodrigob.121403173614.1063"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,v,event):

    # Note: "drag" hooks handled by vnode callback routine.
    # trace(event)
    
    c = self.commands
    assert(v == self.drag_v)

    if not event:
        return

    if not self.dragging:
        # 11/25/02: Only do this once: greatly speeds drags.
        self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
        self.dragging = true
        self.controlDrag = c.frame.controlKeyIsDown
        # 1/29/03: support this new option.
        flag = app().config.getBoolWindowPref("look_for_control_drag_on_mouse_down")
        if flag:
            if self.controlDrag:
                es("dragged node will be cloned")
            else:
                es("dragged node will be moved")
        self.canvas['cursor'] = "hand2" # "center_ptr"

    self.OnContinueDrag(v,event)</t>
<t tx="rodrigob.121403173614.1064">def OnEndDrag(self,v,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    # trace(v)
    
    # 7/10/03: Make sure we are still dragging.
    if not self.drag_v:
        return

    assert(v == self.drag_v)
    c = self.commands ; canvas = self.canvas

    if event:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        # 1/29/03: support for this new option.
        flag = app().config.getBoolWindowPref("look_for_control_drag_on_mouse_down")
        if not flag:
            self.controlDrag = c.frame.controlKeyIsDown
        if vdrag and vdrag != v:
            if self.controlDrag: # Clone v and move the clone.
                if childFlag:
                    c.dragCloneToNthChildOf(v,vdrag,0)
                else:
                    c.dragCloneAfter(v,vdrag)
            else: # Just drag v.
                if childFlag:
                    c.dragToNthChildOf(v,vdrag,0)
                else:
                    c.dragAfter(v,vdrag)
        else:
            if v and self.dragging:
                pass # es("not dragged: " + v.headString())
            if 0: # Don't undo the scrolling we just did!
                self.idle_scrollTo(v)
    
    # 1216/02: Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"

    if self.drag_id:
        canvas.tag_unbind(self.drag_id , "&lt;B1-Motion&gt;")
        canvas.tag_unbind(self.drag_id , "&lt;Any-ButtonRelease-1&gt;")
        self.drag_id = None
        
    self.dragging = false
    self.drag_v = None</t>
<t tx="rodrigob.121403173614.1065">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="rodrigob.121403173614.1066">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others</t>
<t tx="rodrigob.121403173614.1067">def onHeadChanged (self,v):
    
    """Handle a change to headline text."""

    self.commands.body.after_idle(self.idle_head_key,v)


</t>
<t tx="rodrigob.121403173614.1068">def OnHeadlineKey (self,v,event):
    
    """Handle a key event in a headline."""

    ch = event.char
    self.commands.body.after_idle(self.idle_head_key,v,ch)

</t>
<t tx="rodrigob.121403173614.1069">def idle_head_key (self,v,ch=None):
    
    """Update headline text at idle time."""

    c = self.commands
    if not v or not v.edit_text() or v != c.currentVnode():
        return "break"
    if doHook("headkey1",c=c,v=v,ch=ch):
        return "break" # The hook claims to have handled the event.

    &lt;&lt; set s to the widget text &gt;&gt;
    &lt;&lt; set head to vnode text &gt;&gt;
    changed = s != head
    done = ch and (ch == '\r' or ch == '\n')
    if not changed and not done:
        return "break"
    if changed:
        c.undoer.setUndoParams("Change Headline",v,newText=s,oldText=head)
    index = v.edit_text().index("insert")
    if changed:
        &lt;&lt; update v and all nodes joined to v &gt;&gt;
    &lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;
    &lt;&lt; update the screen &gt;&gt;

    doHook("headkey2",c=c,v=v,ch=ch)
    return "break"</t>
<t tx="rodrigob.121403173614.1070">s = v.edit_text().get("1.0","end")
s = toUnicode(s,app().tkEncoding) # 2/25/03
if not s:
    s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# trace(`s`)
</t>
<t tx="rodrigob.121403173614.1071">head = v.headString()
if head == None:
    head = u""
head = toUnicode(head,"utf-8")
</t>
<t tx="rodrigob.121403173614.1072">c.beginUpdate()

# Update changed bit.
if not c.changed:
    c.setChanged(true)

# Update all dirty bits.
v.setDirty()

# Update v.
v.initHeadString(s)
v.edit_text().delete("1.0","end")
v.edit_text().insert("end",s)
v.edit_text().mark_set("insert",index)

# Update all joined nodes.
for v2 in v.t.joinList:
    if v2 != v:
        v2.initHeadString(s)
        if v2.edit_text(): # v2 may not be visible
            v2.edit_text().delete("1.0","end")
            v2.edit_text().insert("end",s)

c.endUpdate(false) # do not redraw now.</t>
<t tx="rodrigob.121403173614.1073"># Reconfigure v's headline.
if done:
    self.setDisabledLabelState(v)

v.edit_text().configure(width=self.headWidth(v))

# Reconfigure all joined headlines.
for v2 in v.t.joinList:
    if v2 != v:
        if v2.edit_text(): # v2 may not be visible
            v2.edit_text().configure(width=self.headWidth(v2))</t>
<t tx="rodrigob.121403173614.1074">if done:
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # update v immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(v,v.iconx,v.icony) # just redraw the icon.</t>
<t tx="rodrigob.121403173614.1075">def OnIconClick (self,v,event):

    # Note: "iconclick" hooks handled by vnode callback routine.

    canvas = self.canvas
    if event:
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        id = canvas.find_closest(canvas_x,canvas_y)
        if id != None:
            try: id = id[0]
            except: pass
            # trace("drag_v",v)
            self.drag_v = v
            self.drag_id = id
            id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", v.OnDrag)
            id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", v.OnEndDrag)
            
            # Remember the bindings so deleteBindings can delete them.
            self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
            self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)

    self.select(v)
    
def OnIconRightClick (self,v,event):

    self.select(v)</t>
<t tx="rodrigob.121403173614.1076">def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.commands
    s = v.headString().strip()
    if match_word(s,0,"@url"):
        if not doHook("@url1",c=c,v=v):
            url = s[4:].strip()
            &lt;&lt; stop the url after any whitespace &gt;&gt;
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        doHook("@url2",c=c,v=v)</t>
<t tx="rodrigob.121403173614.1077"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        es("ignoring characters after space in url:"+url[i:])
        es("use %20 instead of spaces")
    url = url[:i]
</t>
<t tx="rodrigob.121403173614.1078">if not url or len(url) == 0:
    es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    es("invalid url: "+url)
    return
</t>
<t tx="rodrigob.121403173614.1079">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file:///home/me/todolist.html
@c

try:
    import os
    import webbrowser
    os.chdir(app().loadDir)
    # print "url:",url
    webbrowser.open(url)
except:
    es("exception opening " + url)
    es_exception()</t>
<t tx="rodrigob.121403173614.1080">def OnPopup (self,v,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.commands
        if not doHook("create-popup-menu",c=c,v=v,event=event):
            self.createPopupMenu(v,event)
        if not doHook("enable-popup-menu-items",c=c,v=v,event=event):
            self.enablePopupMenuItems(v,event)
        if not doHook("show-popup-menu",c=c,v=v,event=event):
            self.showPopupMenu(v,event)

    return "break"</t>
<t tx="rodrigob.121403173614.1081">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    self.popupMenu.unpost()
    
</t>
<t tx="rodrigob.121403173614.1082">def createPopupMenu (self,v,event):
    
    a = app() ; c = self.commands ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tkinter.Menu(app().root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if a.openWithTable:
        frame.createMenuEntries(menu,a.openWithTable,openWith=1)
        table = (("-",None,None),)
        frame.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    frame.createMenuEntries(menu,table)</t>
<t tx="rodrigob.121403173614.1083">table = (
    ("&amp;Read @file Nodes",None,frame.OnReadAtFileNodes),
    ("&amp;Write @file Nodes",None,frame.OnWriteAtFileNodes),
    ("-",None,None),
    ("&amp;Tangle","Shift+Ctrl+T",frame.OnTangle),
    ("&amp;Untangle","Shift+Ctrl+U",frame.OnUntangle),
    ("-",None,None),
    ("Toggle Angle &amp;Brackets","Ctrl+B",frame.OnToggleAngleBrackets),
    ("-",None,None),
    ("Cut Node","Shift+Ctrl+X",frame.OnCutNode),
    ("Copy Node","Shift+Ctrl+C",frame.OnCopyNode),
    ("&amp;Paste Node","Shift+Ctrl+V",frame.OnPasteNode),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",frame.OnDeleteNode),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",frame.OnInsertNode),
    ("&amp;Clone Node","Ctrl+`",frame.OnCloneNode),
    ("Sort C&amp;hildren",None,frame.OnSortChildren),
    ("&amp;Sort Siblings","Alt-A",frame.OnSortSiblings),
    ("-",None,None),
    ("Contract Parent","Alt+0",frame.OnContractParent))</t>
<t tx="rodrigob.121403173614.1084">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    c = self.commands ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = choose(isAtFile,1,0)
    isAtRoot = choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = choose(canContract,1,0)
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enableMenu(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enableMenu(menu,name,isAtRoot)
    
    enableMenu(menu,"Cut Node",c.canCutOutline())
    enableMenu(menu,"Delete Node",c.canDeleteHeadline())
    enableMenu(menu,"Paste Node",c.canPasteOutline())
    enableMenu(menu,"Sort Children",c.canSortChildren())
    enableMenu(menu,"Sort Siblings",c.canSortSiblings())
    enableMenu(menu,"Contract Parent",c.canContractParent())</t>
<t tx="rodrigob.121403173614.1085">isAtFile = false ; isAtRoot = false
v2 = v ; next = v.nodeAfterTree()

while (not isAtFile or not isAtRoot) and v2 != None and v2 != next:
    if (
        v2.isAtFileNode() or
        v.isAtRawFileNode() or
        v.isAtSilentFileNode() or
        v.isAtNoSentinelsFileNode()):
        isAtFile = true

    isRoot, junk = is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = true
    v2 = v2.threadNext()</t>
<t tx="rodrigob.121403173614.1086">def showPopupMenu (self,v,event):
    
    """Show a popup menu."""
    
    c = self.commands ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Make certain we have focus so we know when we lose it.
    # I think this is OK for all OSes.
    set_focus(c,menu)</t>
<t tx="rodrigob.121403173614.1087"></t>
<t tx="rodrigob.121403173614.1088">def allocateNodes(self,where,lines):
    
    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
    
    assert(where in ("above","below"))

    # print "allocateNodes: %d lines %s visible area" % (lines,where)
    
    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # print "expandedArea:   %5.1f %5.1f" % (y1,y2)
    
    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.rootVnode,root_left,root_top,0,0)
    # if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
</t>
<t tx="rodrigob.121403173614.1089">def allocateNodesBeforeScrolling (self, args):
    
    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # print "allocateNodesBeforeScrolling:",self.redrawCount,`args`

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = choose(n&lt;frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = choose(n == 1,"below","above")
        lines = choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)</t>
<t tx="rodrigob.121403173614.1090">def updateNode (self,v,x,y):
    
    """Draw a node that may have become visible as a result of a scrolling operation"""

    if self.inExpandedVisibleArea(y):
        # This check is a major optimization.
        if not v.edit_text():
            return self.force_draw_node(v,x,y)
        else:
            return self.line_height

    return self.line_height</t>
<t tx="rodrigob.121403173614.1091">def setVisibleAreaToFullCanvas(self):
    
    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2</t>
<t tx="rodrigob.121403173614.1092">def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # print "scroll ratios:",r1,r2

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return
        
    scroll_h = y2-y1
    # print "height of scrollregion:", scroll_h

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
</t>
<t tx="rodrigob.121403173614.1093">def updateTree (self,v,x,y,h,level):

    yfirst = ylast = y
    if level==0: yfirst += 10
    while v:
        # trace(`x` + ", " + `y` + ", " + `v`)
        h = self.updateNode(v,x,y)
        y += h ; ylast = y
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
        v = v.next()
    return y
</t>
<t tx="rodrigob.121403173614.1094"></t>
<t tx="rodrigob.121403173614.1095">def abortEditLabelCommand (self):
    
    v = self.currentVnode
    # trace(v)
    if self.revertHeadline and v.edit_text() and v == self.editVnode:
        
        # trace(`self.revertHeadline`)
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        self.idle_head_key(v) # Must be done immediately.
        self.revertHeadline = None
        self.select(v)
        if v and len(v.t.joinList) &gt; 0:
            # 3/26/03: changed redraw_now to force_redraw.
            self.force_redraw() # force a redraw of joined headlines.</t>
<t tx="rodrigob.121403173614.1096"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    v = self.currentVnode
    self.setDisabledLabelState(v)

def undimEditLabel (self):

    v = self.currentVnode
    self.setSelectedLabelState(v)</t>
<t tx="rodrigob.121403173614.1097"># Start editing v.edit_text()

def editLabel (self, v):

    # End any previous editing
    if self.editVnode and v != self.editVnode:
        self.endEditLabel()
        self.revertHeadline = None
        
    self.editVnode = v # 7/7/03.

    # Start editing
    if v and v.edit_text():
        # trace(`v`)
        self.setNormalLabelState(v)
        self.revertHeadline = v.headString()</t>
<t tx="rodrigob.121403173614.1098"># End editing for self.editText

def endEditLabel (self):

    c = self.commands ; v = self.editVnode
    # trace(v)
    if v and v.edit_text():
        self.setUnselectedLabelState(v)
        self.editVnode = None
    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        # 3/26/03: changed redraw_now to force_redraw.
        self.force_redraw() # force a redraw of joined and ancestor headlines.
    set_focus(c,c.body) # 10/14/02
        
def endEditLabelCommand (self):

    c = self.commands ; v = self.editVnode
    # trace(v)
    if v and v.edit_text():
        self.select(v)
    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        # 3/26/03: changed redraw_now to force_redraw.
        self.force_redraw() # force a redraw of joined headlines.
    set_focus(c,c.body) # 10/14/02</t>
<t tx="rodrigob.121403173614.1099">def expandAllAncestors (self,v):

    redraw_flag = false
    p = v.parent()
    while p:
        if not p.isExpanded():
            p.expand()
            redraw_flag = true
        p = p.parent()
    return redraw_flag</t>
<t tx="rodrigob.121403173614.1100"># Similar to code in scanAllDirectives.

def scanForTabWidth (self, v):
    
    c = self.commands ; w = c.tab_width

    while v:
        s = v.t.bodyString
        dict = get_directives_dict(s)
        &lt;&lt; set w and break on @tabwidth &gt;&gt;
        v = v.parent()

    c.frame.setTabWidth(w)</t>
<t tx="rodrigob.121403173614.1101">if dict.has_key("tabwidth"):
    
    val = scanAtTabwidthDirective(s,dict,issue_error_flag=false)
    if val and val != 0:
        w = val
        break</t>
<t tx="rodrigob.121403173614.1102"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,v,updateBeadList=true):
    
    # trace(v)

    &lt;&lt; define vars and stop editing &gt;&gt;

    if not doHook("unselect1",c=c,new_v=v,old_v=old_v):
        &lt;&lt; unselect the old node &gt;&gt;
    else: old_body = u""

    doHook("unselect2",c=c,new_v=v,old_v=old_v)
    
    if not doHook("select1",c=c,new_v=v,old_v=old_v):
        &lt;&lt; select the new node &gt;&gt;
        if v and v != old_v: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(v)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node and redraw &gt;&gt;
    doHook("select2",c=c,new_v=v,old_v=old_v)
    doHook("select3",c=c,new_v=v,old_v=old_v)
</t>
<t tx="rodrigob.121403173614.1103">c = self.commands ; frame = c.frame ; body = frame.body
old_v = c.currentVnode()

# Unselect any previous selected but unedited label.
self.endEditLabel()
old = self.currentVnode
self.setUnselectedLabelState(old)</t>
<t tx="rodrigob.121403173614.1104"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.body.index("insert")

# Remember the old body text
old_body = body.get("1.0","end")

if old and old != v and old.edit_text():
    old.t.scrollBarSpot = yview
    old.t.insertSpot = insertSpot
</t>
<t tx="rodrigob.121403173614.1105">self.commands.frame.setWrap(v)

# Delete only if necessary: this may reduce flicker slightly.
s = v.t.bodyString
s = toUnicode(s,"utf-8")
old_body = toUnicode(old_body,"utf-8")
if old_body != s:
    body.delete("1.0","end")
    body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.recolor_now(v)

if v and v.t.scrollBarSpot != None:
    first,last = v.t.scrollBarSpot
    body.yview("moveto",first)

if v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.body.mark_set("insert",v.t.insertSpot)
    c.body.see(v.t.insertSpot)
else:
    c.body.mark_set("insert","1.0")</t>
<t tx="rodrigob.121403173614.1106">self.currentVnode = v
self.setSelectedLabelState(v)
self.scanForTabWidth(v) # 9/13/02 #GS I believe this should also get into the select1 hook
set_focus(c,c.body)
</t>
<t tx="rodrigob.121403173614.1107">if updateBeadList:
    if c.beadPointer &gt; -1:
        present_v = c.beadList[c.beadPointer]
    else:
        present_v = None
    
    if v != present_v:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(v)
</t>
<t tx="rodrigob.121403173614.1108"># Make v the most recently visited node on the list.
if v in c.visitedList:
    c.visitedList.remove(v)
    
c.visitedList.insert(0,v)</t>
<t tx="rodrigob.121403173614.1109">def setNormalLabelState (self,v): # selected, editing
    if v and v.edit_text():
        # trace(v)
        &lt;&lt; set editing headline colors &gt;&gt;
        v.edit_text().tag_remove("sel","1.0","end")
        v.edit_text().tag_add("sel","1.0","end")
        set_focus(self.commands,v.edit_text())

def setDisabledLabelState (self,v): # selected, disabled
    if v and v.edit_text():
        # trace(v)
        &lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,v): # selected, not editing
    self.setDisabledLabelState(v)

def setUnselectedLabelState (self,v): # not selected.
    if v and v.edit_text():
        # trace(v)
        &lt;&lt; set unselected headline colors &gt;&gt;</t>
<t tx="rodrigob.121403173614.1110">config = app().config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
    fg,bg = "black","white"
    
try:
    if selfg and selbg:
        v.edit_text().configure(
            selectforeground=selfg,selectbackground=selbg,
            state="normal",highlightthickness=1,fg=fg,bg=bg)
    else:
        v.edit_text().configure(
            state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
    es_exception()</t>
<t tx="rodrigob.121403173614.1111">config = app().config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
    fg,bg = "black","gray80"

try:
    v.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    es_exception()</t>
<t tx="rodrigob.121403173614.1112">config = app().config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    v.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    es_exception()</t>
<t tx="rodrigob.121403173614.1113">def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
    c = self.commands ; body = c.frame.body
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if upOrDown == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2:
        x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    # trace("entry:  %s.%s" % (lines,char))
    # trace("result:",result)
    # trace("insert:",body.index("insert"))
    return "break" # Inhibit further bindings.</t>
<t tx="rodrigob.121403173614.1114">@language python

# Undo manager for leo.py.

&lt;&lt; How Leo implements unlimited undo &gt;&gt;
&lt;&lt; Define optional ivars &gt;&gt;
from leoGlobals import *
import types

class baseUndoer:
    """The base class of the undoer class."""
    @others
    
class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass</t>
<t tx="rodrigob.121403173614.1115">@ Only leo.py supports unlimited undo.  Unlimited undo is straightforward; it merely requires that all commands that affect the outline or body text must be undoable. In other words, everything that affects the outline or body text must be remembered.

We may think of all the actions that may be Undone or Redone as a string of beads (undo nodes). Undoing an operation moves backwards to the next bead; redoing an operation moves forwards to the next bead. A bead pointer points to the present bead. The bead pointer points in front of the first bead when Undo is disabled.  The bead pointer points at the last bead when Redo is disabled. An undo node is a Python dictionary containing all information needed to undo or redo the operation.

The Undo command uses the present bead to undo the action, then moves the bead pointer backwards. The Redo command uses the bead after the present bead to redo the action, then moves the bead pointer forwards. All undoable operations call setUndoParams() to create a new bead. The list of beads does not branch; all undoable operations (except the Undo and Redo commands themselves) delete any beads following the newly created bead.

I did not invent this model of unlimited undo.  I first came across it in the documentation for Apple's Yellow Box classes.
</t>
<t tx="rodrigob.121403173614.1116">optionalIvars = (
    "lastChild",
    "parent","oldParent",
    "back","oldBack",
    "n","oldN","oldV",
    "oldText","newText",
    "oldSel","newSel",
    "sort","select",
    "oldTree",
    "yview",
    # For incremental undo typing...
    "leading","trailing",
    "oldMiddleLines","newMiddleLines",
    "oldNewlines","newNewlines")</t>
<t tx="rodrigob.121403173614.1117">def __init__ (self,commands):
    
    u = self ; u.commands = commands
    
    # Ivars to transition to new undo scheme...
    
    u.debug = false # true: enable debugging code in new undo scheme.
    u.debug_print = false # true: enable print statements in debug code.
    u.new_undo = true # true: enable new debug code.
    
    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0
    
    # State ivars...
    u.undoType = "Can't Undo"
    # Bug fix: 12/16/02: These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = false # True if executing an Undo command.
    u.redoing = false # True if executing a Redo command.

    u.clearUndoState()</t>
<t tx="rodrigob.121403173614.1118">def clearIvars (self):
    
    self.v = None # The node being operated upon for undo and redo.
    for ivar in optionalIvars:
        setattr(self,ivar,None)</t>
<t tx="rodrigob.121403173614.1119"></t>
<t tx="rodrigob.121403173614.1120">@ This method clears then entire Undo state.  All non-undoable commands should call this method.
@c

def clearUndoState (self):
    
    u = self
    
    if 0: # Bug fix: 12/16/02: setUndo/Redo type needs the old values.
        u.redoMenuLabel = "Can't Redo" 
        u.undoMenuLabel = "Can't Undo"
    
    if 0: # Wrong: set realLabel only when calling setMenuLabel.
        realLabel = app().getRealMenuName("Can't Redo")
        u.realRedoMenuLabel = realLabel.replace("&amp;","")
        realLabel = app().getRealMenuName("Can't Undo")
        u.realUndoMenuLabel = realLabel.replace("&amp;","")
        
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()</t>
<t tx="rodrigob.121403173614.1121"># Translation does not affect these routines.

def canRedo (self):

    u = self
    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self
    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="rodrigob.121403173614.1122">def enableMenuItems (self):

    u = self ; c = u.commands
    menu = c.frame.getMenu("Edit")

    enableMenu(menu,u.redoMenuLabel,u.canRedo())
    enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="rodrigob.121403173614.1123">def getBead (self,n):
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads): return false
    d = u.beads[n]
    # trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
    self.clearIvars()
    u.v = d["v"]
    u.undoType = d["undoType"]

    for ivar in optionalIvars:
        val = d.get(ivar,None)
        setattr(u,ivar,val)

    if not u.new_undo: # Recreate an "oldText" entry if necessary.
        if u.undoType == "Typing" and u.oldText == None:
            assert(n &gt; 0)
            old_d = u.beads[n-1]
            # The user will lose data if these asserts fail.
            assert(old_d["undoType"] == "Typing")
            assert(old_d["v"] == u.v)
            u.oldText = old_d["newText"]
            # trace(`u.oldText`)
    return d
    
def peekBead (self,n):
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads): return false
    d = u.beads[n]
    # trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
    return d

def setBead (self,n,keywords=None):

    u = self ; d = {}
    d["undoType"]=u.undoType
    d["v"]=u.v
    # Only enter significant entries into the dictionary.
    # This is an important space optimization for typing.
    for ivar in optionalIvars:
        if getattr(u,ivar) != None:
            d[ivar] = getattr(u,ivar)
    # copy all significant keywords to d.
    if keywords:
        for key in keywords.keys():
            if keywords[key] != None:
                d[key] = keywords[key]
    # Clear the "oldText" entry if the previous entry was a "Typing" entry.
    # This optimization halves the space needed for Undo/Redo Typing.
    if not u.new_undo:
        if u.undoType == "Typing" and n &gt; 0:
            old_d = u.beads[n-1]
            if old_d["undoType"] == "Typing" and old_d["v"] == u.v:
                del d["oldText"] # We can recreate this entry from old_d["newText"]
                # trace(`u.oldText`)
    # trace(`d`)
    return d</t>
<t tx="rodrigob.121403173614.1124">def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name</t>
<t tx="rodrigob.121403173614.1125"># These routines update both the ivar and the menu label.
def setRedoType (self,type):
    u = self ; c = u.commands
    menu = c.frame.getMenu("Edit")
    name = u.redoMenuName(type)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = app().getRealMenuName(name)
        if realLabel == name:
            underline=choose(match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,type):
    u = self ; c = u.commands
    menu = c.frame.getMenu("Edit")
    name = u.undoMenuName(type)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = app().getRealMenuName(name)
        if realLabel == name:
            underline=choose(match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = type
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel</t>
<t tx="rodrigob.121403173614.1126">@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,v,**keywords):

    u = self
    if u.redoing or u.undoing: return None
    if undo_type == None:
        return None
    if undo_type == "Can't Undo":
        u.clearUndoState()
        return None
    # trace(undo_type,v)
    # Set the type: set the menu labels later.
    u.undoType = undo_type
    # Calculate the standard derived information.
    u.v = v
    u.parent = v.parent()
    u.back = v.back()
    u.n = v.childIndex()
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    d = u.setBead(u.bead,keywords)
    u.beads[u.bead:] = [d]
    # trace(`u.bead` + ":" + `len(u.beads)` + ":" + `keywords`)
    # Recalculate the menu labels.
    u.setUndoTypes()
    return d</t>
<t tx="rodrigob.121403173614.1127">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,v,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    u = self ; c = u.commands
    if u.redoing or u.undoing: return None
    if undo_type == None:
        return None
    if undo_type == "Can't Undo":
        u.clearUndoState()
        return None
    if oldText == newText:
        # trace("no change")
        return None
    # Clear all optional params.
    for ivar in optionalIvars:
        setattr(u,ivar,None)
    # Set the params.
    u.undoType = undo_type
    u.v = v
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    u.oldSel = oldSel ; u.newSel = newSel
    # 11/13/02: Remember the scrolling position.
    if oldYview:
        u.yview = oldYview
    else:
        u.yview = c.frame.body.yview()
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    d = u.setBead(u.bead)
    u.beads[u.bead:] = [d]
    # trace(`u.bead` + ":" + `len(u.beads)`)
    u.setUndoTypes() # Recalculate the menu labels.
    return d
</t>
<t tx="rodrigob.121403173614.1128">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]
    
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    trace()
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"</t>
<t tx="rodrigob.121403173614.1129">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
    if u.debug:
        # Remember the complete text for comparisons...
        u.oldText = oldText
        u.newText = newText
        # Compute statistics comparing old and new ways...
        # The old doesn't often store the old text, so don't count it here.
        u.old_mem += len(newText)
        s1 = string.join(old_middle_lines,'\n')
        s2 = string.join(new_middle_lines,'\n')
        u.new_mem += len(s1) + len(s2)
    else:
        u.oldText = None
        u.newText = None
else:
    u.oldText = oldText
    u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines</t>
<t tx="rodrigob.121403173614.1130">def setUndoTypes (self):
    
    u = self
    # trace(`u.bead` + ":" + `len(u.beads)`)

    # Set the undo type and undo menu label.
    d = u.peekBead(u.bead)
    if d:
        u.setUndoType(d["undoType"])
    else:
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    d = u.peekBead(u.bead+1)
    if d:
        u.setRedoType(d["undoType"])
    else:
        u.setRedoType("Can't Redo")



</t>
<t tx="rodrigob.121403173614.1131">def redo (self):
    
    # clear_stats() ; stat()
    u = self ; c = u.commands
    if not u.canRedo(): return
    if not u.getBead(u.bead+1): return
    current = c.currentVnode()
    if not current: return
    # trace(`u.bead+1` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead+1)`)
    u.redoing = true
    redrawFlag = true
    c.beginUpdate()
    redoType = u.undoType # Use the type of the next bead.
    if 1: # range...
        &lt;&lt; redo clone cases &gt;&gt;
        &lt;&lt; redo insert cases &gt;&gt;
        &lt;&lt; redo delete cases &gt;&gt;
        &lt;&lt; redo move &amp; drag cases &gt;&gt;
        &lt;&lt; redo promote and demote cases &gt;&gt;
        &lt;&lt; redo replace cases &gt;&gt;
        &lt;&lt; redo sort cases &gt;&gt;
        &lt;&lt; redo typing cases &gt;&gt;
        else: trace("Unknown case: " + `redoType`)
        c.setChanged(true)
        if u.v: u.v.setDirty()
    c.endUpdate(redrawFlag) # 11/08/02
    u.redoing = false
    u.bead += 1
    u.setUndoTypes()
    # print_stats()</t>
<t tx="rodrigob.121403173614.1132">if redoType in ("Clone","Drag &amp; Clone"):

    if u.back:
        u.v.linkAfter(u.back)
    elif u.parent:
        u.v.linkAsNthChild(u.parent,0)
    else:
        u.v.linkAsRoot()

    shared = u.findSharedVnode(u.v)
    if shared: u.v.joinTreeTo(shared)
    u.v.createDependents()
    c.initAllCloneBits()
    c.selectVnode(u.v)
</t>
<t tx="rodrigob.121403173614.1133">elif redoType == "Delete Outline" or redoType == "Cut Node":

    c.selectVnode(u.v)
    c.deleteHeadline()</t>
<t tx="rodrigob.121403173614.1134">elif redoType in ["Import", "Insert Outline", "Paste Node"]:

    if u.back:
        u.v.linkAfter(u.back)
    elif u.parent:
        u.v.linkAsNthChild(u.parent,0)
    else:
        u.v.linkAsRoot()

    shared = u.findSharedVnode(u.v)
    if shared: u.v.joinTreeTo(shared)
    u.v.createDependents()
    c.initAllCloneBits()
    c.selectVnode(u.v)</t>
<t tx="rodrigob.121403173614.1135">elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

    if u.parent:
        u.v.moveToNthChildOf(u.parent,u.n)
    elif u.back:
        u.v.moveAfter(u.back)
    else:
        # 3/16/02: Moving up is the only case that can do this.
        parent = u.v.parent()
        u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
        if parent: # We could assert(parent)
            parent.moveAfter(u.v)
    c.initJoinedCloneBits(u.v) # 7/6/02
    c.selectVnode(u.v)
    
elif redoType == "Drag":

    u.v.moveToNthChildOf(u.parent,u.n)
    c.initJoinedCloneBits(u.v) # 7/6/02
    c.selectVnode(u.v)</t>
<t tx="rodrigob.121403173614.1136">elif redoType == "Demote":

    c.selectVnode(u.v)
    c.demote()
    
elif redoType == "Promote":

    c.selectVnode(u.v)
    c.promote()</t>
<t tx="rodrigob.121403173614.1137">elif redoType in (
    "Convert All Blanks","Convert All Tabs",
    "Extract","Extract Names","Extract Section"):
    
    u.v = self.undoReplace(u.oldTree,u.v,u.newText)
    c.selectVnode(u.v) # Does full recolor.
    if u.newSel:
        start,end=u.newSel
        setTextSelection(c.frame.body,start,end)
    redrawFlag = redoType in ("Extract","Extract Names","Extract Section")
</t>
<t tx="rodrigob.121403173614.1138">elif redoType == "Sort Children":

    c.selectVnode(u.v)
    c.sortChildren()

elif redoType == "Sort Siblings":

    c.selectVnode(u.v)
    c.sortSiblings()
    
elif redoType == "Sort Top Level":
    
    c.selectVnode(u.v)
    c.sortTopLevel()
    u.v = None # don't mark u.v dirty
</t>
<t tx="rodrigob.121403173614.1139">elif redoType in ( "Typing",
    "Change","Convert Blanks","Convert Tabs","Cut",
    "Delete","Indent","Paste","Reformat Paragraph","Undent"):

    # trace(`redoType` + ":" + `u.v`)
    # selectVnode causes recoloring, so avoid if possible.
    if current != u.v:
        c.selectVnode(u.v) ## Optimize this away??
    self.undoRedoText(
        u.v,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo")
    
    if u.newSel:
        start,end=u.newSel
        setTextSelection (c.frame.body,start,end)
    if u.yview:
        first,last=u.yview
        c.body.yview("moveto",first)
    redrawFlag = (current != u.v)
        
elif redoType == "Change All":

    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        redoType = u.undoType
        # trace(`redoType`)
        if redoType == "Change All":
            c.selectVnode(u.v)
            break
        elif redoType == "Change":
            u.v.t.setTnodeText(u.newText)
            u.v.setDirty()
        elif redoType == "Change Headline":
            u.v.initHeadString(u.newText)
        else: assert(false)

elif redoType == "Change Headline":
    
    # trace(`u.newText`)
    u.v.setHeadStringOrHeadline(u.newText)
    # Update all joined headlines.
    for v2 in u.v.t.joinList:
        if v2 != u.v:
            v2.setHeadString(u.newText)
    c.selectVnode(u.v)</t>
<t tx="rodrigob.121403173614.1140">@ This function and its allies undo the operation described by the undo parmaters.
@c

def undo (self):
    
    # clear_stats() ; # stat()
    u = self ; c = u.commands
    if not u.canUndo(): return
    if not u.getBead(u.bead): return
    current = c.currentVnode()
    if not current: return
    # trace(`u.bead` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead)`)
    c.endEditing()# Make sure we capture the headline for a redo.
    u.undoing = true
    c.beginUpdate()
    undoType = u.undoType
    redrawFlag = true
    if 1: # range...
        &lt;&lt; undo clone cases &gt;&gt;
        &lt;&lt; undo delete cases &gt;&gt;
        &lt;&lt; undo insert cases &gt;&gt;
        &lt;&lt; undo move &amp; drag cases &gt;&gt;
        &lt;&lt; undo promote and demote cases &gt;&gt;
        &lt;&lt; undo replace cases &gt;&gt;
        &lt;&lt; undo sort cases &gt;&gt;
        &lt;&lt; undo typing cases &gt;&gt;
        else: trace("Unknown case: " + `u.undoType`)
        c.setChanged(true)
        if u.v: u.v.setDirty()
    c.endUpdate(redrawFlag) # 11/9/02
    u.undoing = false
    u.bead -= 1
    u.setUndoTypes()
    # print_stats()</t>
<t tx="rodrigob.121403173614.1141"># We can immediately delete the clone because clone() can recreate it using only v.

if undoType == "Clone":
    
    c.selectVnode(u.v)
    c.deleteHeadline()
    c.selectVnode(u.back)
    
elif undoType == "Drag &amp; Clone":
    
    c.selectVnode(u.v)
    c.deleteHeadline()
    c.selectVnode(u.oldV)</t>
<t tx="rodrigob.121403173614.1142">@ Deleting a clone is _not_ the same as undoing a clone: the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Outline" or undoType == "Cut Node":
    
    if u.back:
        u.v.linkAfter(u.back)
    elif u.parent:
        u.v.linkAsNthChild(u.parent,0)
    else:
        u.v.linkAsRoot()
    shared = u.findSharedVnode(u.v)
    if shared: u.v.joinTreeTo(shared)
    u.v.createDependents()
    c.initAllCloneBits()
    c.selectVnode(u.v)</t>
<t tx="rodrigob.121403173614.1143">elif undoType in ["Import", "Insert Outline", "Paste Node"]:
    
    c.selectVnode(u.v)
    c.deleteHeadline()
    if u.select:
        # trace("Insert/Paste:" + `u.select`)
        c.selectVnode(u.select)</t>
<t tx="rodrigob.121403173614.1144">elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

    if u.oldParent:
        u.v.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.v.moveAfter(u.oldBack)
    else:
        # 3/16/02: Moving up is the only case that can do this.
        parent = u.v.parent()
        u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
        if parent: # We could assert(parent)
            parent.moveAfter(u.v)
    
    c.initJoinedCloneBits(u.v) # 7/6/02
    c.selectVnode(u.v)
</t>
<t tx="rodrigob.121403173614.1145">elif undoType in (
    "Convert All Blanks","Convert All Tabs",
    "Extract","Extract Names","Extract Section"):
        
    u.v = self.undoReplace(u.v,u.oldTree,u.oldText)
    c.selectVnode(u.v) # Does full recolor.
    if u.oldSel:
        start,end=u.oldSel
        setTextSelection(c.frame.body,start,end)
    redrawFlag = true</t>
<t tx="rodrigob.121403173614.1146">@ Promote and demote operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Demote":

    u.undoDemote()

elif undoType == "Promote":
    
    u.undoPromote()</t>
<t tx="rodrigob.121403173614.1147">@ Sort operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Sort Children":
    
    u.undoSortChildren()

elif undoType == "Sort Siblings":
    
    u.undoSortSiblings()
    
elif undoType == "Sort Top Level":
    
    u.undoSortTopLevel()
    u.v = None # don't mark u.v dirty</t>
<t tx="rodrigob.121403173614.1148">@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
    
elif undoType in ( "Typing",
    "Change","Convert Blanks","Convert Tabs","Cut",
    "Delete","Indent","Paste","Reformat Paragraph","Undent"):

    # trace(`undoType` + ":" + `u.v`)
    # selectVnode causes recoloring, so don't do this unless needed.
    if current != u.v:
        c.selectVnode(u.v) ## Optimize this away??
    self.undoRedoText(
        u.v,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo")
    if u.oldSel:
        start,end=u.oldSel
        setTextSelection (c.frame.body,start,end)
    if u.yview:
        first,last=u.yview
        c.body.yview("moveto",first)
    redrawFlag = (current != u.v)
        
elif undoType == "Change All":

    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        undoType = u.undoType
        # trace(`undoType`)
        if undoType == "Change All":
            c.selectVnode(u.v)
            break
        elif undoType == "Change":
            u.v.t.setTnodeText(u.oldText)
            u.v.setDirty()
        elif undoType == "Change Headline":
            u.v.initHeadString(u.oldText)
        else: assert(false)
        
elif undoType == "Change Headline":
    
    # trace(`u.oldText`)
    u.v.setHeadStringOrHeadline(u.oldText)
    # 9/24/02: update all joined headlines.
    for v2 in u.v.t.joinList:
        if v2 != u.v:
            v2.setHeadString(u.oldText)
    c.selectVnode(u.v)</t>
<t tx="rodrigob.121403173614.1149"></t>
<t tx="rodrigob.121403173614.1150">def findSharedVnode (self,target):

    u = self ; c = u.commands ; v = c.rootVnode()
    while v:
        if v != target and v.t == target.t:
            return v
        v = v.threadNext()
    return None</t>
<t tx="rodrigob.121403173614.1151"># undoes the previous demote operation.
def undoDemote (self):

    u = self ; c = u.commands
    ins = v = u.v
    last = u.lastChild
    child = v.firstChild()
    assert(child)
    c.beginUpdate()
    # 3/19/03: do not undemote children up to last.
    if last:
        while child and child != last:
            child = child.next()
        if child:
            child = child.next()
    while child:
        next = child.next()
        child.moveAfter(ins)
        ins = child
        child = next
    c.selectVnode(v)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.1152"># Undoes the previous promote operation.
def undoPromote (self):

    u = self ; c = u.commands
    v = v1 = u.v
    assert(v1)
    last = u.lastChild
    next = v.next()
    assert(next)
    c.beginUpdate()
    while next:
        v = next
        next = v.next()
        n = v1.numberOfChildren()
        v.moveToNthChildOf(v1,n)
        if v == last: break
    c.selectVnode(v1)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.1153">@ This routine implements undo for any kind of operation, no matter how complex.  Just do:

    v_copy = v.copyTree(v)
    (make arbitrary changes to v's tree.)
    c.undoer.setUndoParams("Op Name",v,select=current,oldTree=v_copy)
@c

def undoReplace (self,new_v,old_v,text):
    
    """Replace new_v with old_v during undo."""

    # trace("new_v:%s" % new_v)
    # trace("old_v:%s" % old_v)
    # trace("text:",text)
    assert(new_v and old_v)
    assert(text is not None)
    u = self ; c = u.commands
    joinList = new_v.t.joinList[:]
    if 0:
        trace("joinList")
        for j in joinList:
            print '\t',j
    assert(new_v in joinList)
    result = None
    for v in joinList:
        if v == new_v: result = copy = old_v
        else: copy = old_v.copyTree()
        # Remember how to link the new node.
        parent = v.parent()
        prev = v.back()
        next = v.next()
        n = v.childIndex()
        # Unlink the old tree.
        v.unjoinTree()
        v.unlink()
        # Link in the new tree.
        if parent: copy.linkAsNthChild(parent,n)
        elif prev: copy.linkAfter(prev)
        else:      copy.linkAsRoot(oldRoot=next)
        copy.addTreeToJoinLists()
        assert(copy in copy.t.joinList)

    assert(result == old_v)
    result.t.setTnodeText(text)
    result.setBodyStringOrPane(text)

    c.initAllCloneBits()
    return result</t>
<t tx="rodrigob.121403173614.1154"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,v,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo"): # "undo" or "redo"

    u = self ; c = u.commands
    assert(v == c.currentVnode())

    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using v's body text &gt;&gt;
    #trace(`v`)
    #trace("old:"+`v.bodyString()`)
    v.t.setTnodeText(result)
    #trace("new:"+`v.bodyString()`)
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        # print "incremental undo:",leading,trailing
        c.tree.recolor_range(v,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            &lt;&lt; print mismatch trace &gt;&gt;
        # print "non-incremental undo"
        v.setBodyStringOrPane(result)
</t>
<t tx="rodrigob.121403173614.1155"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.delete(str(1+leading)+".0","end")
    if leading &gt; 0:
        c.frame.body.insert("end",'\n')
    c.frame.body.insert("end",mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.delete(str(1+leading)+".0",
            str(leading+new_mid_len)+".0 lineend")
    elif leading &gt; 0:
        c.frame.body.insert(str(1+leading)+".0",'\n')
    c.frame.body.insert(str(1+leading)+".0",mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.get("1.0","end")
s = toUnicode(s,app().tkEncoding) # 2/25/03
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
    c.frame.body.delete("end-1c")
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insert("end",'\n'*(oldNewlines-newlines))
</t>
<t tx="rodrigob.121403173614.1156"># Recreate the text using the present body text.
body = v.bodyString()
body = toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",`body`
    print "result:",`result`</t>
<t tx="rodrigob.121403173614.1157">textResult = c.frame.body.get("1.0","end")
textResult = toUnicode(textResult,app().tkEncoding) # 2/25/03

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result</t>
<t tx="rodrigob.121403173614.1158">print "undo mismatch"
print "expected:",`result`
print "actual  :",`textResult`
</t>
<t tx="rodrigob.121403173614.1159">def undoSortChildren (self):

    u = self ; c = u.commands ; v = u.v
    assert(v)
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        index = 0
        for child in u.sort:
            child.moveToNthChildOf(v,index)
            index += 1
        v.setDirty()
        c.setChanged(true)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.1160">def undoSortSiblings (self):
    
    u = self ; c = u.commands ; v = u.v
    parent = v.parent()
    assert(v and parent)
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        index = 0
        for sib in u.sort:
            sib.moveToNthChildOf(parent,index)
            index += 1
        parent.setDirty()
        c.setChanged(true)
    c.endUpdate()</t>
<t tx="rodrigob.121403173614.1161">def undoSortTopLevel (self):
    
    u = self ; c = u.commands
    root = c.rootVnode()
    
    c.beginUpdate()
    c.endEditing()
    v = u.sort[0]
    v.moveToRoot(oldRoot=root)
    for next in u.sort[1:]:
        next.moveAfter(v)
        v = next
    c.setChanged(true)
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.1162">@language python

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from leoGlobals import *
import types

@others</t>
<t tx="rodrigob.121403173614.1163">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
    + a' (1)
    + a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
    + a'
        + b
    + a'
        + b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
    + a'
        + b' (1)
        + b' (2)
    + a'
        + b' (1)
        + b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then converts each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="rodrigob.121403173614.1164">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="rodrigob.121403173614.1165">class baseTnode:
    """The base class of the tnode class."""
    &lt;&lt; tnode constants &gt;&gt;
    @others
    
class tnode (baseTnode):
    """A class that implements tnodes."""
    pass</t>
<t tx="rodrigob.121403173614.1166">dirtyBit =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit =	0x04</t>
<t tx="rodrigob.121403173614.1167"># All params have defaults, so t = tnode() is valid.

def __init__ (self,index=0,bodyString=None,headString=None):

    a = app()
    self.bodyString = choose(bodyString, bodyString, "")
    self.statusBits = 0 # status bits
    self.selectionStart = 0 # The start of the selected body text.
    self.selectionLength = 0 # The length of the selected body text.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    # For Pre-3.12 files.  These must always exist.
    self.fileIndex = index # The immutable file index for self tnode.
    self.cloneIndex = 0 # Zero for @file nodes
    # New in 3.12
    self.joinList = [] # vnodes on the same joinlist are updated together.
    self.headString = headString
</t>
<t tx="rodrigob.121403173614.1168"></t>
<t tx="rodrigob.121403173614.1169">def hasBody (self):

    return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="rodrigob.121403173614.1170">def loadBodyPaneFromTnode(self, body):

    s = self.bodyString
    if s and len(s) &gt; 0:
        body.delete(1,"end")
        body.insert(1,s)
    else:
        body.delete(1,"end")</t>
<t tx="rodrigob.121403173614.1171"></t>
<t tx="rodrigob.121403173614.1172">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="rodrigob.121403173614.1173">def isRichTextBit (self):

    return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="rodrigob.121403173614.1174">def isVisited (self):

    return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="rodrigob.121403173614.1175"></t>
<t tx="rodrigob.121403173614.1176"></t>
<t tx="rodrigob.121403173614.1177">def saveBodyPaneToTnode (self,body): # No need for an encoding param.

    self.setTnodeText(body.GetValue()) # 1/20/03

    # Set the selection.
    i,j = body.GetSelection()
    if i &gt; j:
        i,j = j,i
    self.selectionStart = i
    self.selectionLength = j - i
</t>
<t tx="rodrigob.121403173614.1178"># This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    s = toUnicode(s,encoding,reportErrors=true)
    self.bodyString = s
</t>
<t tx="rodrigob.121403173614.1179">def setSelection (self, start, length):

    self.selectionStart = start
    self.selectionLength = length</t>
<t tx="rodrigob.121403173614.1180"></t>
<t tx="rodrigob.121403173614.1181">def clearDirty (self):

    self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="rodrigob.121403173614.1182">def clearRichTextBit (self):

    self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="rodrigob.121403173614.1183">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="rodrigob.121403173614.1184">def setDirty (self):

    self.statusBits |= self.dirtyBit</t>
<t tx="rodrigob.121403173614.1185">def setRichTextBit (self):

    self.statusBits |= self.richTextBit</t>
<t tx="rodrigob.121403173614.1186">def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="rodrigob.121403173614.1187">def setCloneIndex (self, index):

    self.cloneIndex = index</t>
<t tx="rodrigob.121403173614.1188">def setFileIndex (self, index):

    self.fileIndex = index</t>
<t tx="rodrigob.121403173614.1189">class baseVnode:
    """The base class of the vnode class."""
    &lt;&lt; vnode constants &gt;&gt;
    @others
    
class vnode (baseVnode):
    """A class that implements vnodes."""
    pass</t>
<t tx="rodrigob.121403173614.1190"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # true: vnode has clone mark.
# not used	 = 0x02
expandedBit = 0x04 # true: vnode is expanded.
markedBit	  = 0x08 # true: vnode is marked
orphanBit	  = 0x10 # true: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # true: vnode is current vnode.
topBit		    = 0x40 # true: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit	 = 0x100
</t>
<t tx="rodrigob.121403173614.1191"></t>
<t tx="rodrigob.121403173614.1192">if 0: # not used
    def __cmp__(self,other):
        
        trace(`self` + "," + `other`)
        return not (self is other) # Must return 0, 1 or -1</t>
<t tx="rodrigob.121403173614.1193">def __init__ (self,commands,t):

    a = app()
    assert(t)
    
    # commands may be None for testing.
    # assert(commands)

    &lt;&lt; initialize vnode data members &gt;&gt;
</t>
<t tx="rodrigob.121403173614.1194">self.commands = commands # The commander for this vnode.
self.t = t # The tnode, i.e., the body text.
self.statusBits = 0 # status bits

# Structure links
self.mParent = self.mFirstChild = self.mNext = self.mBack = None

# To be moved to vxnodes...

self.iconVal = -1 # The icon index.  -1 forces an update of icon.
self.iconx, self.icony = 0,0 # Coords of icon so icon can be redrawn separately.</t>
<t tx="rodrigob.121403173614.1195">def __repr__ (self):
    
    if self.t:
        return "&lt;vnode %d:%s&gt;" % (id(self),`self.t.headString`)
    else:
        return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
        
__str__ = __repr__
</t>
<t tx="rodrigob.121403173614.1196">@ These callbacks are vnode methods so we can pass the vnode back to the tree class.
</t>
<t tx="rodrigob.121403173614.1197"># Called when the box is clicked.

def OnBoxClick(self,event=None):

    try:
        v = self ; c = v.commands
        if not doHook("boxclick1",c=c,v=v,event=event):
            self.commands.tree.OnBoxClick(self)
        doHook("boxclick2",c=c,v=v,event=event)
    except:
        es_event_exception("boxclick")</t>
<t tx="rodrigob.121403173614.1198">def OnDrag(self,event=None):
    
    # trace()
    
    try:
        v = self ; c = v.commands
        if c.frame.tree.dragging:
            if not doHook("dragging1",c=c,v=v,event=event):
                self.commands.tree.OnDrag(self,event)
            doHook("dragging2",c=c,v=v,event=event)
        else:
            if not doHook("drag1",c=c,v=v,event=event):
                self.commands.tree.OnDrag(self,event)
            doHook("drag2",c=c,v=v,event=event)
    except:
        es_event_exception("drag")</t>
<t tx="rodrigob.121403173614.1199">def OnEndDrag(self,event=None):
    
    """Vnode end-drag handler."""
    
    # trace()

    try:
        v = self ; c = v.commands
        # 7/10/03: Always call tree.OnEndDrag, regardless of state.
        if not doHook("enddrag1",c=c,v=v,event=event):
            self.commands.tree.OnEndDrag(self,event)
        doHook("enddrag2",c=c,v=v,event=event)
    except:
        es_event_exception("enddrag")</t>
<t tx="rodrigob.121403173614.1200">def OnHeadlineClick(self,event=None):
    try:
        v = self ; c = v.commands
        if not doHook("headclick1",c=c,v=v,event=event):
            self.commands.tree.OnActivate(self)
        doHook("headclick2",c=c,v=v,event=event)
    except:
        es_event_exception("headclick")
    
def OnHeadlineRightClick(self,event=None):
    try:
        v = self ; c = v.commands
        if not doHook("headrclick1",c=c,v=v,event=event):
            self.commands.tree.OnActivate(self)
            self.commands.tree.OnPopup(self,event)
        doHook("headrclick2",c=c,v=v,event=event)
    except:
        es_event_exception("headrclick")</t>
<t tx="rodrigob.121403173614.1201">def OnHeadlineKey (self,event=None):

    try:
        v = self ; c = v.commands
        if not doHook("headkey1",c=c,v=v,event=event):
            self.commands.tree.OnHeadlineKey(self,event)
        doHook("headkey2",c=c,v=v,event=event)
    except:
        es_event_exception("headkey")</t>
<t tx="rodrigob.121403173614.1202">def OnHyperLinkControlClick (self,event):

    try:
        v = self ; c = v.commands
        if not doHook("hypercclick1",c=c,v=v,event=event):
            c.beginUpdate()
            c.selectVnode(v)
            c.endUpdate()
            c.body.mark_set("insert","1.0")
        doHook("hypercclick2",c=c,v=v,event=event)
    except:
        es_event_exception("hypercclick")</t>
<t tx="rodrigob.121403173614.1203">def OnHyperLinkEnter (self,event=None):

    try:
        v = self ; c = v.commands
        if not doHook("hyperenter1",c=c,v=v,event=event):
            if 0: # This works, and isn't very useful.
                c.body.tag_config(v.tagName,background="green")
        doHook("hyperenter2",c=c,v=v,event=event)
    except:
        es_event_exception("hyperenter")</t>
<t tx="rodrigob.121403173614.1204">def OnHyperLinkLeave (self,event=None):

    try:
        v = self ; c = v.commands
        if not doHook("hyperleave1",c=c,v=v,event=event):
            if 0: # This works, and isn't very useful.
                c.body.tag_config(v.tagName,background="white")
        doHook("hyperleave2",c=c,v=v,event=event)
    except:
        es_event_exception("hyperleave")</t>
<t tx="rodrigob.121403173614.1205">def OnIconClick(self,event=None):
    try:
        v = self ; c = v.commands
        if not doHook("iconclick1",c=c,v=v,event=event):
            self.commands.tree.OnIconClick(self,event)
        doHook("iconclick2",c=c,v=v,event=event)
    except:
        es_event_exception("iconclick")
    
def OnIconRightClick(self,event=None):
    try:
        v = self ; c = v.commands
        if not doHook("iconrclick1",c=c,v=v,event=event):
            self.commands.tree.OnIconRightClick(self,event)
        doHook("iconrclick2",c=c,v=v,event=event)
    except:
        es_event_exception("iconrclick")
</t>
<t tx="rodrigob.121403173614.1206">def OnIconDoubleClick(self,event=None):

    try:
        v = self ; c = v.commands
        if not doHook("icondclick1",c=c,v=v,event=event):
            self.commands.tree.OnIconDoubleClick(self)
        doHook("icondclick2",c=c,v=v,event=event)
    except:
        es_event_exception("icondclick")
</t>
<t tx="rodrigob.121403173614.1207"></t>
<t tx="rodrigob.121403173614.1208"># 12/03/02: We now handle @file options here.

def afterHeadlineMatch(self,s):
    
    h = self.headString()

    if s != "@file" and match_word(h,0,s):
        # No options are valid.
        return string.strip(h[len(s):])
    elif match(h,0,"@file"):
        i,atFileType,junk = scanAtFileOptions(h)
        if s == atFileType:
            # print "s,h:",s,h
            return string.strip(h[i:])
        else: return ""
    else: return ""
</t>
<t tx="rodrigob.121403173614.1209">@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
    return self.afterHeadlineMatch("@file")
    
def atNoSentinelsFileNodeName (self):
    return self.afterHeadlineMatch("@nosentinelsfile")
    
def atRawFileNodeName (self):
    return self.afterHeadlineMatch("@rawfile")
    
def atSilentFileNodeName (self):
    return self.afterHeadlineMatch("@silentfile")
</t>
<t tx="rodrigob.121403173614.1210"># Returns true if the receiver's headline starts with @file.
def isAtFileNode (self):
    s = self.atFileNodeName()
    return len(s) &gt; 0
    
# Returns true if the receiver's headline starts with @rawfile.
def isAtNoSentinelsFileNode (self):
    s = self.atNoSentinelsFileNodeName()
    return len(s) &gt; 0
    
# Returns true if the receiver's headline starts with @rawfile.
def isAtRawFileNode (self):
    s = self.atRawFileNodeName()
    return len(s) &gt; 0

# Returns true if the receiver's headline starts with @silentfile.
def isAtSilentFileNode (self):
    s = self.atSilentFileNodeName()
    return len(s) &gt; 0
</t>
<t tx="rodrigob.121403173614.1211">def isAnyAtFileNode (self):

    return (
        self.isAtFileNode() or
        self.isAtNoSentinelsFileNode() or
        self.isAtRawFileNode() or
        self.isAtSilentFileNode())
        
def anyAtFileNodeName (self):

    if self.isAtFileNode():
        return self.atFileNodeName()
    elif self.isAtNoSentinelsFileNode():
        return self.atNoSentinelsFileNodeName()
    elif self.isAtRawFileNode():
        return self.atRawFileNodeName()
    elif self.isAtSilentFileNode():
        return self.atSilentFileNodeName()
    else:
        return ""
</t>
<t tx="rodrigob.121403173614.1212">@ Returns true if the receiver contains @ignore in its body at the start of a line.
@c

def isAtIgnoreNode (self):

    flag, i = is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="rodrigob.121403173614.1213">@ Returns true if the receiver contains @others in its body at the start of a line.
@c

def isAtOthersNode (self):

    flag, i = is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="rodrigob.121403173614.1214">@ Returns true if the headline matches the pattern ignoring whitespace and case.  The headline may contain characters following the successfully matched pattern.
@c

def matchHeadline (self,pattern):

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    p = string.lower(pattern)
    p = string.replace(p,' ','')
    p = string.replace(p,'\t','')

    # ignore characters in the headline following the match
    return p == h[0:len(p)]</t>
<t tx="rodrigob.121403173614.1215"></t>
<t tx="rodrigob.121403173614.1216"># Converts the outline to a string in "MORE" format

def convertTreeToString (self):

    v = self
    level1 = v.level()
    after = v.nodeAfterTree()
    s = ""
    while v and v != after:
        s += v.moreHead(level1) + "\n"
        body = v.moreBody()
        if len(body) &gt; 0:
            s += body + "\n"
        v = v.threadNext()
    return s</t>
<t tx="rodrigob.121403173614.1217"># Returns the headline string in MORE format.

def moreHead (self, firstLevel,useVerticalBar=false):

    v = self
    level = self.level() - firstLevel
    if level &gt; 0: s = "\t" * level
    else: s = ""
    s += choose(v.hasChildren(), "+ ", "- ")
    s += v.headString()
    return s</t>
<t tx="rodrigob.121403173614.1218">@ Returns the body string in MORE format.  It inserts a backslash before any leading plus, minus or backslash.

+ test line
- test line
\ test line
test line +
test line -
test line \

More lines...
@c

def moreBody (self):

    v = self ; list = []
    
    if 1: # new code: only escape the first non-blank character of the line.
        s =  v.t.bodyString ; result = []
        lines = string.split(s,'\n')
        for s in lines:
            i = skip_ws(s,0)
            if i &lt; len(s):
                ch = s[i]
                if ch == '+' or ch == '-' or ch == '\\':
                    s = s[:i] + '\\' + s[i:]
            result.append(s)
        return string.join(result,'\n')

    else: # pre 3.1 code.
        for ch in v.t.bodyString:
            if ch == '+' or ch == '-' or ch == '\\':
                list.append('\\')
            list.append(ch)
        return string.join(list,'')</t>
<t tx="rodrigob.121403173614.1219"></t>
<t tx="rodrigob.121403173614.1220"></t>
<t tx="rodrigob.121403173614.1221"># childIndex and nthChild are zero-based.

def childIndex (self):

    parent=self.parent()
    if not parent: return 0

    child = parent.firstChild()
    n = 0
    while child:
        if child == self: return n
        n += 1 ; child = child.next()
    assert(false)</t>
<t tx="rodrigob.121403173614.1222"># Compatibility routine for scripts

def firstChild (self):

    return self.mFirstChild</t>
<t tx="rodrigob.121403173614.1223">def hasChildren (self):

    return self.firstChild() != None</t>
<t tx="rodrigob.121403173614.1224"># Compatibility routine for scripts

def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child</t>
<t tx="rodrigob.121403173614.1225"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n &gt; 0 and child:
        n -= 1
        child = child.next()
    return child</t>
<t tx="rodrigob.121403173614.1226">def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n</t>
<t tx="rodrigob.121403173614.1227"></t>
<t tx="rodrigob.121403173614.1228">def isCloned (self):

    return ( self.statusBits &amp; vnode.clonedBit ) != 0</t>
<t tx="rodrigob.121403173614.1229">def isDirty (self):

    return self.t.isDirty()</t>
<t tx="rodrigob.121403173614.1230">def isExpanded (self):

    return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="rodrigob.121403173614.1231">def isMarked (self):

    return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="rodrigob.121403173614.1232">def isOrphan (self):

    return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="rodrigob.121403173614.1233">def isSelected (self):

    return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="rodrigob.121403173614.1234">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="rodrigob.121403173614.1235"># Returns true if all parents are expanded.

def isVisible (self):

    v = self.parent()
    while v:
        if not v.isExpanded():
            return false
        v = v.parent()
    return true</t>
<t tx="rodrigob.121403173614.1236">def isVisited (self):

    return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="rodrigob.121403173614.1237">def status (self):

    return self.statusBits</t>
<t tx="rodrigob.121403173614.1238"># Compatibility routine for scripts

def bodyString (self):

    return self.t.bodyString</t>
<t tx="rodrigob.121403173614.1239"># Compatibility routine for scripts

def currentVnode (self):

    return self.commands.tree.currentVnode</t>
<t tx="rodrigob.121403173614.1240">def edit_text (self):
    
    return self.commands.tree.edit_text_dict.get(self)</t>
<t tx="rodrigob.121403173614.1241"># Compatibility routine for scripts

def findRoot (self):

    return self.commands.tree.rootVnode
</t>
<t tx="rodrigob.121403173614.1242">def headString (self):

    if self.t.headString:
        return self.t.headString
    else:
        return ""
        
def cleanHeadString (self):
    
    s = self.headString()
    s = toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
    return s</t>
<t tx="rodrigob.121403173614.1243">def isAncestorOf (self, v):

    if not v:
        return false
    v = v.parent()
    while v:
        if v == self:
            return true
        v = v.parent()
    return false</t>
<t tx="rodrigob.121403173614.1244">def isRoot (self):

    return not self.parent() and not self.back()</t>
<t tx="rodrigob.121403173614.1245">def exists(self,c):
    
    """Return true if v exists in c's tree"""
    
    v = self ; c = v.commands
    
    # This code must be fast.
    root = c.rootVnode()
    while v:
        if v == root:
            return true
        p = v.parent()
        if p:
            v = p
        else:
            v = v.back()
        
    return false</t>
<t tx="rodrigob.121403173614.1246"></t>
<t tx="rodrigob.121403173614.1247"></t>
<t tx="rodrigob.121403173614.1248">def appendStringToBody (self,s,encoding="utf-8"):

    if len(s) == 0: return
    body = self.t.bodyString + s
    self.setBodyStringOrPane(body,encoding)
</t>
<t tx="rodrigob.121403173614.1249">def setBodyStringOrPane (self,s,encoding="utf-8"):

    v = self ; c = v.commands
    if not c or not v: return
    
    s = toUnicode(s,encoding)
    if v == c.currentVnode():
        # This code destoys all tags, so we must recolor.
        c.frame.body.delete("1.0","end")
        c.frame.body.insert("1.0",s) # Replace the body text with s.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.t.setTnodeText(s)
        v.t.setSelection(0,0)
        v.setDirty()
        if not c.isChanged():
            c.setChanged(true)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="rodrigob.121403173614.1250">def setHeadString (self,s,encoding="utf-8"):

    self.initHeadString(s,encoding) # 6/28/03
    self.setDirty()

def initHeadString (self,s,encoding="utf-8"):

    s = toUnicode(s,encoding,reportErrors=true)
    self.t.headString = s
</t>
<t tx="rodrigob.121403173614.1251"># Compatibility routine for scripts

def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    c = self.commands
    c.endEditing()
    self.setHeadString(s,encoding)
</t>
<t tx="rodrigob.121403173614.1252">def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="rodrigob.121403173614.1253"></t>
<t tx="rodrigob.121403173614.1254"># Compatibility routine for scripts

def clearAllVisited (self):
    
    self.commands.clearAllVisited()
</t>
<t tx="rodrigob.121403173614.1255">def clearAllVisitedInTree (self):

    v = self ; c = v.commands
    after = v.nodeAfterTree()
    
    c.beginUpdate()
    while v and v != after:
        v.clearVisited()
        v.t.clearVisited()
        v = v.threadNext()
    c.endUpdate()
</t>
<t tx="rodrigob.121403173614.1256">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="rodrigob.121403173614.1257">def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    # trace()
    v = self ; c = v.commands
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons</t>
<t tx="rodrigob.121403173614.1258">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
    doHook("clear-mark",c=self.commands,v=self)</t>
<t tx="rodrigob.121403173614.1259">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="rodrigob.121403173614.1260">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="rodrigob.121403173614.1261">def clearVisitedInTree (self):

    after = self.nodeAfterTree()
    v = self
    while v and v != after:
        v.clearVisited()
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.1262">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

def expand(self):

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="rodrigob.121403173614.1263">def initStatus (self, status):

    self.statusBits = status</t>
<t tx="rodrigob.121403173614.1264">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to the caller.

This marks v dirty and all cloned nodes in v's tree.

2/1/03: I don't see how this can possibly be correct.
Why is it needed?? If it is needed, what about undo??
@c
def setAncestorsOfClonedNodesInTreeDirty(self):

    # Look up the tree for an ancestor @file node.
    v = self ; redraw_flag = false
    
    if v == None:
        return redraw_flag
        
    flag = v.setAncestorAtFileNodeDirty()
    if flag: redraw_flag = true
        
    next = v.nodeAfterTree()
    v = v.threadNext()
    while v and v != next:
        if v.isCloned() and not v.isDirty():
            flag = v.setAncestorAtFileNodeDirty()
            if flag: redraw_flag = true
            for v2 in v.t.joinList:
                if v2 != v:
                    flag = v2.setAncestorAtFileNodeDirty()
                    if flag: redraw_flag = true
        v = v.threadNext()

    return redraw_flag</t>
<t tx="rodrigob.121403173614.1265">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to c.endUpdate().

This is called from v.setDirty, so we avoid further calls to v.setDirty here.  The caller, that is, v.setDirty itself, handles all clones.

@c
def setAncestorAtFileNodeDirty(self):

    # Look up the tree for an ancestor @file node.
    v = self ; c = v.commands
    redraw_flag = false
    c.beginUpdate()
    while v:
        if not v.isDirty() and v.isAnyAtFileNode():
            redraw_flag = true
            v.t.setDirty() # Do not call v.setDirty here!
        v = v.parent()
    c.endUpdate(redraw_flag) # A crucial optimization: does nothing if inside nested begin/endUpdate.
    return redraw_flag # Allow caller to do the same optimization.</t>
<t tx="rodrigob.121403173614.1266">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="rodrigob.121403173614.1267">@ v.setDirty now ensures that all cloned nodes are marked dirty and that all ancestor @file nodes are marked dirty.  It is much safer to do it this way.

v.setDirtyDeleted is used only when a node is deleted.  (And why is it even needed????)
@c

def setDirty (self):

    v = self ; c = v.commands
    # trace(`v`)
    changed = false
    c.beginUpdate()
    if not v.t.isDirty():
        v.t.setDirty()
        changed = true
    # This must _always_ be called, even if v is already dirty.
    if v.setAncestorAtFileNodeDirty():
        changed = true
    for v2 in v.t.joinList:
        if v2 != v:
            assert(v2.t.isDirty())
            # Again, must always be called.
            if v2.setAncestorAtFileNodeDirty():
                changed = true
    c.endUpdate(changed)
    return changed
    
def setDirtyDeleted (self):
    
    self.setDirty()
    return
    
    ## This code is bizarre and unnecessary.

    v = self ; c = v.commands
    # trace(`v`)
    changed = false
    c.beginUpdate()
    if not v.t.isDirty():
        v.t.setDirty()
        changed = true
    # This must _always_ be called, even if v is already dirty.
    if v.setAncestorsOfClonedNodesInTreeDirty():
        changed = true
    for v2 in v.t.joinList:
        if v2 != v:
            assert(v2.t.isDirty())
            # Again, must always be called.
            if v2.setAncestorsOfClonedNodesInTreeDirty():
                changed = true
    c.endUpdate(changed)
    return changed

def initDirtyBit (self):
    self.t.setDirty()</t>
<t tx="rodrigob.121403173614.1268">def setMarked (self):

    self.statusBits |= self.markedBit
    doHook("set-mark",c=self.commands,v=self)

def initMarkedBit (self):

    self.statusBits |= self.markedBit</t>
<t tx="rodrigob.121403173614.1269">def setOrphan (self):

    self.statusBits |= self.orphanBit</t>
<t tx="rodrigob.121403173614.1270"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit</t>
<t tx="rodrigob.121403173614.1271"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="rodrigob.121403173614.1272">def setSelection (self, start, length):

    self.t.setSelection ( start, length )</t>
<t tx="rodrigob.121403173614.1273">def setT (self, t):

    if t != self:
        del self.t
        self.t = t</t>
<t tx="rodrigob.121403173614.1274">@ This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.
@c

def trimTrailingLines (self):

    v = self
    body = v.bodyString()
    # trace(`body`)
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = false
    while i &gt;= 0:
        line = lines[i]
        j = skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = true
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # trace(`body`)
        v.setBodyStringOrPane(body)
        # Don't set the dirty bit: it would just be annoying.</t>
<t tx="rodrigob.121403173614.1275"></t>
<t tx="rodrigob.121403173614.1276"># Compatibility routine for scripts

def back (self):

    return self.mBack</t>
<t tx="rodrigob.121403173614.1277">def lastNode (self):

    v = self
    level = self.level()
    result = None

    while v:
        result = v
        v = v.threadNext()
        if not v or v.level() &lt;= level:
            break

    return result</t>
<t tx="rodrigob.121403173614.1278">@ This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.
@c

def level (self):

    level = 0 ; parent = self.parent()
    while parent:
        level += 1
        parent = parent.parent()
    return level</t>
<t tx="rodrigob.121403173614.1279"># Compatibility routine for scripts

def next (self):

    return self.mNext</t>
<t tx="rodrigob.121403173614.1280"># Returns the vnode following the tree whose root is the receiver.

def nodeAfterTree (self):

    next = self.next()
    p = self.parent()

    while not next and p:
        next = p.next()
        p = p.parent()

    return next</t>
<t tx="rodrigob.121403173614.1281"># Compatibility routine for scripts

def parent (self):

    return self.mParent</t>
<t tx="rodrigob.121403173614.1282">def threadBack (self):
    
    """Returns the previous element of the outline, or None if at the start of the outline"""

    back = self.back()
    if back:
        lastChild = back.lastChild()
        if lastChild:
            return lastChild.lastNode()
        else:
            return back
    else:
        return self.parent()</t>
<t tx="rodrigob.121403173614.1283">def threadNext (self):

    """Returns node following the receiver in "threadNext" order"""

    # stat()
    v = self
    if v.firstChild():
        return v.firstChild()
    elif v.next():
        return v.next()
    else:
        p = v.parent()
        while p:
            if p.next():
                return p.next()
            p = p.parent()
        return None</t>
<t tx="rodrigob.121403173614.1284">def visBack (self):

    v = self.threadBack()
    while v and not v.isVisible():
        v = v.threadBack()
    return v</t>
<t tx="rodrigob.121403173614.1285">def visNext (self):

    v = self.threadNext()
    while v and not v.isVisible():
        v = v.threadNext()
    return v</t>
<t tx="rodrigob.121403173614.1286"></t>
<t tx="rodrigob.121403173614.1287"></t>
<t tx="rodrigob.121403173614.1288">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self, newVnode):

    """Unlinks the receiver, but does not destroy it. May be undone"""

    v = self ; c = v.commands
    v.setDirty() # 1/30/02: mark @file nodes dirty!
    v.destroyDependents()
    v.unjoinTree()
    v.unlink()
    # Bug fix: 1/18/99: we must set the currentVnode here!
    c.selectVnode(newVnode)
    # Update all clone bits.
    c.initAllCloneBits()
    return self # We no longer need dvnodes: vnodes contain all needed info.</t>
<t tx="rodrigob.121403173614.1289">def insertAfter (self,t=None):

    """Inserts a new vnode after the receiver"""

    if not t:
        t = tnode(headString="NewHeadline")
    v = vnode(self.commands,t)
    v.iconVal = 0
    v.linkAfter(self)
    return v</t>
<t tx="rodrigob.121403173614.1290">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of the receiver"""

    n = self.numberOfChildren()
    if not t:
        t = tnode(headString="NewHeadline")
    return self.insertAsNthChild(n,t)</t>
<t tx="rodrigob.121403173614.1291">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""
    
    # trace(`n` + `self`)
    if not t:
        t = tnode(headString="NewHeadline")
    v = vnode(self.commands,t)
    v.iconVal = 0
    v.linkAsNthChild(self,n)
    return v</t>
<t tx="rodrigob.121403173614.1292">def moveToRoot (self, oldRoot = None):

    """Moves the receiver to the root position"""

    v = self
    v.destroyDependents()
    v.unlink()
    v.linkAsRoot(oldRoot)
    v.createDependents()</t>
<t tx="rodrigob.121403173614.1293"># Restores (relinks) the dv tree in the position described by back and parent.

def restoreOutlineFromDVnodes (self, dv, parent, back):

    if back:
        dv.linkAfter(back)
    elif parent:
        dv.linkAsNthChild(parent, 0)
    else:
        dv.linkAsRoot()
    return dv</t>
<t tx="rodrigob.121403173614.1294"># Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):
    
    clone = self.cloneTree(back)
    clone.createDependents()

    # Set the clone bit in all nodes joined to back.
    clone.setClonedBit()
    back.setClonedBit()
    for v in back.t.joinList:
        v.setClonedBit()

    return clone</t>
<t tx="rodrigob.121403173614.1295"># Links the receiver after v.

def linkAfter (self,v):

    # stat()
    self.mParent = v.mParent
    self.mBack = v
    self.mNext = v.mNext
    v.mNext = self
    if self.mNext:
        self.mNext.mBack = self</t>
<t tx="rodrigob.121403173614.1296">def linkAsNthChild (self, p, n):

    """Links the receiver as the n'th child of p"""

    v = self
    # stat() ; # trace(`v` + ", " + `p` + ", " + `n`)
    v.mParent = p
    if n == 0:
        v.mBack = None
        v.mNext = p.mFirstChild
        if p.mFirstChild:
            p.mFirstChild.mBack = v
        p.mFirstChild = v
    else:
        prev = p.nthChild(n-1) # zero based
        assert(prev)
        v.mBack = prev
        v.mNext = prev.mNext
        prev.mNext = v
        if v.mNext:
            v.mNext.mBack = v</t>
<t tx="rodrigob.121403173614.1297">@ Bug fix: 5/27/02.  We link in the rest of the tree only when oldRoot != None.  Otherwise, we are calling this routine from init code and we want to start with a pristine tree.
@c
def linkAsRoot(self, oldRoot = None):

    v = self ; c = v.commands ; tree = c.tree
    # stat() ; # trace(`v`)
    # Bug fix 3/16/02:
    # Clear all links except the child link.
    # This allows a node with children to be moved up properly to the root position.
    # v.mFirstChild = None
    v.mParent = None
    v.mBack = None
    # 5/27/02
    if oldRoot: oldRoot.mBack = v
    v.mNext = oldRoot
    tree.rootVnode = v
</t>
<t tx="rodrigob.121403173614.1298"># Used by scripts

def moveAfter (self,a):

    """Moves the receiver after a"""

    v = self ; c = self.commands
    v.destroyDependents()
    v.unlink()
    v.linkAfter(a)
    v.createDependents()
    
    # 5/27/02: Moving a node after another node can create a new root node.
    if not a.parent() and not a.back():
        c.tree.rootVnode = a</t>
<t tx="rodrigob.121403173614.1299"># Compatibility routine for scripts

def moveToNthChildOf (self, p, n):

    """Moves the receiver to the nth child of p"""

    v = self ; c = self.commands

    v.destroyDependents()
    v.unlink()
    v.linkAsNthChild(p, n)
    v.createDependents()
    
    # 5/27/02: Moving a node can create a new root node.
    if not p.parent() and not p.back():
        c.tree.rootVnode = p</t>
<t tx="rodrigob.121403173614.1300">def sortChildren (self):

    # Create a list of (headline,vnode) tuples
    v = self ; pairs = []
    child = v.firstChild()
    if not child: return
    while child:
        pairs.append((string.lower(child.headString()), child))
        child = child.next()
    # Sort the list on the headlines.
    pairs.sort()
    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(v,index)
        index += 1</t>
<t tx="rodrigob.121403173614.1301"></t>
<t tx="rodrigob.121403173614.1302">def addTreeToJoinLists (self):
    
    """Add each v of v's entire tree to v.t.joinList."""
    
    v = self ; after = v.nodeAfterTree()
    
    while v and v != after:
        if not v in v.t.joinList:
            v.t.joinList.append(v)
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.1303">def cloneTree (self, oldTree):
    
    """Create a cloned tree after oldTree."""

    # Create a new tree following oldTree.
    newTree = oldTree.copyTree()
    newTree.linkAfter(oldTree)
    # Join the trees and copy clone bits.
    oldTree.joinTreeTo(newTree)
    oldTree.copyCloneBitsTo(newTree)
    return newTree</t>
<t tx="rodrigob.121403173614.1304"># This methods propagates clone bits from the receiver's tree to tree2.

def copyCloneBitsTo (self, tree2):

    tree1 = self
    assert(tree2)
    # Set the bit in the root.
    if tree1.isCloned():
        tree2.setClonedBit()
    else:
        tree2.clearClonedBit()
    # Recursively set the bits in all subtrees.
    child1 = tree1.firstChild()
    child2 = tree2.firstChild()
    while child1:
        assert(child2)
        if child1.isCloned():
            child2.setClonedBit()
        else:
            child2.clearClonedBit()
        child1 = child1.next()
        child2 = child2.next()
    assert(child2 == None)</t>
<t tx="rodrigob.121403173614.1305"># Rewritten 7/11/03.

def copyTree (self):
    
    """Returns a free-standing copy of a vnode and all its descendents.
    
    The new tree uses the same tnodes as the old,
    but the new vnodes are _not_ joined to the old nodes.
    That is, the new vnodes v do not appear on v.t.joinList."""
    
    c = self.commands ; old_v = self
    
    # trace(self)
    
    # Copy all fields of the root.
    new_v = vnode(c,old_v.t)
    new_v.t.headString = old_v.t.headString
    new_v.iconVal = old_v.iconVal
    assert(new_v not in new_v.t.joinList)

    # Recursively copy and link all children.
    old_child = old_v.firstChild()
    n = 0
    while old_child:
        new_child = old_child.copyTree()
        new_child.linkAsNthChild(new_v,n)
        assert(new_child not in new_child.t.joinList)
        n += 1
        old_child = old_child.next()
        
    return new_v
</t>
<t tx="rodrigob.121403173614.1306">def copyTreeWithNewTnodes (self):
    
    """Return a copy of self with all new tnodes"""
    
    c = self.commands
    # trace(`self`)
    
    # Create the root node.
    old_v = self
    new_v = vnode(c,tnode())
    new_v.t.headString = old_v.t.headString
    new_v.t.bodyString = old_v.t.bodyString
    
    # Recursively create all descendents.
    old_child = old_v.firstChild() ; n = 0
    while old_child:
        new_child = old_child.copyTreeWithNewTnodes()
        new_child.linkAsNthChild (new_v, n)
        n += 1
        old_child = old_child.next()
        
    # Return the root of the new tree.
    return new_v</t>
<t tx="rodrigob.121403173614.1307"># This method creates all nodes that depend on the receiver.
def createDependents (self):

    v = self ; t = v.t ; parent = v.parent()
    if not parent: return

    # Copy v as the nth child of all nodes joined to parent.
    n = v.childIndex()
    
    # 7/11/03: work on copy of join list.
    joinList = parent.t.joinList[:]
    if parent in joinList:
        joinList.remove(parent)

    for p in joinList:
        # trace(n,p)
        copy = v.copyTree()
        copy.linkAsNthChild(p,n)
        v.joinTreeTo(copy)</t>
<t tx="rodrigob.121403173614.1308"># Destroys all dependent vnodes and tree nodes associated with the receiver.

def destroyDependents (self):
    
    """Destroy the nth child of all nodes joined to the receiver's parent.."""

    parent = self.parent()
    if not parent:
        # trace("no parent",self)
        return

    n = self.childIndex()
    
    # 7/11/03: work on copy of join list.
    joinList = parent.t.joinList[:]
    if parent in joinList:
        joinList.remove(parent)
    #trace(parent,joinList)

    for join in joinList:
        # trace(n,join)
        child = join.nthChild(n)
        if child:
            child.unjoinTree()
            child.unlink()
            child.destroyTree()</t>
<t tx="rodrigob.121403173614.1309">@ This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.
@c

def destroyTree (self):

    pass</t>
<t tx="rodrigob.121403173614.1310">def invalidOutline (self, message):

    s = "invalid outline: " + message + "\n"
    parent = self.parent()

    if parent:
        s += `parent`
    else:
        s += `self`

    alert ( s )</t>
<t tx="rodrigob.121403173614.1311">def joinNodeTo (self, v2):
    
    """Add self or v2 to their common join list"""

    v1 = self
    assert(v1.t==v2.t)
    j = v1.t.joinList
    
    if v1 not in j:
        j.append(v1)
        
    if v2 not in j:
        j.append(v2)</t>
<t tx="rodrigob.121403173614.1312">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The assert's guarantee that both trees have the same topology.
@c

def joinTreeTo (self, tree2):

    tree1 = self
    assert(tree2)
    # Join the roots.
    tree1.joinNodeTo ( tree2 )
    # Recursively join all subtrees.
    child1 = tree1.firstChild()
    child2 = tree2.firstChild()
    while child1:
        assert(child2)
        child1.joinTreeTo(child2)
        child1 = child1.next()
        child2 = child2.next()
    assert(child2 == None)</t>
<t tx="rodrigob.121403173614.1313">@ The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.

Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.
@c

def shouldBeClone (self):
    
    """Returns True if the receiver should be a clone"""
    p = self.parent()
    n = self.childIndex()

    for v in self.t.joinList:
        if v != self:
            vp = v.parent()
            # self and v are structurally dissimilar if...
            if( (not p or not vp) or  # they are at the top level, or
                vp == p or  # have the same parent, or
                p.t != vp.t or  # have unjoined parents, or
                (v.childIndex() != n)): # have different child indices.

                # trace("true",v)
                return true

    # The receiver is structurally similar to all nodes joined to it.
    # trace("false",v)
    return false</t>
<t tx="rodrigob.121403173614.1314">def unjoinTree (self):

    """Remove all v and all its descendents v from v.t.joinList."""

    v = self
    after = self.nodeAfterTree()
    while v and v != after:
        if v in v.t.joinList:
            v.t.joinList.remove(v)
        v = v.threadNext()</t>
<t tx="rodrigob.121403173614.1315">def unlink (self):

    """Unlinks the receiver from the tree before moving or deleting.
    
    The mFistChild link is not affected in the receiver."""

    v = self ; c = v.commands ; tree = c.tree

    # stat() # trace(`v.mParent`+", child:"+`v.mFirstChild`+", back:"+`v.mBack`+", next:"+`v.mNext`)
    
    # Special case the root
    if v == tree.rootVnode:
        if not v.mNext: return # Should never happen.
        tree.rootVnode = v.mNext

    # Clear the links in other nodes
    if v.mBack:
        v.mBack.mNext = v.mNext
    if v.mNext:
        v.mNext.mBack = v.mBack
    if v.mParent and v == v.mParent.mFirstChild:
        v.mParent.mFirstChild = v.mNext

    # Clear the links in this node
    v.mParent = v.mNext = v.mBack = None</t>
<t tx="rodrigob.121403173614.1316"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self, p):

    result = true # optimists get only unpleasant surprises.
    parent = self.parent()
    childIndex = self.childIndex()
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    child = self.firstChild()
    while child:
        r = child.validateOutlineWithParent ( self )
        if not r: result = false
        child = child.next()
    return result</t>
<t tx="rodrigob.121403173614.1317">if parent != p:
    self.invalidOutline ( "Invalid parent link: " + parent.description() )</t>
<t tx="rodrigob.121403173614.1318">if p:
    if childIndex &lt; 0:
        self.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= p.numberOfChildren():
        self.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    self.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="rodrigob.121403173614.1319">if not self.t and p:
    self.invalidOutline ( "Empty t" )</t>
<t tx="rodrigob.121403173614.1320">LeoN development status VIII

Hi,
finally LeoN has reached the alpha status. After a long silence here it is the soup after so much vapour.

Obviously my exams finished long time ago and since end november I have been working hard.

My focus was to cover the base elements to provide the base usability for LeoN, in order be able to refocus myself onto the more important topic: collaborative edition. I want to have this module hard rock, that mean more unit test and solving the HB garbage collector issues.

Release 0.1.0 is mostly an on date release, there are many bugs underlying, but I think it is ready for other persons tests, and I hope it will raise interest to get more developers involved. There is the open source idea of "release soon, release often". No one reported a test of the release 0**0 (release soon), so now I will try to release more often. At difference of  0**0 this release is usable, at least for testing the features, because I'm sure you will find bugs.

A lot of time has passed since the time that the forum was thinking about providing to Leo internet features, almost 8 months ago. During that time my classes have finished, I had participated in the exposition of tecnologies, my computer crashed, the leon.leo file got erased, I had some familiar health difficulties, the year has finished, and finally I got the first alpha release out, ufff.

I'm pretty happy to see that the development path, depicted at the begining of 2003, has worked pretty fine. The step1,2,3,4 scalled very well and finally the design look ok (not bloated, or plenty of patches) and all the features has been integrated without too much pain.

As expectable the Python very high level programming has saved the year, making possible for an individual to achieve such a hard task. Also the excelent work of Edward creating Leo, documenting it, and designing the plugin system was a critical factor. The same has to be said to the Twisted Matrix team that have created an excellent tool for internet application, providing a huge set of tools and feature never found on other internet packages, the excelent design of Twisted, his serious documentation and such a high ratio of bug free code; had made LeoN possible.

Leo as itself is a very good tool. I do not even remember how was the pain of code management before Leo. Passed the two thousand lines of commented code I become very thanksfull to Leo with the code perspectives construction that helped me to focus on some topic and avoided me the hundred of "edit, search, edit, search back" iterations, usual in the simple code edition tools.

Another very cool thing I started to appreciated during the LeoN development is the executable nodes. This feature require a good knowledge of the Leo internals, but once learned it allow to do very agrable things. For example I sufered will the long running, test, detect, patch, retest. To accelerate the process I have developed a very usefull LeoNtest.py program that executed the required tests, start a server and start a Leo client with a specific file. That files included some executable nodes and was saved keeping the most usefull node. Thus with one key the test are run, the server is raised, the client is raise and with one key more (Ctrl+E) I arrived just at the test point (example: automatic connect, select the networked node and raise the admin gui). By doing this I free my mind to think while the software run automatically, instead of being woried of clicking, writing , selecting, expanding, double clicking, hundred and hundred of times.
Maybe this topic can be seem as trivial of no relevant for a post. But want I wanted to remark, is how easy Python + Leo allowed me to do such important things with no pain.

Leo is great, but as depicted there are many excellent and important things to do, and 2004 will be a very exiting year. My personal vote is for a better usage of the messages bar, to provide jed/emacs like capabilities (specially search and replace, commands execution). This is probably part of the long waited new key binding feature.

Back to LeoN.

During the last week (since end of november) a lot of things have been done:

- Full clones support
- Admin Gui
- Twisted 1.1 upgrade
- Leo4.1 upgrade
- Outlines upload/download
- Better server and client test units
- unicode support, nodes with '/' char in the name support
- lot of unmemored minor code and user side enhancenment
- documentation (never a minor issue)
- updated the webpage
- released 0.1.0

That is good, but there still various very important things to do,

- solve the garbage collector issues
- need better concurrenteditable test, need rock hard code
- new server side id paths ideas (what a good idea, I knew it should arive)
- solve asperities (huge todo list)
- more unittest (client side) (will try but do not promise)
- analyse the development as a valid and viable problem solver. If no problem is solved this work is a non sense.
- solve the reported bugs
- step 1 integration.

It is weird to observe that the long time ago defined step1,2,3,4; now have steps2,3 and 4 passed but step1 is missing.
I think that this topic will (and should) take relevance in the next week. Specially considering that the interesant work of the "non sentinel files" is somewhat related.

Was you can see in the web page (and in the readme file), LeoN 0.1.0 provide, in alpha stage, the following features.

- Easy and confortable integration with the Leo editor
- Full clones support, full unicode support
- Allow download/upload Leo outline from/to the server (thus direct internet outlines sharing)
- Direct publication of the outlines via web
- Basic server side persistence of the outlines
- Chat service for Leo clients connected in the outline (per server, per node, and to individual user messages) 
- Concurrent non-protected outline edition
- Concurrent edition of nodes content, allow more than a user to edit a node at the same time over the same version
- Administration system to manage access and permissions over the outlines/nodes
- Full crossplatform (herited from python, leo and twisted)

That list covert almost every mentioned feature in the design round (or at least every feature that I recopiled as relevant), only "outline merging" is missing, but that is step1.

Unfortunatelly is somewhat difficult to test and collaboration tool, in particular if it is being coded by a one person team. I only had ocasion to do incipient tests it alone in a LAN network (during the expo I found some bugs, but could not do 'formal' tests).
So I would thank to receive help, at least in the testing of the code, and ideally at the development level, both about coding and design.

The intention of this release is to allow more people to introduce them in the LeoN project, I expect feedback, bugs report, constructive critics, and collaboration offers. But all of this will depend of the Leo community interest, and very specially of the application they can found and the difficulties they can see that LeoN solve.

On the personal aspect I think that the Concurrent Edition feature is what I always wanted to create reports in a team. Allowing to have persons writing and at the same time persons reviewing and correcting the already wrote text. Integrated to Leo is see a more flexible and a bigger applications range.

As a last comment I would mention that we should be aware that LeoN test/development/usage will require new habits in the Leo community, probably access to some servers, more realtime interaction, and the longitude will start to be relevant. There are differences in developing desktop applications and network applications (but each one has they special pleasures/inconvenients).

End of message.

Happy new year ! 
propaganda: I believe that happiness, joy and internal peace can be the result of your actions, do not wait for luck, seek your desires.

RodrigoB.

P.S.: linux users, I recommend to take a look at another great open source project http://thecircle.org.au</t>
<t tx="rodrigob.121403173614.1321">@nocolor

31/05/03 First log. RodrigoB.
04/08/03 Release LeoN '0**0'. RodrigoB.
02/01/04 Release LeoN 0.1.0 alpha. RodrigoB.

12/01/04 Changed 'range' by 'xrange' usage (better memory usage). RodrigoB.
13/01/04 Attacking the HB garbage collector issue. Patching start_server.bat . RodrigoB &amp; Grayrest.
19/01/04 Solved the HB garbage collector conceptual issues. Starting implementation. RodrigoB.
21/01/04 Working. Garbage collector non trivial bug found. RodrigoB.
22/01/04 Solved the GC bug. Working. RodrigoB.
25/01/04 Reimplemented the start/stop_LeoServer files. Minor edit at fill_body. RodrigoB.
28/01/04 Doing some GC tests, debuging. RodrigoB.

24/08/04 Separating Chalks from LeoN. LeoN has died, long live to Chalks !. RodrigoB.
??/0?/04 Working. RodrigoB &amp; RicardoN. Logs are keept in the svn server.


/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\

@color
@language python
@path ./src/

</t>
<t tx="rodrigob.121403173614.1412">&lt;html&gt;
&lt;head&gt;
&lt;style typ="text/css"&gt;

body
{
    font: Helvetica;
    background-color: yellow;
}


.Node
{
    background-color: green;
}

&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;hello world!&lt;/p&gt;
&lt;div class="Node"&gt;
    &lt;p&gt;hello girls!&lt;/p&gt;
&lt;/div&gt;
&lt;table height="100%" border="1"&gt;
    &lt;tr valign="bottom"&gt;&lt;td&gt;_bottom_&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
    
&lt;p&gt;more text&lt;/p&gt;

&lt;table border="1"&gt;
&lt;tr&gt;&lt;td&gt; anothert table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</t>
<t tx="rodrigob.121403173614.1506">@
To understand the ConcurrentEditable code you will have to read the works of Chengzheng Sun.
(http://www.researchindex.com sun98achieving.pdf and related files)

This is a very short explication of the main concepts behind the algorithm, to have the big pictures while reading the papers.

Big picture (of base implementation: ConcurrentEditable)
-----------

There is a concurrent editable object that receive commands  (operations to realize) associated with the State Vector of the emisor.

The received command are 'received and delayed to preserve causality' or 'executed'.

When executed an undo/transform-do/transform-redo scheme is used.

The transformation of commands (operational transforms) is realized by the GOT algorithm.

The GOT algorithm use two application specific transformation functions IT, ET (inclusion and exclusion transform, respectively).

Tadaaa...
@c
</t>
<t tx="rodrigob.121403173614.1509">class ConcurrentEditable:
    """
    This is the core class.
    It instanciate a Site that contain an editable text.
    Will receive and generate operations.
    The implementation is focused on simplicity and paper similarities.
    """
    
    def __init__(self, site_index, num_of_sites):
        """
        if site_index == None then the site is and Observer
        """
                       
        self.site_index   = site_index
        self.state_vector = [0] * num_of_sites
                
        self.state_vector_table   = [[0]* num_of_sites]* num_of_sites # required by the garbage collector (SVT)
        self.minimum_state_vector = [0]*num_of_sites # required by the garbage collector (MSV)

        if self.site_index != None:
            self.state_vector_table [self.site_index] = self.state_vector # link with local state_vector
  
        self.HB = [] # history buffer
        self.delayed_operations = [] 

        self.text_buffer = ""
        
        
    def get_text(self):
        """
        """
        
        return self.text_buffer


    @others
    

</t>
<t tx="rodrigob.121403173614.1510">def receive_operation(self, t_op, *args, **kw):
    """
    can receive operations receiving an Operation object, or being called as : (type, pos, data, {extra args}) 
    receive an operation to execute
    check if it is causally ready
    if not delay it
    else execute it
    if executed check the delayed buffer to check for operation that now can be operated (and so on until no operation is executable)
    ---
    The workflow is receive-&gt;apply-&gt;execute
    """

    if not isinstance(t_op, Operation):
        try:
            assert len(args) == 2
            t_op = Operation(t_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(t_op, args, kw)
            
    # receive an operation to execute
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; receiving %s"%(self.site_index, self.state_vector, self.get_text(), t_op)

    
    if is_causally_ready(t_op, self): 		# check if it is causally ready
        self.apply(t_op) # execute it (apply to local buffer)
            
        # if executed check the delayed buffer to check for operation that now can be operated
        # (and so on until no operation is executable)			
        
        while 1: # uhhh, dangerous
            for tt_op in self.delayed_operations:
                if is_causally_ready(tt_op, self): 
                    self.apply(tt_op) 
                    self.delayed_operations.remove(tt_op)
                    break # break the 'for'; go back to 'while 1'
            break # end of while 1

    else: # if not delay it
        self.delayed_operations.append(t_op)
    
    if dbg &gt;=1:
        print "Site %s; HB %s"%(self.site_index, self.HB)
        print "Site %s;%s; '%s'; delayed_ops: %s\n"%(self.site_index, self.state_vector, self.get_text(), self.delayed_operations)

            
    return

receive_op = receive_operation # alias
    
</t>
<t tx="rodrigob.121403173614.1511">def apply(self, Onew):
    """
    Algorithm 3: The undo/transform-do/transform-redo scheme (sun98generic)
    
    Given a new causally-ready operation Onew , and HB = [EO1,..., EOm,..., EOn ], the following steps are executed:
    
    1. Undo operations in HB from right to left until an operation EOm is found such that EOm =&gt; Onew .
    2. Transform Onew into EOnew by applying the GOT control scheme. Then, do EOnew .
    3. Transform each operation EOm+i in HB[m+1,n] into the new execution form EO'm+i as follows:
        - EO'm+1 := IT (EOm+1, EOnew ).
        - For 2 &lt;= i &lt;= (n - m),
            (1) TO := LET (EOm+i, reverse(HB[m+1,m+i - 1]) );
            (2) EO'm+i := LIT (TO, [EOnew, EO'm+1,..., EO'm+i-1 ]).
        Then, redo EO'm+1, EO'm+2, ..., EO'n , sequentially.
    
    After the execution of the above steps, the contents of the history buffer becomes: HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    ---
    This function manage the History Buffer and update the State Vector Table.
    """
        
    assert T(Onew) in ["Insert", "Delete"], "Invalid operation request."
    
    if dbg &gt;=1:
        print "Site %s;%s; '%s'; applying %s"%(self.site_index, self.state_vector, self.get_text(), Onew)


    HB = self.HB

    # 1.
    m = 0 # manage the case HB == []
    undoed = []
    for m in xrange(len(HB) -1, 0 -1, -1):	 # from right to left
        EOm = HB[m]
        #print "check_total_ordering(%s, %s) =&gt; %i"%(EOm, Onew, check_total_ordering(EOm, Onew)) # just for debugging
        if not check_total_ordering(EOm, Onew):
            self.undo(EOm)
            # operations do should not be erased from HB, because they will later be transformed !
            undoed.append(EOm)
        else:
            break
        
    if HB and len(undoed) == len(HB):
        if dbg&gt;=2:
            print "No previous op found !"
        m = -1 # to indicate that no previous op was found

    # 2.
    EOnew = GOT( Onew, HB[:m+1]) # pass Onew and HB = [EO1, EO2, ..., EOm ]
    self.execute(EOnew)
    # EOnew will be inserted after step 3 to follow better the paper notation.
    if dbg&gt;=2:
        print "m %i; [EO1, ..., EOm ] %s; HB[m+1:] %s"%(m,  HB[:m+1],  HB[m+1:])

    
    # 3.
    if undoed: # if there was an undo, then redo
        if dbg&gt;=1:
            print "Site %s; '%s'; undoed %s; executed %s;"%(self.site_index, self.get_text(), undoed, EOnew) # just for debugging
        EOoL = [] # EO'm+1 List

        EOoL.append( IT( HB[m+1], EOnew ) ) 
        for i in xrange(1, len(undoed)):  # python indexes start from 'zero' (in the paper they start from 'one')
            TO = LET( HB[m+1+i], reverse(HB[m+1: m+i +1])) # paper [m+1,m+i - 1] -&gt; python [m+1:m+i +1]
            EOoL.append( LIT( TO, [EOnew] + EOoL) )

        #print "m: %i; len(EOoL) %i;EOoL %s"%(m, len(EOoL), EOoL) # just for debugging
        for i in xrange(len(EOoL)):			
            t_op = EOoL[i]
            self.execute(t_op)
            HB[m+1+i] = t_op # python indexes start from 'zero'


    # After the execution of the above steps [...] HB = [EO1,..., EOm, EOnew, EO'm+1,..., EO'n ].
    HB.insert(m + 1, EOnew) # insert into the HB, just after EOm
        
        
    # Update local State vector
    t_index = Onew["source_site"]
    assert t_index &lt; len(self.state_vector), "Received an operation from a source_site outside the state_vector range"
    self.state_vector[t_index] += 1
    
    # Update the State Vector Table (what we know about the status of each site, including ourself)
    self.state_vector_table[EOnew["source_site"]] = list(EOnew["timestamp"]) # update state_vector_table (via a list copy)

    if (len(HB) % 10) == 0: # call the garbage collector (over a dummy periodic condition)
        self.collect_garbage()

    return
</t>
<t tx="rodrigob.121403173614.1512">def execute(self, EO, splitted_part=0):
    """
    Modify the text buffer.
    The lost information is stored into the operators for future undos.
    """
    
    if EO.get("is_splitted"):
        self.execute(EO["splitted_head"], splitted_part=1)
        self.execute(EO["splitted_tail"], splitted_part=1)
        return
        
    startpos = P(EO)
    data     = EO["data"]
    
    if T(EO) == "Insert":
        self.insert_text(startpos, data, op=EO)
        
    elif T(EO) == "Delete":
        self.delete_text(startpos, data, op=EO)
    else:
        raise " Tried to execute an Unmanaged Operation type"
        
    return
    
redo = execute # alias</t>
<t tx="rodrigob.121403173614.1513">def insert_text(self, startpos, data, op=None):
    """
    the op argument is used to obtain extra information in some specific posible implementations
    """
        
    self.text_buffer = self.text_buffer[:startpos] + data + self.text_buffer[startpos:]
    
    return
</t>
<t tx="rodrigob.121403173614.1514">def delete_text(self, startpos, length, op=None):
    """
    the op argument is used to obtain extra information in some specific posible implementations
    It is necessary to store there some undo information.
    """
    
    t_text = self.text_buffer
    op["deleted_text"] = t_text[startpos:(startpos+length)]
    self.text_buffer = ''.join(t_text[:startpos] + t_text[(startpos+length):])	
        
    return</t>
<t tx="rodrigob.121403173614.1515">def undo(self, EO):
    """
    Undo an operation. Return the text to his previous state.
    The undo operation supose that EO is the last operation executed over the buffer.
    """
    
    if EO.get("is_splitted"):
        self.undo(EO["splitted_head"])
        self.undo(EO["splitted_tail"])
        return

    if T(EO) == "Delete":
        assert EO.has_key("deleted_text"), "Undoable operation (no undo info stored)"
        self.execute( op("Insert", P(EO), EO["deleted_text"]) ) # create the undo operation and execute it
        
    elif T(EO) == "Insert":
        self.execute( op("Delete", P(EO), len(S(EO)) ) ) # create the undo operation and execute it
        
    else:
        raise "Trying to undo an Unmanaged Operation."
    
    
    return

</t>
<t tx="rodrigob.121403173614.1516">def collect_garbage(self):
    """
    Algorithm 4. The garbage collection procedure. sun98achieving (page 18, 19, 20).
    Scan HB from left to right. Let EO be the current operation under inspection.
    Suppose that EO was generated at site i and timestamped by SVEO.
        (1) If SVEO [i] &lt;= MSVk[i], then EO is removed from HB and continue scanning.
        (2) Otherwise stop scanning and return.
        
    (The garbage collection procedure can be invoked periodically, or after processing each remote operation/message, or when the number of buffered operations in HB goes beyond a preset threshold value.)
    """
            
    #dbg = 1 # just for debugging
        
    # reference asignations (local aliases)
    HB  = self.HB 
    SVT = self.state_vector_table
    MSV = self.minimum_state_vector

    if dbg&gt;=1:
        print "Site %s; before garbage collector; HB %s"%(self.site_index, map(lambda x: "{from S%i%s}"%(x["source_site"], x["timestamp"]) , HB))
    
    # compute the MSV
    for i in xrange(len(MSV)):
        MSV[i] = min( [ sv[i] for sv in SVT ] )
    
    if dbg &gt;=1:
        print "Site %s; garbage collector; MSV %s; SVT %s;"%(self.site_index, MSV, SVT)
        
    # collect the garbage
    deleted_operations_list = []
    for EO in list(HB): # iterate over a copy of HB (to be able to mutate HB will iterating over it)
        i    = EO["source_site"]
        SVEO = EO["timestamp"]

        if dbg&gt;=1:
            print "Site %s; garbage collector; EO %s; i %i; %s &lt;=? %s"%(self.site_index, EO, i,  SVEO[i], MSV[i])
        
        condition = SVEO[i] &lt;= MSV[i]
            
        if condition:
            deleted_operations_list.append(Operation(**EO)) # append to the list a copy of the operation
            HB.remove(EO) 
            if dbg&gt;=1:
                print "Site %s; garbage collector; removing %s"%(self.site_index, EO)

        else:
            break # stop scanning HB
            
    if dbg&gt;=1:
        print "Site %s; after garbage collector; HB %s"%(self.site_index, map(lambda x: "{from S%i%s}"%(x["source_site"], x["timestamp"]) , HB))
        
    return deleted_operations_list
</t>
<t tx="rodrigob.121403173614.1517">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    
    t_SV = list(self.state_vector) # copy the list
    t_SV[self.site_index] += 1
    
    t_op = Operation(type, pos, data, t_SV, self.site_index)
    
    for k in kws.keys():
        t_op[k] = kws[k]
        
    if dbg&gt;=1:
        print "Site %s; generating %s"%(self.site_index, t_op)
    
    self.receive_op(t_op)
    
    return t_op

def gen_op(self, type, pos, data, **kws):
    """
    Alias of generate_operation.
    """
    return self.generate_operation(type, pos, data, **kws)
    
    
def gen_Op(self, type, data, pos, **kws):
    """
    Alias with another parameters order.
    """
    
    return self.gen_op(type, pos, data, **kws)
</t>
<t tx="rodrigob.121403173614.1547">@
The unit tests for concurrent editions.
@c


def get_test_suite():
    """
    run the tests
    """
    
    global dbg
    dbg = 0
    
    import unittest
    TestSuite = unittest.TestSuite()
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable1))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditable2))
    TestSuite.addTest(unittest.FunctionTestCase(TestConcurrentEditableServer))
        
    return TestSuite
</t>
<t tx="rodrigob.121403173614.1548">
def TestConcurrentEditable1():
    """
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Delete 1 2
        - O4 Insert 2 "c"
    So the final result should be "ABCcD" in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable1 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2") # test the alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Insert", 2, u"c", dbg_name="O4") 
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage() # at site2 two operations should be deleted
    

    
    if dbg&gt;=0:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;MSV %s;\nHB\n\t%s\n"%(t_site.site_index, t_site.state_vector, t_site.minimum_state_vector, "\n\t".join([str(x) for x in t_site.HB]))
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == u"ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success

</t>
<t tx="rodrigob.121403173614.1549">
def TestConcurrentEditable2():
    """
    Second test is similar to Test1 but with other operations. Try to test other code areas (i.e. Lost Information cases)
    
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Insert 5 "c"
        - O4 Delete 0 3
    So the final result should be ABCc in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable2 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2") # test alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Insert", 5, u"c", dbg_name="O4")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
    
    if dbg&gt;=0:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;MSV %s;\nHB\n\t%s\n"%(t_site.site_index, t_site.state_vector, t_site.minimum_state_vector, "\n\t".join([str(x) for x in t_site.HB]))

    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == u"ABCc" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCc', and no delayed operations left in the buffer."


    return success
</t>
<t tx="rodrigob.121403173614.1550">def TestConcurrentEditableServer():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a Star network; with one central server and three clients connecting to it.
    """
    
    #global dbg
    #dbg = 0 #1 # ;P
    
    # when dbg==1 this is a __very__ verbose test, but it allow a good tracking of every event.
    
    print "-"*15
    print "Read docstring of TestConcurrentEditableServer for more info about this test.\n"
    
    # creates server
    server = ConcurrentEditableServer()
    
    # connect site 0 and 1
    site0 = ConcurrentEditableClient(server)
    site1 = ConcurrentEditableClient(server)
    
    global sent_test_operations; 	sent_test_operations = [] # used for delaying the transmissions in the test
    
    # start editions
    # Apply the operations in each site (following the order of the picture)
    O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1", gen_site="0") # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2", gen_site="1") # test the alias

    # O*_toS* is an operation that was sent by the server to the client. This object is delayed to simulate delays in the transmissions lines.
    # the order of reception of commands is similar of the TestConcurrentEditable1
    server.receive_op(O2); 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O2_toS0] = sent_test_operations; sent_test_operations = []	
    server.receive_operation(O1);
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O1_toS1] = sent_test_operations; sent_test_operations = []	
    
    # connect site 2 (to test connection during sessions)
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    
    if dbg&gt;=1:
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    sent_test_operations = []
    
    # continue editions
    site1.receive_op(O1_toS1) # receive delayed operations sent by the server
    site0.receive_op(O2_toS0)
    O4 = site2.gen_op("Insert", 2, u"c", dbg_name="O4", gen_site="2") 
    server.receive_op(O4); O4_toS0, O4_toS1 = sent_test_operations; 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    sent_test_operations = []	

    
    # test disconnection and site_index reusage (for reconnetion connection)
    if dbg&gt;=1: 
        print "\nDisconnectiong S2"
        
    server.del_client(site2)	
    if dbg&gt;=1: print "\nReconnection S2"
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    if dbg&gt;=1: 
        print "Site2 after reconnecting"
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    site0.receive_op(O4_toS0)
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3", gen_site="1")
    server.receive_op(O3);	
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    O3_toS0, O3_toS2 = sent_test_operations; sent_test_operations = []	
    site2.receive_op(O3_toS2)
    site0.receive_op(O3_toS0)
    site1.receive_op(O4_toS1)
    
    # Original sequence------------------
    #O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1")  # generate and apply locally the operation
    #O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2") # test alias
    #site2.receive_op(O2)
    #site1.receive_op(O1)
    #site0.receive_op(O2)
    #O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    #site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    #O3 = site1.gen_op("Insert", 5, u"c", dbg_name="O4")
    #site2.receive_op(O3)
    #site0.receive_op(O3)
    #site1.receive_op(O4)			
    #site2.receive_op(O1)
    # ------------------

    if dbg&gt;=1:	
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
        
    
    if dbg&gt;=1:
        print "\nDirty HBs"
        for t_site in [server, site0, site1, site2]:
            print "Site %s;%s;HB %s; delayed_ops %s"%(t_site.site_index, t_site.state_vector, t_site.HB, t_site.delayed_operations)
        print
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)
        if dbg&gt;=1: print "Manually collecting the garbage in all sites"
        server.collect_garbage()
        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    # --------	
    # disconnect
    if dbg&gt;=1: print "Disconnecting the three sites."
    server.del_client(site0)	
    server.del_client(site1)	
    server.del_client(site2)	
    # --------------
        
    if dbg&gt;=0:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;MSV %s;\nHB\n\t%s\n"%(t_site.site_index, t_site.state_vector, t_site.minimum_state_vector, "\n\t".join([str(x) for x in t_site.HB]))
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [server, site0, site1, site2]:
        t_res = (t_site.get_text() == u"AcBCD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'AcBCD', and no delayed operations left in the buffer."


    return success</t>
<t tx="rodrigob.122203065507">25/12/2003
if file clonning is safe double message should be avoied

Clonned @file repeated messages

One of the core features of Leo is the clonning capabilty. When I clone a @file node, at saving the "writing/unchanged: filename.py" message appears two times (as many times as clones existing). As Leo saves only the dirty files, there is no overusage of the disk, but I think that the repeated messages are anoying. 
It look simple to avoid message repeating and to send one message per file, not per cloned @file node, I suppose this would also speed the "save" command (keeping a list of already flushed files).

So this is a feature request, to enhance the clones usability.

RodrigoB.</t>
<t tx="rodrigob.122403095223">25/12/2003
can not open: /usr/local/leo/leo-4.1rc1/src/dev/LeoNtest.leo

@url and @path relative path discordance

If I write @path ./dev/ then files are stored in a path relative to the open .leo file
If I write @url file:./dev/somthing.leo then Leo try to open the file relative to the Leo installation path.

I think this discordance show aa bug in the @url file: management.

RodrigoB.</t>
<t tx="rodrigob.122403125851"></t>
<t tx="rodrigob.122403134052">
# (should check which overwritten text was already sent)
# and should create a sequence of deletion operations


# need to define the lists:
#	- text_deletion_ranges
#   - to_send_deletion_ranges

# has as input:
#   - old_to_send_ranges
#   - old_sel

from Tkinter import *

root = Tk()
text   = Text(root)
#text.insert("1.0", "a"*20 + '\n' + "b" * 30) # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; has to test with and without this line &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.2","1.8","1.10","2.5")


def index_to_list(val):
	return map(int, val.split("."))
    
def list_to_index(val):
	return "%i.%i"%tuple(val)


@others


# run some tests	
old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.2","1.8","1.10","2.5")
test(old_sel, old_to_send_ranges)


old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.8","1.10")
test(old_sel, old_to_send_ranges)

old_sel=["1.12", "1.15"]
old_to_send_ranges = ("1.2","1.8", "1.10","2.5", "2.8", "2.20")
test(old_sel, old_to_send_ranges)



old_sel=["1.6", "2.3"]
old_to_send_ranges = ("1.8","1.10", "1.20", "2.15")
test(old_sel, old_to_send_ranges)

</t>
<t tx="rodrigob.122403134052.1">def test(old_sel, old_to_send_ranges):
	print "old_sel", old_sel
	print "old_to_send_ranges", old_to_send_ranges
	
	
	
	
	old_sel =	map(index_to_list, old_sel)
	ranges =	old_to_send_ranges
	t_ranges = [] # will keep the list of to_send ranges that are embedded in the old_sel range.
	
	# first we prune the to_send_ranges to get only the ranges of interest
	
	for i in range(0, len(ranges), 2):	
		start  = index_to_list(ranges[i])
		stop   = index_to_list(ranges[i+1])
		# search the initial range
		
		if start &gt;= old_sel[0]: # found the initial range
			break # lets continue with a new logic
		elif  stop &gt;= old_sel[0]:
			t_ranges.append(old_sel[0])
			t_ranges.append(min(stop, old_sel[1]))
			i += 2
			break
		else:
			continue

	for i in range(i, len(ranges), 2):	# starting from last point
		start  = index_to_list(ranges[i])
		stop   = index_to_list(ranges[i+1])	
		
		if start &lt;= old_sel[1]: 
			t_ranges.append(start)
		else:
			break # job finished
			
		if stop &lt;= old_sel[1]:
			t_ranges.append(stop)
		else:
			t_ranges.append(old_sel[1])
			break # job finished
		
	
	to_send_deletion_ranges = map(list_to_index, t_ranges)
	text_deletion_ranges    = []
	
	print "to_send_deletion_ranges", to_send_deletion_ranges
	print "text_deletion_ranges", text_deletion_ranges
	print
	return
</t>
<t tx="rodrigob.122403141113">25/12/2003
Change, Then Find error

I checked the rc2 code and it does not seems to patch this bug,

When I use the find command to search and replace and headline text,  the "change, then find" buttom does not work.
The traceback look like a reorg simple bug...

[rodrigob@localhost dev]$ Exception in Tkinter callback
Traceback (most recent call last):
  File "/usr/local/lib/python2.3/lib-tk/Tkinter.py", line 1345,  in __call__
    return self.func(*args)
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 159, in  changeThenFindButton
    self.changeThenFind()
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 431, in  changeThenFind
    if self.changeSelection():
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 417, in  changeSelection
    c.frame.idle_head_key(v)
AttributeError: leoTkinterFrame instance has no attribute 'idle _head_key'
Exception in Tkinter callback
Traceback (most recent call last):
  File "/usr/local/lib/python2.3/lib-tk/Tkinter.py", line 1345,  in __call__
    return self.func(*args)
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 159, in  changeThenFindButton
    self.changeThenFind()
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 431, in  changeThenFind
    if self.changeSelection():
  File "/usr/local/leo/leo-4.1rc1/src/leoFind.py", line 417, in  changeSelection
    c.frame.idle_head_key(v)
AttributeError: leoTkinterFrame instance has no attribute 'idle _head_key'

should it be c.frame.tree.idle_head_key ?

RodrigoB.</t>
<t tx="rodrigob.122403141856">25/12/2003
Leo Freeze on big outlines copy

This looks like a long running issue. When I try to copy the root node of my projects, the program freeze. It seems to be a problem with big outlines copy. 

Why does Leo freeze when copying big outlines ? , I thinked that this operation should take a time similar to the save to disk, as the copyied text buffer contain a leo xml file ...

This issue is somewhat problematic. 

RodrigoB.

</t>
<t tx="rodrigob.122403213028">@
LeoN version 0.1.0 alpha, "Feux d'artifice".
LeoN project. Leo over Network.
Rodrigo Benenson 2003, 2004. &lt;rodrigo_b at users dot sourceforge dot net&gt;
http://souvenirs.sf.net, http://leo.sf.net.

The collaborative editing code is based research papers of Chengzheng Sun.

This code is released under GNU GPL.
The license is aviable at 'LeoN.leo/LeoN/Docs/GNU GPL' or in the web http://www.gnu.org .

---
This file is part of LeoN.

LeoN is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

LeoN is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeoN; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
---
@c</t>
<t tx="rodrigob.122403220526">This nodes are supposed to be read by the curious users.</t>
<t tx="rodrigob.122403220526.1">@language plain
@nocolor

These nodes are supposed to be read by curious hackers and by people interested in understanding Chalks internals (and probably help with development)

Chalks docs make some references to the excellent Twisted Documentation, which can be found at the http://www.twistedmatrix.com webpage.

The code and this outline contain many (hopefully useful) comments. Look at the related code perspectives and code sections to get more low level details (as usual).</t>
<t tx="rodrigob.122403220526.2"></t>
<t tx="rodrigob.122503213200">if there is no plugin using the toolbar, the toolbar should not appeard at all, it is a non sense anoyance

Empty toolbar

This is also a feature request for Leo4.1. If no plugin use the Leo4.x toolbar feature, the empty toolbar still there. This window space loose is an unecesarry anoyance. Tk alow "dinamic" windows, and if no plugin insert any sub widget to the toolbar, this one should be "erased".
It is not diffucult at all, but I don't which is the better mechanism to detect if the toolbar is empty or not...

RodrigoB.</t>
<t tx="rodrigob.122703165736"></t>
<t tx="rodrigob.122803215625">28/12/03
If the user delete some chars and then continue to write text, the cloned twin does not follow the step. When deleting chars the twin do not delete hims. Funny weirdness.</t>
<t tx="rodrigob.122903205815">pb.error management is defined in /twisted/examples/pbecho.py and pbechoclient.py

Server Side need to raise or create only and only LeoErrors
Client side can do anything it want. errCallback has to be only one, and he can trap/manage different kind of error.</t>
<t tx="rodrigob.123003164537">If an error is raised with an unicode string, pb get a crash

Traceback (most recent call last):
  File "/usr/local/lib/python2.3/site-packages/twisted/internet/default.py", line 507, in doSelect
    _logrun(selectable, _drdw, selectable, method, dict)
  File "/usr/local/lib/python2.3/site-packages/twisted/python/log.py", line 65, in callWithLogger
    callWithContext({"system": lp}, func, *args, **kw)
  File "/usr/local/lib/python2.3/site-packages/twisted/python/log.py", line 52, in callWithContext
    return context.call({ILogContext: newCtx}, func, *args, **kw)
  File "/usr/local/lib/python2.3/site-packages/twisted/python/context.py", line 32, in callWithContext
    return func(*args,**kw)
--- &lt;exception caught here&gt; ---
  File "/usr/local/lib/python2.3/site-packages/twisted/internet/default.py", line 516, in _doReadOrWrite
    why = getattr(selectable, method)()
  File "/usr/local/lib/python2.3/site-packages/twisted/internet/tcp.py", line 250, in doRead
    return self.protocol.dataReceived(data)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/banana.py", line 320, in dataReceived
    processed = cBanana.dataReceived(self.state, buffer, self.callExpressionReceived)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/banana.py", line 93, in callExpressionReceived
    self.expressionReceived(obj)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 568, in expressionReceived
    method(*sexp[1:])
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 879, in proto_message
    self._recvMessage(self.localObjectForID, requestID, objectID, message, answerRequired, netArgs, netKw)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 901, in _recvMessage
    self._sendError(f, requestID)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 949, in _sendError
    self.sendCall("error", requestID, self.serialize(fail))
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 816, in serialize
    return jelly(object, self.security, None, self)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/jelly.py", line 845, in jelly
    return _Jellier(taster, persistentStore, invoker).jelly(object)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/jelly.py", line 407, in jelly
    return obj.jellyFor(self)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/flavors.py", line 310, in jellyFor
    state = self.getStateToCopyFor(p)
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/flavors.py", line 278, in getStateToCopyFor
    return self.getStateToCopy()
  File "/usr/local/lib/python2.3/site-packages/twisted/spread/pb.py", line 469, in getStateToCopy
    state['value'] = str(self.value) # Exception instance
exceptions.UnicodeEncodeError: 'ascii' codec can't encode character u'\xe8' in position 60: ordinal not in range(128)
</t>
<t tx="rodrigob.123103123839"></t>
<t tx="rodrigob.123103123958">Features
--------

- Easy and confortable integration with the Leo editor
- Server/Client architecture, ultra easy usage
- Full clones support, full unicode support
- Allow download/upload Leo outline from/to the server (thus direct internet outlines sharing)
- Direct publication of the outlines via web
- Basic server side persistence of the outlines
- Chat service for Leo clients connected in the outline
- Concurrent edition of nodes content, allow more than a user to edit a node at the same time over the same version
- Administration system to manage access and permissions over the outlines/nodes
- Full crossplatform (herited from python, leo and twisted)
</t>
<t tx="rodrigob.123103130342"></t>
<t tx="rodrigob.123103131341">05/08/03 Code review. Looking for ParagraphText. Web Parent link patched. RodrigoB.
06/08/03 The Paragraph problem was a Twisted bug. Working. RodrigoB.
07/08/03 Working on the Admin GUI. RodrigoB.
10/08/03 Minor work, broking code for ConcurrentEditable inclution. RodrigoB.
18/08/03 Minor work. Copying at UTFSM. Working, trying to make order in the salade. RodrigoB.
28/08/03 Minor work. RodrigoB.
30/08/03 Minor work. RodrigoB.
31/08/03 Working on the ConcurrentEditable merge. RodrigoB.
03/09/03 Working. RodrigoB.
04/09/03 Working. RodrigoB.
07/09/03 Working. RodrigoB.
08/09/03 Working. Reimplemented connect_to_server. RodrigoB.
11/09/03 Working. Changing the logic of text_widget editions, debugging. RodrigoB.
12/09/03 Debuging not detected errors in ConcurrentEditable, and other minors one. RodrigoB.
14/09/03 Minor work. RodrigoB.
16/09/03 Working. Better web debugging tools. RodrigoB.
18/09/03 Working. Stabilizing the app, preparing the demo. RodrigoB.
19/09/03 Working. Stabilizing the app, preparing the demo. RodrigoB.
20/09/03 Bugfix of delete_text. RodrigoB.
27/09/03 First show of LeoN. Working on new detected bugs. 
         Fixed the Ascii error in Operations representation. RodrigoB.
28/09/03 Thinking. Added definition and usage of "vnode.isOnline()". 
         Now disconnection from collaborating nodes is successfull. 
         Now during connection to collaborative node the initial action is omited. RodrigoB.
29/09/03 Finally using functomethod hook helper. Intercepting 	idle_body_key and OnBodyKey to install the oldTagsRanges. RodrigoB.
04/10/03 Working. Created delay lines emulation capabilites for better testings. 
         Studying some Leo internals. Reimplementing OnBodyKey2. 
05/10/03 Adding a presentable aspect to the web templates. Now Leo + LeoN shutdown is clean (intercepting finishQuit).
         Working at OnBodyKey2 reimplementation, working on the Present/Past problem. RodrigoB.
06/10/03 Working at OnBodyKey2 reimplementation. Unifying client.es usage. 
         Trying to solve the Woven unicode problem (unsuccessfull). Now flush_body does do inecessary delete/insert operations. RodrigoB.
07/10/03 Added title to the web template. Changed the source code encoding (now utf-8) to patch the unicode problems 
         (so woven manage it fine; send_operation encode to utf-8). Finishing the OnBodyKey2 reimplementation.
         Minor bug fix at connection/disconnection process. 
         Solving a non trivial GOTO Garbage Collector - Minimum State Vector - Connection issue. Introduced the base_state_vector element.
         Working hard to restore the actually broken system. RodrigoB.
08/10/03 Working hard to restore the actually broken system. Bugfixing fill_body. Detected the unicode tk_pos/string_len problem. 
         Now LeoN seems to be "monkey over keyboard" proof. "Muestra Elo 2003" preparatives. Solved the Windows chat bar problem. 
         Thinking about the unicode problems. RodrigoB.
09/10/03 Presenting LeoN at the "Muestra Elo 2003". RodrigoB.
10/10/03 Presenting LeoN at the "Muestra Elo 2003". RodrigoB.
1?/10/03 Posted the impressions and comments of the ET2003. RodrigoB.
16/10/03 Thinking about the unicode the problem, looking at the implementation of the next features (upload, download, clones).
         Translating back the web interface to english, minor enhancenment. Adding clients disconections into the test sequence. 
         Bugfixing. New screenshots post. RodrigoB.
17/10/03 Working on outline upload/download. RodrigoB.
04/11/03 Restored my computer, needed to reformat the disks. Still some days before going back to work. RodrigoB.
06/11/03 Working hard to get my pc alife again. Getting running again LeoN. ConcurrentEditable does not pass the tests. Fixed a minor concurrent editable bug. RodrigoB.
08/11/03 Cleaning up development directory. Studying Leo 4.1 and Twited 1.1. Working in the new_cred support. RodrigoB.
09/11/03 Working in the new_cred support. RodrigoB.
21/11/03 Got python2.3 working on the machine. Solving minor import errors. Starting LeoNtesting unittest reformating. RodrigoB.
22/11/03 Working. RodrigoB.
23/11/03 Obtained the method to test the deferred (twisted.trial.unittest.deferredResult). Working. RodrigoB.
25/11/03 Working. Conversion to newcred, new unittests, and clones support. Debugging. RodrigoB.
26/11/03 Working. Got unittest pass again, clones support on server side. Work on the admin interface gui. RodrigoB.
27/11/03 Working. Gui. Data upload/download. Backup. RodrigoB.
29/11/03 Implementing "find_upward_nodes". RodrigoB.
30/11/03 Working. Reimplementing the propagation system (defined node.base_node_of). 
         Changing nomanclature "reference_path" by "base_path". RodrigoB.
01/12/03 Working on move event propagation. Client side data_to_outline. RodrigoB.
02/12/03 Working. RodrigoB.
03/12/03 Working on client side. Basic usability now  re-aviable. RodrigoB.
04-06/12/03 Lost work. Ordering huge todo list. Start of Leo4.1 port. Fatal Leo crash. RodrigoB.
07/12/03 Creating a restored LeoN.leo outline. Reordering todo list. RodrigoB.
08/12/03 Implementing node scripts into LeoNtest.leo, for easier Client tests. 
         Implemented the new admin gui. Testing the admin gui. The Admin gui pass the base tests. RodrigoB.
12/12/03 Working on outline upload/download. Server side unittest, debugging. Testing client side. 
         Changed isinstance by type is. Installing Twisted 1.1.1. RodrigoB.
13/12/03 Debugging client side data_to_outline (Leo clones weirdness). Adding copy node hook. 
         Implementing node download, not ready. RodrigoB.
14/12/03 Working on outlines upload/download. Debugging. Outlines upload/download pass the base tests. RodrigoB.
16/12/03 Working. Debugging the logout system. No more import types. Thinking the unicode problem. 
         Cleaning up easy todo elements. Fixing Leo4.1 weirdenesses. Passed from 4.1b5 to 4.1rc1.
         Checking the outline operations code. Eliminated the dirty outline actions concept. RodrigoB &amp; EKR.
18/12/03 Minor work, debugging outline operations. RodrigoB.
19/12/03 Working. Minor usability enhancements. Minor hooks system clean up. Thinking the Unicode problem. RodrigoB.
22/12/03 Working. Restricted command execution over online nodes. Minor preprotection at node renaming.
         Unicode aha. (re)Implementing the unicode support. Unicode seems to work now, good. 
         Solving some remaining 4.1 port issues. Testing and code cleaning. RodrigoB.
23/12/03 Finishing outline events propagation, day 1. RodrigoB.
24/12/03 Finishing outline events propagation, day 2. Testing outline operations. Renaming LeoNtesting.py as LeoNtest.py.
         Updating LeoServer main to new twisted nomenclature, created LeoServer.tac, created the LeoNtest 'save_tap' option. RodrigoB.
25/12/03 Posted some leo bugs. Working in bugs hunting and bugs fixing, day 1. RodrigoB.
27/12/03 Working in bugs hunting and bugs fixing, day 2. RodrigoB.
28/12/03 Working in bugs hunting and bugs fixing, day 3. Base outline operations seems ok. RodrigoB.
29/12/03 Working in bugs hunting and bugs fixing, day 4. RodrigoB.
30/12/03 Adding unicode support to node headlines. Working in bugs hunting and bugs fixing, day 5. RodrigoB.
31/12/03 Updated the webpage. Documenting (day 1) and preparing release. Working in bugs hunting and bugs fixing, day 6. RodrigoB.
01/01/04 Documenting, day 2. RodrigoB.
02/01/04 Documenting, day 3, ready. Learned the software is developed, not "develloped". 
         Working in bugs hunting and bugs fixing, day 7. Release 0.1.0 . RodrigoB.</t>
<t tx="rodrigob.123103132025"></t>
<t tx="rodrigob.123103132025.1"></t>
<t tx="rodrigob.123103162446">1. How to install LeoN ?
------------------------

See the previous "Instalation" section, obviously LeoN has to be correctly installed. 

You should be able to run Leo 

$ leo

and see, after startup, in the message bar the text "Welcome to LeoN".
</t>
<t tx="rodrigob.123103162446.1">2. How to run a server ?
------------------------

LeoN is separated in two different elements the 'client' and the 'server'. The server is a must to use the system, normally there will be many (2-20) clients connected to one server. The 'server' is a program, just like Leo, but it run as a 'daemon', that is, in the background.

The 'server' files of LeoN can be found in the directory "leon_server". 
There you will find some *.bat, *.sh files, as well as a *.tac and *.tap file.

Twisted make very easy creating and using servers.

For starters the release provide a ready-to-use server.  
Run the command "start_LeoServer.sh" (or "start_LeoServer.bat" if using windows) to start a server with some dummy default contents. 
Normally nothing should happen, now the server is running in the background, providing services in the port 8787 and 8788.

&gt;&gt;&gt; to run a server use the script "start_LeoServer", port 8787 will provide a LeoServer and 8788 a Web server. &lt;&lt;&lt;

Open a web navigator and look at the url "http://localhost:8788", if a page appear, congratulations your server is running !
At this web page you will be able to see the contents of the server outlines and who is editing it.

At the end of the server it will automagically store all his data in the .tap file, in order to restore his content when running it again latter. The server can be turned off using the stop_LeoServer.sh command (in windows you will to manually kill the process).

The default server include accounts for 'user1', 'user2' and 'admin_user'.

Now that you have your LeoServer running, look at the next section to learn how to use Leo with the LeoN plugin.

IMPORTANT: if your going to use LeoN between various computer in a LAN make sure that the firewalls of the network allow TCP transactions in the ports 8787 and 8788.

2.1 Advanced users 
------------------

All the magics of server daemonizing, logging and persistence is made by Twisted.
The shell scripts call the program "twistd", look at the Twisted documentation for more information about it.

The '.tap' file is a "twisted application pickle".
The '.tac' file is a "twisted application configuration" file, and will allow you to create new empty '.tap' files (look inside it for more information).

Both '.tap' and '.tac' files are executed using the "twistd" command (twisted daemon).

Respect of the web publishing, the "templates" directory contain two '.xhtml' files that define the esthetics (not the contents) of the web pages published, that files can be edited and the changes will be apreciable at the next page reload (does not require server restart). Then, you can edit that files to make the webpages look just like you like.    </t>
<t tx="rodrigob.123103162446.2">3. How to connect to a server ?
-------------------------------

3.1 @leoServer nodes
--------------------

This is when the funny start !
At this point we expect that you have already installed the plugin with success, made run the LeoServer with success too. 
The server has to be running in order to be able to connect to it.

The LeoN plugin provide the definition for a new kind of node, with node name starting with "@leoServer".
LeoN expect to find the following notation for that nodes, 

@leoServer &lt;dnsname or ip&gt;:&lt;port&gt;:&lt;path&gt;

or

@leoServer &lt;dnsname or ip&gt;:&lt;path&gt;

if no port is indicated, the default port is 8787.
If you are running a LeoServer on the local machine then you should create a node named

@leoServer localhost:8787:/

The @leoServer nodes define the machine and port to connect, a at which remote server node access. '/' is the root nodes, but you could login directly into a known subnodes. Depending on the administrator LeoServer configuration, you will not be able to connect at the root node, and you will be forced to connect directly into a project subnode (example "@leoServer the_server:/your_project").

The @leoServer node headline answer the "where ?" but the "who ?" is missing. The LeoN plugin will expect that the @leoServer nodes will contain in his *body* the "@login" directive (if not found an error is connected).
That directive use the following notation

@login &lt;name&gt;:&lt;password&gt;

Thus the "@login" directive indicate your authentification at the connection.

Once a "@leoServer" node is correctly defined a simple double click over the node icon (not over the headline, over the icon) will initiate the connection procedure to the server, after some seconds a new remote outline will appear.

&gt;&gt;&gt; to connect to a @leoServer node you have to doubleclick over this icon. Look at the example file "LeoNtest.leo".&lt;&lt;&lt;

You will find the "leon_plugin/LeoN/LeoNtest.leo" outline, which include a "@leoServer" node with the username and password of the predefined user named "user1" (password "pass1"). A simple double click over that node icon (the icon, not the headline) will connect the you to the local running server.


3.2 After connection
--------------------

After connection, if everything go fine two things should happen,
- a new suboutline should appear, corresponding to the server content at that path,
- in the log pane a char bar should appear. 

The chat bar allow you to send messages to the persons in the room, the editions to the outline will be propagated to the server and to the related online clients, and at the first edition of the body of an online node, you will automatically enter in the collaborative mode (loosing the first edition). The change to the collaborative mode could take some seconds, please be patient.

If you are using a local machine server, with your web navigator visit the site "http://localhost:8788" to see server outline published via web.

This kind of features become interesant when more than one persons are intereseted for the same outline.

More documentation can be found in the "LeoN.leo" file.
</t>
<t tx="rodrigob.123103162446.3">4. Panoramas
------------

This alpha release provides to you some interesant panoramas:

- Various users play

  Run a server, install various clients in your LAN and play with your friends creating some test outlines and editing the content. 
  You can see how the outline is directly published in the port 8788 of you server machine.

- Code Lecture

  The file LeoN.leo contain all the code and his documentation. Interested hackers should start to take a look there.

- Test Bed

  The file "LeoNtest.py" is the test bed for LeoN (specially concurrent editable and server elements), look at "LeoNtest.py -h" to see his usage.

</t>
<t tx="rodrigob.123103165427">		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    &lt;one line to give the program's name and a brief idea of what it does.&gt;
    Copyright (C) &lt;year&gt;  &lt;name of author&gt;

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  &lt;signature of Ty Coon&gt;, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
</t>
<t tx="rodrigob.123103172351">copy do not paste in Leo Find/Change panel


On Linux, if you copy some leo headline or body text, and try to paste it in the Find/Change panel (as a string to search), it does not work.

I suspect the problem is due that Ctrl+V (paste) is not define in the Find panel.

RodrigoB.</t>
<t tx="rodrigob.20040119132949">class FileStack:
    """
    Helper class to manage the HB buffer file.
    
    Original creation of Josiah Carlson &lt;jcarlson at uci dot edu&gt;, University of California, Irvine.
    """
    
    def __init__(self, fout):
        """
        receive in file as input
        """        
        
        assert type(fout) is file
        assert fout.mode == 'w+b'
        
        from cPickle import dumps, loads
        from struct import pack, unpack

        self.dumps, self.loads = dumps, loads
        self.pack, self.unpack = pack, unpack
        self.f = fout
        self.s = len(self.pack('!i', 0))

        return
        
    def get_size(self):
        """
        Return the actual file size
        """
        t_pos = self.f.tell()
        self.f.seek(0,1) # reach the end of the file
        size = self.f.tell()
        self.f.seek(t_pos, 0) # put the file pointer at his original position
        return size
        
    def push(self, obj):
        """
        Add an object in the file
        """
        
        st = self.dumps(obj)
        self.f.write(st)
        
        t_string = self.pack('!i', len(st))
        assert len(t_string) == self.s, "too long object to keep in the FileStack len(dumps(data)) == %i" % len(st)
        self.f.write(t_string)
        
        return
        
    def pop(self):
        """
        Extract one object from the file 
        """
        
        posn = self.f.tell()
        if posn &lt;= 0:
            raise IndexError
        self.f.seek(posn - self.s)
        s = self.unpack('!i', self.f.read(self.s))[0]
        self.f.seek(posn - self.s - s)
        ret = self.loads(self.f.read(s))
        self.f.seek(posn - self.s - s)
        
        return ret

        

</t>
<t tx="rodrigob.20040121150952.2">def resizePanesToRatio(self,ratio):
    self.divideSplitter(self.splitVerticalFlag, ratio)
</t>
<t tx="rodrigob.20040121150952.6"># Divides the main or secondary splitter, using the key invariant.
def divideSplitter (self, verticalFlag, frac):
    self.divideAnySplitter(frac, verticalFlag, self.split_bar, self.splitPane1, self.splitPane2)
    self.ratio = frac # Ratio of body pane to tree pane.

# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="rodrigob.20040121150952.7">def onDragSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring
    frac = float(offset) / wMax
    # trace(`frac`)
    self.divideSplitter(verticalFlag, frac)
    
    
    # check if the chat bar has dissapeared or appeared, to sincronise with the status_bar
    if self.chat_bar.winfo_height() &lt; 15 or offset &lt; 5: 
        self.status_bar.pack(fill=X, pady=1)
        #t_text = self.text_widget.get("end - 1 line", "end")
        t_text = "this is the status bar"
        #print t_text
        self.set_status(t_text)
    else:
        self.status_bar.forget()
    
    </t>
<t tx="rodrigob.20040121151612">def body(self, base_frame):
    """
    build the body of the dialog window
    """
    
    # base_frame
    self.root = root = base_frame    
    
    &lt;&lt; create frames &gt;&gt;
    &lt;&lt; install the menu &gt;&gt;
    &lt;&lt; install the status bar &gt;&gt;
    &lt;&lt; install the chat bar &gt;&gt;

    self.Redirect(self)
    
    root.title("Chalks")
    root.protocol('WM_DELETE_WINDOW', self.quit) # not a good idea because already overwritten, has to intercept finishQuit

    self.text_widget.focus_set() # put the input focus at the text widget 
        
    return</t>
<t tx="rodrigob.20040121153312">def onChattextEntry(self, event):
    """
    Obtain the last line in the text widget.
    Put the cursor at the end of the widget.
    Send the message.
    
    The event callback is called *before* that the key modify the text widget.
    """
    
    text = event.widget

    txt = text.get("insert linestart", "insert lineend")  # extract the actual line
    if len(txt) == 0: # return immediately on blank input text
        return

    # ensure that the cursor is on the last line, and that there is only one blank line at the end (new entry...)
    text.mark_set("insert", "end")	
    if text.get("insert - 1 chars") == '\n':
        text.delete("insert - 1 chars")
    
    if txt[0] == '/': # manage commands
        if txt.startswith("/presence"):
            t_list = txt.split(' ')
            if len(t_list) &gt;= 2:
                status = ' '.join(t_list[1:])
                self.perspective.callRemote("set_presence", status)
            else:
                self.log("Set your status online (dummy demo command by the moment).\ Example: '/presence happy coding'", color="gray")
                
        elif txt.startswith("/help"):
            self.log("Actual defined commands are:\n'/help','/presence', (sorry, nothing else by now)", color="gray")
            
        else:
            cmd = txt.split(' ')[0]
            self.log_error("Unknown command '%s'; message not sent.\nUse '/help' to get some guidance."%(cmd))	
    else:
        t_from = self.node.nickname
        t_to = None # to everyone
        self.node.remote_send_message(self.node, t_from, t_to, txt)
    
    return


</t>
<t tx="rodrigob.20040121153834.4">def updateStatusRowCol (self):
    
    row, col = tuple(map(int, self.text_widget.index(INSERT).split(".")))
    
    if self.node:
        t_string = "(row %3i, col %3i) (HB %3i, DOps %3i)" % (row, col, len(self.node.HB), len(self.node.delayed_operations))
    else:
        t_string = "(row %3i, col %3i)" % (row, col)
    
    self.rowcol_stringvar.set( t_string )
    
    self.status_bar.after(150, self.updateStatusRowCol)     # Reschedule this routine 150 ms. later.
    
</t>
<t tx="rodrigob.20040121154249">@nocolor

@encoding utf-8
@language plain

Chalks: easy to use crossplatform collaborative text editor

http://chalks.berlios.de

Chalks, the LeoN child.

@color
@language python</t>
<t tx="rodrigob.20040121155420">class ConcurrentEditableNode(ConcurrentEditable):
    """
    This is a specialization of ConcurrentEditable. Instead of suposing that each site is reacheable a network is constructed.
    The network graph is a tree. The parent of the tree is the original text. Each node in the network has at most one parent, and zero or more childrens.
    Each operation that a node receive is repeated to all the other edges (known nodes) of the node.
    
    This network architecture allow the users to control the construction and extension of the network. This allow faster responsiveness in local area, and as fast as possible responsiveness with remote machines.
    
    In this specialization the state vectors in the nodes are different. During interchange the states are sent as diccionary that indicate the known state of each known node. Each node has an unique id (that is not the position in the state vector).

    This kind on ConcurrentEditable specialization allow more dinamic interconnections. At the cost of little extra bandwith, little extra processor cycles, a more memory usage.

    EDIT THIS LINE&gt;&gt;&gt;The concept behind Chalks. Each node acts as a client and a server. It connects to, accept editions and incoming connections. Each received operation (via connections or local) are repeated to the nodes that have connected themself to the local instance.
    """
            
    @others</t>
<t tx="rodrigob.20040121155542">def TestConcurrentEditableNode():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a 'relay network'; with three nodes S1 connect to S2 and S0 connecto to S1.
    """
    
    raise NotImplementedError
    
    return
    
</t>
<t tx="rodrigob.20040121161315">def update_SVT(self, site_index, state_vector):
    """
    update_StateVectorTable
    
    sun98achievings.pdf, page 19 paragraph 2.
    If one site happens to be silent for an unusually long period of time, other sites will not know what its state is [a 'mostly observer' site]. Therefore, it is required for a site to broadcast a short state message containing its state vector when it has not generated an operation for a certain period of time and/or after executing a certain number of remote operations. Upon receiving a state message from a remote site r, site k simply updates its rth statve vecor in SVTk withe the piggybacked state vector.
    ---
    This function is used as a remote call to broadcast the state message.
    """
    
    self.state_vector_table[site_index] = state_vector
    
    return

</t>
<t tx="rodrigob.20040122143140">class S:
        pass
    
def test_FileStack():
    
    import tempfile
    
    f = tempfile.TemporaryFile()
    fs = FileStack(f)
    fs.push({"Hello":"boy"})
    fs.push(range(8))
    s = S(); s.a = 5; s.b = {5:7};	s.c = "8"
    fs.push(s)
    print "File size %s bytes" % fs.get_size()
    print fs.pop()
    print fs.pop()
    fs.push({"Bye, bye":"darling"})
    print fs.pop()
    print fs.pop()
    
    return</t>
<t tx="rodrigob.20040122173046">#f = Frame(root,bd=0,relief="flat")
#f.pack(expand=1,fill="both",pady=1)
#pane1 = Frame(f)
#pane2 = Frame(f)
#bar =   Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

self.splitVerticalFlag = 1 # self.splitVerticalFlag tells the alignment of the splitter 
verticalFlag = 1
&lt;&lt; create the splitter &gt;&gt;
self.split_bar, self.splitPane1, self.splitPane2 = bar, pane1, pane2
self.resizePanesToRatio(1.0/4)


# create the body and the chat frames
from ScrolledText import ScrolledText
&lt;&lt; create the log  widget &gt;&gt;
&lt;&lt; create the text widget &gt;&gt;

</t>
<t tx="rodrigob.20040122173046.1">
self.menu_bar = Menu(root,)

# File, Save, Open, Connect to; Help, about, help, online homepage

self.file_menu = file_menu = Menu(self.menu_bar,)

file_menu.add_command(label="Connect to", underline=0, accelerator="Ctrl+T", command= self.onConnectTo)
file_menu.add_separator()
file_menu.add_command(label="Open", underline=0, accelerator="Ctrl+O",command= self.onOpen)
file_menu.add_command(label="Save", underline=0, accelerator="Ctrl+S", command= self.onSave)
file_menu.add_separator()
file_menu.add_command(label="Quit", underline=0,  accelerator="Ctrl+Q", command= self.quit)

self.menu_bar.add_cascade(label = "File", underline=0, menu= file_menu)

self.menu_bar.add_command(label="Help", underline=0, command= self.onHelp)
@
help_menu = Menu(self.menu_bar,)
help_menu.add_command(label="About", command= lambda _: None)
help_menu.add_command(label="Help", command= lambda _: None)
help_menu.add_command(label="Online homepage", command= self.online_homepage)

self.menu_bar.add_cascade(label = "Help", menu= help_menu)
@c

root.config(menu=self.menu_bar)


# install the shortcuts
root.bind("&lt;Control-t&gt;", self.onConnectTo)
root.bind("&lt;Control-o&gt;", self.onOpen)
root.bind("&lt;Control-s&gt;", self.onSave)
root.bind("&lt;Control-q&gt;", self.quit)
root.bind("&lt;Control-H&gt;", self.onHelp)
</t>
<t tx="rodrigob.20040122173046.2">@
Create the chat_bar widget that is a posteriori inserted or extirped from the log panel.
The chat bar allow smart text entry
@c
    
parent = pane1
self.chat_bar = chat_bar = Frame( parent, borderwidth=1,relief=SUNKEN)

self.rowcol_label = Label(chat_bar, textvariable=self.rowcol_stringvar, anchor=W)   
self.rowcol_label.pack(side=LEFT, padx=1)

# the entry is a text widget of fixed heigth 1. The '\n' keystroke is related to a function call. then users can send lines, and have an history.

log = self.log_widget
self.chat_text_entry = text = Text(chat_bar, height=1, background = log["background"], font = log["font"])
text.pack(side=RIGHT, fill=BOTH, expand=1)
text.bind("&lt;Return&gt;", self.onChattextEntry )

text.insert(END, " The chat bar is disabled until someone connects to you or you connect to someone.")
text["state"] = DISABLED

chat_bar.pack(fill=BOTH)</t>
<t tx="rodrigob.20040122173046.3">@others

self.status_bar = Frame(pane2, bd=2)

self.rowcol_stringvar = StringVar()
self.rowcol_label = Label(self.status_bar, textvariable=self.rowcol_stringvar, anchor=W)
self.rowcol_label.pack(side=LEFT, padx=1)

bg = self.status_bar.cget("background")
self.status_text = Text(self.status_bar, height=1, state=DISABLED, bg=bg, relief=GROOVE)
self.status_text.pack(side=LEFT, fill=X,expand=1)

# Register an idle-time handler to update the row and column indicators.
self.status_bar.after_idle(self.updateStatusRowCol)


#self.status_bar.pack(fill=X, pady=1) # the status bar is pack at onDragSplitBar</t>
<t tx="rodrigob.20040122173128">
def online_homepage(self, event=1):
    
    import webbrowser

    url = "http://chalks.berlios.de"
    
    try:
        webbrowser.open_new(url)
    except:
        print "not found: " + url
</t>
<t tx="rodrigob.20040122175312"></t>
<t tx="rodrigob.20040122182446.1">class Redirect:
    """
    act a proxy for a file
    When instanciated will redirect the stdout and stdout over the log_widget.
    """
    
    # To redirect stdout a class only needs to implement a write(self,s) method.
    def __init__ (self, app):
        
        assert hasattr(app, "log_widget"), "require to have already build the gui in order to install the redirection"
        
        self.redirecting = None
        self.app = app
        self.app.log_widget.tag_config("stdout", foreground="gray45")
        
        self.redirect() # redirect stderr and stdout to the log panel
        
    def isRedirected (self):
        return self.redirecting
        
    def flush(self, *args):
        return # 6/14/03:  For LeoN: just for compatibility.
    
    def redirect (self):
        import sys
        if not self.redirecting:
            sys.stdout, sys.stderr, self.redirecting = self, self, 1
    
    def undirect (self,stdout=1):
        import sys
        sys.stdout, sys.stderr, self.redirecting = sys.__stdout__, sys.__stderr__, None

    def write(self,s):
        if self.redirecting:
            if self.app.log_widget: 
                if not s.isspace(): # if it has some readable content
                    self.app.log("&lt;local&gt; %s" % s , tag= "stdout")
                else:
                    self.app.log(s)

            sys.__stdout__.write(s) # anyway write out (to see the crash errors)
        else: print s # Typically will not happen.
    
</t>
<t tx="rodrigob.20040123123802"># help is defined at the class level; to avoid leo identation problems
&lt;&lt; chalks help &gt;&gt; # define 'help' (at the class level)

def onHelp(self, event=None):
    """
    Show main help screen
    """

    from ScrolledText import ScrolledText
    top = Toplevel(self.root)
    top.title("Help")
    t = ScrolledText(top, wrap=WORD, padx=50); t.pack(expand=1, fill=BOTH)
    
    # add apropos
    t.insert(END, "\nChalks " + self.version + "\nLicensed under the GNU GPL\nCopyright 2004, Chalks Development Team")
    link_text = " Project homepage"
    t.insert(END, link_text)
    t.tag_config("hyperlink", underline=1, foreground="blue3")
    t.tag_bind("hyperlink", "&lt;Button&gt;", self.online_homepage)
    t.tag_add("hyperlink","end - %i chars" % (len(link_text) + 1), "end - 1 char")
    
    t.insert(END, "\n")
    t.insert(END, self.help) # insert the content
    t.config(state=DISABLED)
    Button(top, text="Close", command= top.destroy, default=ACTIVE).pack()
    top.protocol("WM_DELETE_WINDOW", top.destroy)

    self.root.wait_window(top) # show
    
    return
    
</t>
<t tx="rodrigob.20040123123802.1"># Create a splitter window and panes into which the caller packs widgets.
# Returns (f, bar, pane1, pane2) 

parent = root

# require parent, verticalFlag

# set up icon only on win32 (need to research how this is done on *NIX)
import sys
if sys.platform == 'win32':
    root.iconbitmap(bitmap="chalks.ico")  # set application icon

# Create the frames.
f = Frame(parent,bd=0,relief="flat",width=640,height=480) # without forcing width/height, the frame starts up with a really small dimension on win32 (almost iconic)
f.pack(expand=1,fill="both",pady=1)
pane1 = Frame(f)
pane2 = Frame(f)
bar =   Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

# Configure and place the frames.

&lt;&lt; configure &gt;&gt;
&lt;&lt; place &gt;&gt;

#return f, bar, pane1, pane2
</t>
<t tx="rodrigob.20040123123829">#bar, verticalFlag


w = 7
relief = "groove"
color = "LightSteelBlue2"

try:
    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
except: # Could be a user error. Use all defaults
    self.log("exception in user configuration for splitbar")

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.configure(height=7,cursor="sb_v_double_arrow")
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.configure(width=7,cursor="sb_h_double_arrow")


# bind the bar
bar.bind("&lt;B1-Motion&gt;", self.onDragSplitBar)
</t>
<t tx="rodrigob.20040123124005"></t>
<t tx="rodrigob.20040123130224"></t>
<t tx="rodrigob.20040123130224.1">#bar,pane1,pane2,verticalFlag

if verticalFlag:
    # Panes arranged vertically; horizontal splitter bar
    pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
    pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
    bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
else:
    # Panes arranged horizontally; vertical splitter bar
    # adj gives tree pane more room when tiling vertically.
    adj = (verticalFlag != self.splitVerticalFlag and 0.65) or 0.5
    pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
    pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
    bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="rodrigob.20040123132311.1">@color
@language python
# this is the documentation that will be seen by the end user, give a description of the panel and it's usage
# this is part of the code, so do not delete the "help" definition and the """ elements.
help = \
"""

NOT YET WRITTEN

@others

"""

</t>
<t tx="rodrigob.20040123133012">def log(self, text, tag=None, color=None):
    """
    log some text in the log panel
    """
    assert hasattr(self, "log_widget")
    assert hasattr(self, "status_text")

    if tag:   assert type(tag)   is str
    if color: assert type(color) is str
    
    self.log_widget.config(state=NORMAL)                    

    if color:
        self.log_widget.tag_config(color, foreground=color) # create or config a tag to have the same name that the color string
        tag = color
                    
    if tag:
        t_index = self.log_widget.index(INSERT)
        self.log_widget.insert(END, text)
        self.log_widget.tag_add(tag, t_index, END)
    else:
        self.log_widget.insert(END, text)
        
    self.log_widget.config(state=DISABLED)
    
    self.log_widget.yview(END) # makes sure the bottom is visible
    
    # we also keep the last message in the status bar
    self.set_status(text)
        
    return
    

</t>
<t tx="rodrigob.20040123133928">def onOpen(self, event=None):
    """
    """
    
    from tkFileDialog import askopenfile
    
    t_file = askopenfile(mode="rw") # return the opened file
    
    if not t_file:
        self.log_error("Did not select a file to open.")
        
    else:
        pass
        # check if we have to save the current content
        if self.is_dirty(): # if file is dirty
            if self.filename: 
                message = "File \"%s\" contains changes not yet saved to disk.\nDo you want to save the file before opening a new one ?" % self.filename
            else:
                message = "The text has not been saved. Save before opening a new one ?"

            ret = self.askYesNoCancel("Save before opening", message) # ret 1, 0 or -1 for cancel

            if ret == 1:
                # save the file
                ret = self.onSave()
                if not ret: # did not save
                    return # do not open

            elif ret == -1:
                print "Open cancelled"
                return
        
        # confirm disconnection desire (of ourself, and from everyone already connected to us)
        if self.node.connected:
            from tkMessageBox import askokcancel
            ret = askokcancel("Confirm disconnection",
                              "You are connected to a remote server. Opening another file will close this connection. Proceed ?")

            if not ret:
                print "Open cancelled"
                return
            
            # disconnect ourself first
            self.node.disconnect_from_server()
            
        # open the file content
        base_text = None
        try:
            base_text = t_file.read()
        except IOError:
            print 'i/o error opening file %s, aborting' % t_file

        if not base_text:
            from tkMessageBox import showerror
            showerror('Error', 'Input/output error opening file %s, aborting.' % t_file)
            return
        
        # create a new ChalksNode instance
        self.node = ChalksNode(self, base_text)
        
        # update the window
        
    return
    
    
</t>
<t tx="rodrigob.20040123134358">def onConnectTo(self, event=None):
    """
    Open the connect to dialog
    """
    top = Toplevel(self.root)
    top.title("Connect to ...")
    
    #|-|-|
    ttt_frame = LabelFrame(top, text="Available servers", padx=5, pady=5)
    self.server_listbox = Listbox(ttt_frame, width=46)    
    self.server_listbox.grid(row=0, column=0, pady=5)

    t_text = Label(ttt_frame, text="Select a server and enter a nickname to connect")
    t_text.grid(row=1, column=0)
    
    #|-|-|
    t_frame = LabelFrame(top, text="Enter remote server info", padx=5, pady=5)
    
    t_text = Label(t_frame, text="Address:")
    t_text.grid(row=0, column=0, pady=5)

    address_entry = t_entry = Entry(t_frame, width=16, background="white")
    t_entry.grid(row=0, column=1, sticky=W)
    t_entry.insert(END, "127.0.0.1")
        
    t_text = Label(t_frame, text="e.g. : 181.0.24.5")
    t_text.grid(row=1, column=0, columnspan=2, sticky=E)

    t_text = Label(t_frame, text="  Port:")
    t_text.grid(row=0, column=2)

    port_entry = t_entry = Entry(t_frame, width=5,  background="white")
    t_entry.grid(row=0, column=3, sticky=W)
    t_entry.insert(END, "8787")
    
    t_text = Label(t_frame, text="e.g. : 4321")
    t_text.grid(row=1, column=2, columnspan=2, sticky=E)
    
    #-|-|-
    tt_frame = LabelFrame(top, text="Identify yourself", padx=5, pady=5)
    
    t_text = Label(tt_frame, text="Nickname:")
    t_text.grid(row=2, column=0)
    
    nickname_entry = t_entry = Entry(tt_frame, width=8, background="white")
    t_entry.grid(row=2, column=1, sticky=W)
    t_username = guess_username() # guess the username
    t_entry.insert(END, t_username)
    
    # see binding below...
        
    t_text = Label(tt_frame, text="e.g. : mike")
    t_text.grid(row=3, column=0, columnspan=2, sticky=E)
    
    #-|-|-
    ttt_frame.pack(ipadx = 5)    
    t_frame.pack(ipadx = 5)
    tt_frame.pack(ipadx = 5)        
    #|-|-|
    
    t_frame = Frame(top)
    
    button_close = Button(t_frame, text="Close", command= top.destroy)
    button_close.pack(side=RIGHT, padx=10)
    
    from struct import unpack # used for unpacking IPv4 addresses from zeroconf
    
    &lt;&lt; server list callback &gt;&gt;
    self.server_listbox.bind("&lt;Button-1&gt;", onServerListClick)
    
    &lt;&lt; connect to callback &gt;&gt;
    
    button_connect_to = Button(t_frame, text="Connect to", command=connect_to_callback, state=DISABLED, default=ACTIVE)
    button_connect_to.pack(side=RIGHT, padx=10)
    
    top.bind("&lt;Return&gt;", lambda e: button_connect_to["state"] == NORMAL and connect_to_callback() ) # call the command if the button is enabled
    
    &lt;&lt; validation callback&gt;&gt;
        
    button_connect_to.after(200, validation_callback) # start ciclic calls each 200 ms
    
    t_frame.pack()    
    
    
    top.protocol("WM_DELETE_WINDOW", top.destroy)

    &lt;&lt; server monitor callback &gt;&gt;
    
    if self.server_monitor:
        # register callback with serverMonitor object
        self.server_monitor.addCallbackListener(server_monitor_callback)
        # populate it for the first time
        server_monitor_callback(self.server_monitor.getServers())
    
    self.root.wait_window(top) # show

    if self.server_monitor:
        # unregister callback with serverMonitor object
        self.server_monitor.removeCallbackListener(server_monitor_callback)
    
    return
    </t>
<t tx="rodrigob.20040123134959">def log_error(self, text):
    """
    log an error
    """ 
    return self.log("&lt;error&gt; %s" % text, tag="error")
</t>
<t tx="rodrigob.20040123140212">def onSave(self, event=None):
    """
    Return true if saved, False else.
    """
    
    if self.file:
        # simply save the content
        self.save_text() # save the content
        
        self.log("saved: %s" % self.filename)
        ret = 1
    else:
        # ask for a filename
        from tkFileDialog import asksaveasfile
                
        t_file = asksaveasfile(mode="rw") # return the file instance
        
        if not t_file:
            self.log_error("You did not selected a file to save as.")
            ret = 0
        else:
            
            # save the content
            self.save_text() 
                    
            from os.path import basename
            self.filename = basename(t_file.name)
            self.log("saved: %s" % self.filename)
            self.root.title("Chalks - %s" % self.filename)
            ret = 1
            
    return ret 
</t>
<t tx="rodrigob.20040123142018">def askYesNoCancel(self, title, message):
    """
    helper method to ask yes, no cancel
    """
    
    import tkMessageBox
    
    ret = tkMessageBox._show(title=title, message=message, icon=tkMessageBox.QUESTION, type=tkMessageBox.YESNOCANCEL)
    # will return .YES, .NO or .CANCEL
    #dic = {tkMessageBox.YES:1, tkMessageBox.NO:0, tkMessageBox.CANCEL:-1}
    #print "yes no cancel :", ret, type(ret) # just for debugging
    #return dic[ret] # did not work for cancel
    
    if   ret == tkMessageBox.YES: return  1
    elif ret == tkMessageBox.NO : return  0
    else:                         return -1</t>
<t tx="rodrigob.20040124160427"></t>
<t tx="rodrigob.20040124165851">def set_status(self, text):
    """
    set the text of the status bar
    """
    
    t_widget = self.status_text
    t_widget.config(state=NORMAL)
    t_widget.delete("1.0", END)
    t_widget.insert(END, text)
    t_widget.config(state=DISABLED)
    
    return
</t>
<t tx="rodrigob.20040124184444">@
Hooks related to the text widget
@c

@ 
Text Key Handlers

The &lt;Key&gt; event generates the event before the text text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the text text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onTextChanged, and commands like "Cut" and "Paste" that call onTextWillChange.  The former commands have already changed the text text, and that change must be captured immediately.  The latter commands have not changed the text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="rodrigob.20040125145031">def onCut (self,event=None):
    """The handler for the virtual Cut event."""
    self.onTextWillChange("Cut")

def OnCutFromMenu (self):    
    """
    called from the menu
    """
    self.root.event_generate(virtual_event_name("Cut"))



def onCopy (self,event=None):
    
    # Copy never changes dirty bits or syntax coloring.
    return
        
def OnCopyFromMenu (self):

    self.root.event_generate(virtual_event_name("Copy"))


def onPaste (self,event=None):
    
    self.onTextWillChange(v,"Paste")
    
def onPasteFromMenu (self):

    self.root.event_generate(virtual_event_name("Paste"))
</t>
<t tx="rodrigob.20040125153141"># install the collaboration service 

self.node = ChalksNode(self) # ChalksNode takes care of the rest

# local PB classes definitions
@others

self.server_port = None # initially we don't know which port we are serving at

t_portal = portal.Portal(ChalksRealm(self))
t_portal.registerChecker(DummyChecker())
pb_factory = pb.PBServerFactory(t_portal)

for port in xrange(pb.portno, pb.portno+10):
    try:
        pb_service = reactor.listenTCP(port, pb_factory) #internet.TCPServer(port, site).setParentApp(app)
    except: # failed
        continue
    else: # got it
        self.server_port = port
        print "Starting Chalks service at chalks://localhost:%i" % port
        #print "Knowing your internet address (i.e. your IP) other users can connect themself to your session using the port %i." % port  #&lt;&lt;&lt;&lt;&lt; this should be replaced by a friendlier popup or message
        self.chalks_service = pb_service
        break # stop creating web services
        
else: # the range failed
    self.log_error("Unable to find an available port in the range %s to provide the chalks service." % [pb.portno, pb.portno+10] )
    self.log_error("This is a fatal error")
    self.text_widget["state"] = DISABLED # I said fatal error...
    </t>
<t tx="rodrigob.20040125153909">self.log_widget  = ScrolledText(pane1, background="white", state=DISABLED)
self.log_widget["height"] = 1
self.log_widget.pack(fill=BOTH, expand=1)
self.log_widget.tag_config("error", foreground="red")
</t>
<t tx="rodrigob.20040125153909.1">self.text_widget = text_widget = ScrolledText(pane2, background="white", height=0)
text_widget.pack(fill=BOTH, expand=1)

# Event handlers...
#text_widget.bind("&lt;Button-1&gt;", self.onTextClick)
#text_widget.bind("&lt;Button-3&gt;", self.onTextRClick)
#text_widget.bind("&lt;Double-Button-1&gt;", self.onTextDoubleClick)
text_widget.bind("&lt;Key&gt;", self.onTextKey)

# Returns &lt; &lt; s &gt; &gt;
def virtual_event_name(s):
    return ( "&lt;&lt;" + s +
           "&gt;&gt;") # must be on a separate line.

# Gui-dependent commands...
text_widget.bind(virtual_event_name("Cut"), self.onCut)
text_widget.bind(virtual_event_name("Copy"), self.onCopy)
text_widget.bind(virtual_event_name("Paste"), self.onPaste)</t>
<t tx="rodrigob.20040125154636">def onTextKey (self,event):
    """
    Handle any key press event in the text pane.
    This method is called before the key operation is efectued.
    We recolect all the pertinent status data and use it in posterior processing.
    """
    
    # required data
    d = {}
    d["undoType"] = "Typing"
    d["ch"] = event.char
    d["keycode"] = event.keycode
    d["oldSel"]  = self.get_text_selection() 
    d["oldText"] = self.text_widget.get("1.0", END)


    # obtain some important tags positions
            
    tags_ranges = {}
    #tag_names = self.text_widget.tag_names() 
    tag_names = ["to_send"] # we are only interesed on the to_send ranges

    for t_name in tag_names:
        if 0:
            # normally there are only  two or fours tags at the same time
            # so we convert them directly
            tags = []
            for start, stop in self.text_widget.tag_ranges(t_name) :
                pos = (self.text_widget.get("1.0", start))
                length = (self.text_widget.get(start, stop))
                tags.append((pos, length))
        else:
            tags = self.text_widget.tag_ranges(t_name)
            
        tags_ranges[t_name] = tags

    d["oldTagsRanges"]	= tags_ranges
    
            
    #self.log("tag names %s tags_tanges %s"%(self.text_widget.tag_names(), tags_ranges), color="orange")
    
    self.text_widget.after_idle(self.idle_text_key, d)
    
    return

</t>
<t tx="rodrigob.20040125154657">def idle_text_key (self, data):	
    """
    Update the text pane at idle time.
    """
    
    self.node.fill_body(data) # parse the events over the text widget
    
    return </t>
<t tx="rodrigob.20040125154815.1">from ConcurrentEditable import ConcurrentEditableNode
from ConcurrentEditable import ConcurrentEditable # needed by remote_delete_text()
        
class ChalksNode(ConcurrentEditableNode):
    """
    This is the local instance that take care of the collaborative edition and the network layers.
    This is the core object under the GUI.
    
    A Chalks node is part of a tree network, it can have one parent and N childrens.
    A node connect once to his parent and can receive N childrens connections.
    
    All messages that arrive to a node has to be repeated to the other nodes.
    This is the class that generate all the operations to be sent to the server, and it the the one that process the received operations.
    """
    
    def __init__(self, chalks_gui, text=""):
        """
        """
        
        ConcurrentEditableNode.__init__(self,)

        # initialize the extra attributes		
        self.chalks_gui  = chalks_gui # stores a reference to the gui object

        self.nickname = guess_username()
        self.site_id = None # site_id is an unique internet identifier
        self.connected = 0              # initially we are not connected to anyone
        
        # perspectives of the adjacent nodes in the network
        self.parent_perspective = None
        self.childrens_perspectives = []
        
        # attach some attributes and methods
        for t_name in ["log", "log_error", "exception", "encoding"]: 
            setattr(self, t_name, getattr(chalks_gui, t_name))
        self.log = lambda text, *args, **kws: chalks_gui.log("\n%s" % text) # dummy trick
                
        self.text_widget = chalks_gui.text_widget
        self.text_widget.tag_config("to_send", relief= RAISED, borderwidth=4, background= "beige")# work fine in Linux
            
        self.deletion_buffer = () # helper variable store a cumulative erasure (successive delete or insert commands) in the tuple (startpos, len)

        #&lt;&lt;&lt;&lt;&lt; "text" parameter is not being used. Keep it in mind when fixing this method, as the open dialog will call it with textbase from a local file
        if text:
            self.set_text(text)        

        return


    @others</t>
<t tx="rodrigob.20040125154815.2">
@others







</t>
<t tx="rodrigob.20040125154815.3">@
This methods edit the client node text, presenting the gui results.
Essentially this method take care of allowing the user to input text while receiving operations and solve the unicode inconsistencies between Tkinter and the python string manipulation.

Unmanaged text in the text_widget is marked as "to_send".
@c


def set_cursor_position(self, who, pos):
    """ 
    Define the new position of someone cursor, so the local user can suspect future editions of the camarades. Used as a visual feedback of other user actions.
    """
    
    raise NotImplementedError, "not yet implemented"
    
    return</t>
<t tx="rodrigob.20040125154815.4">def set_text(self, new_text):
    """
    Blindly overwrite the text of this site. (including the "to_send" elements)
    """    
    self.log( "Calling set_text '%s'"%(new_text), color="yellow" ) # for debugging
    
    # maintain an unicode buffer equivalent
    ConcurrentEditableNode.set_text(self, new_text)
            
    # clean up the body
    self.text_widget.delete("1.0", END)
    
    # insert the new text
    self.insert_text(0, new_text, op={"source_site":self.site_index})
    
    return



</t>
<t tx="rodrigob.20040125154815.5">def insert_text(self, startpos, text, op={}):
    """ 
    Some one insert text on the actual node.
    Should insert text only counting non "to_send" locations.
    """
    
    if op.get("avoid"):
        self.log( "AutoInsertion is avoiyed", color="yellow") # for debugging
        del op["avoid"] # I hope this will edit the operation stored in the HB
        self.log("HB after operation avoyance %s"% self.HB, color="yellow") # just for debugging
        return

        
    text_widget = self.text_widget
        
    t_startpos = startpos

    # convert the insertion point, considering the "to_send" elements
    ranges = text_widget.tag_ranges("to_send") # ranges are text indexes
    
    for i in xrange(0, len(ranges), 2):
        # convert text indexes to numerical values
        start =          len(text_widget.get("1.0",     ranges[i]  ))
        stop  =  start + len(text_widget.get(ranges[i], ranges[i+1]))
        
        if start &lt; startpos:
            startpos += stop - start # make the startpos include the unsent local text.
        if start &gt;= startpos:
            break
        # else: continue

    startpos = "1.0 + %i chars"%(startpos)
                
    self.log("Insert text: input starpos %s, real startpos %s. to_send ranges %s"%(t_startpos, startpos, ranges), color="yellow")
    
    # now startpos is a "line.column" index that consider the correct location
            
            
    if op["source_site"] == self.site_index: # if it is a confirmation
        who = None
    else:
        who = op.get("who")
    
    if who and who != self.name:
            
        # check if the who tag exists
        if who not in text_widget.tag_names(): # this is slowww &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; (how to do it fast?)
            # find a new color (fixed saturation and value. tint is random)(this ensure us to have only 'pleasant' background colors)						
            r,b,g = map(lambda x: int(x*255), colorsys.hsv_to_rgb( random.Random().random(), 
                                                                    0.30 , # thee important value (0 white, 1.0 intense color)
                                                                    1.0
                                                                  ))			
            t_color = "#%02x%02x%02x"%(r,g,b)
            
            text_widget.tag_config(who, background = t_color)
            text_widget.tag_bind(who, "&lt;Button-1&gt;", lambda event: self.log("Text inserted by %s"%(who), color=t_color))
        # end of new tag
        
        text_widget.insert(startpos, text, who)
        
    else: # no 'who', just insert the text
    
        text_widget.insert(startpos, text)
    
    self.log( "%s insert at %s the content '%s'"%(who, startpos, text), color="yellow" ) # for debugging
    
    return

</t>
<t tx="rodrigob.20040125154815.6">def delete_text(self, startpos, length, op={}):
    """ 
    Some one delete text on the actual node.
    Should delete text in  non "to_send" locations.
    Delete only remote solicitations, local text was already deleted.
    """

    if op.get("avoid"):
        self.log( "AutoDeletion is avoiyed", color="yellow") # for debugging
        del op["avoid"] # I hope this will edit the operation stored in the HB
        self.log("HB after operation avoidance %s"% self.HB, color="yellow") # just for debugging

        return


    text_widget = self.text_widget
    
    # convert the starting and end points, considering the "to_send" elements
    ranges = text_widget.tag_ranges("to_send") # return a list of index tuples
    
    for i in xrange(0, len(ranges), 2):
        # convert text indexes to numerical values
        start =          len(text_widget.get("1.0",     ranges[i]  ))
        stop  =  start + len(text_widget.get(ranges[i], ranges[i+1]))
        
        if start &lt; startpos:
            startpos += (stop - start) # make the startpos include the unsent local text.
            
        if start &gt;= startpos:
            ranges = ranges[i:] # store the rest (including actual pos)
            break
        # else: continue
        
                    
    self.log( "Deleting text at %s len %s"%(startpos, length), color="yellow" ) # for debugging
    
    # delete the text avoiying the "to_send" elements. 
    deleted_text = ""
    offset = 0
    for i in xrange(0, len(ranges), 2): #ranges contain the indexes of the rest of the "to_send" elements
        # convert text indexes to numerical values
        range_start =                len(text_widget.get("1.0", "%s - %i chars"%(ranges[i], offset)  ))
        range_stop  =  range_start + len(text_widget.get( "%s - %i chars"%(ranges[i], offset), "%s - %i chars"%(ranges[i+1], offset))) 
        
        if startpos + length &gt;= range_start: # there is an overlapping
                        
            t_start = "1.0 + %i chars"%(startpos)
            t_stop  = "1.0 + %i chars"%(range_start)

            deleted_text += text_widget.get(t_start, t_stop)  # necessary for algorithm internal undo/redo	operations
            text_widget.delete(t_start, t_stop)
            
            length  -= range_start - startpos
            offset  += range_start - startpos
            startpos = range_stop - (range_start - startpos) # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; this line is wrong
            # continue
            self.log( "continuing deletion at %s len %s"%(startpos, length), color="yellow" ) # for debugging
        else:
            break
        # end of for

    # the last one is direct (or the only one if no ranges==[])
    if length &gt; 0:
        t_start = "1.0 + %i chars"%(startpos)
        t_stop  = "1.0 + %i chars"%(startpos + length)

        deleted_text += text_widget.get(t_start, t_stop)  # necessary for algorithm internal undo/redo	operations
        text_widget.delete(t_start, t_stop)
    #end of last deletion
    
    # keep the deleted text for future operation undo
    op["deleted_text"] = deleted_text
    
    return
    
</t>
<t tx="rodrigob.20040125154815.7">def send_operation(self, op_type, pos, data):
    """
    Apply locally and then send the operation to all the adjacent nodes (upward and downward the tree).
    This method overwrite the ConcurrentEditableNode implementation to take care of the network layer.
    """
    
    if op_type == "insert_text":
        op_type = "Insert"
        # convert data to unicode
        data = unicode(data, self.encoding, "strict")

    elif op_type == "delete_text":
        op_type = "Delete"
        
    else:
        raise "Unknown op_type '%s'"%op_type
    
    # apply locally
    self.gen_op(op_type, pos, data, avoid=1) # will avoid the effects the first time.

    
    # convert the state vector to a dict representation
    state_vector = {}
    for site_id, pos in self.sites_index.items():
        state_vector[site_id] = self.state_vector[pos]
    
    
    # send to all the connected sites
    perspectives = self.childrens_perspectives + [self.parent_perspective]
    for perspective in perspectives:
        if perspective:       
            # send to the other nodes
            perspective.callRemote("receive_op", op_type, pos, data, state_vector ).addErrback(self.exception)
    
    return


</t>
<t tx="rodrigob.20040125154815.8">def fill_body(self, keywords):
    """
    Process each new key received in the body.
    Attached to OnBodyKey2 (well, really on idle_on_body_key). All params are passed as a keyword.
    Manage insertions, deletions, suppresions, range text overwrite and paste operations.
    
    Note that OnBodyKey2 is called for evey key, but not necesarrely inmediatelly after the key was pressed. The TextWidget contents can have changed since.
        
    fill_body has to mark the to_send chars and trigger the proper delete_text calls.
    This function is associated to the flush_body method, that will check the to_send chars, and send them when proper.
    """
    
    ch = keywords["ch"]
    old_sel    = keywords["oldSel"] # (first, last)
    old_text   = keywords["oldText"] or ""
    undo_type  = keywords["undoType"]
    old_insert = old_sel[0]
    old_tags_ranges    = keywords["oldTagsRanges"]	
    old_to_send_ranges = old_tags_ranges.get("to_send")

    #self.log("fill_body keywords %s"%(keywords), color="yellow") # just for debugging
    #trace("onbodykey2 keywords %s"%(keywords)) # just for debugging


    # some local helpers functions	
    &lt;&lt; def index_to_list&gt;&gt;
    &lt;&lt; def in_range&gt;&gt;
    &lt;&lt; def range_to_pos_and_length &gt;&gt;
    
    if old_sel and old_sel[0] != old_sel[1] and ch: # text was overwritten	(pressed a key while having a non void selection)
        &lt;&lt; text was overwritten &gt;&gt;
    elif ch in ['\x7f', '\x08']: 
        &lt;&lt; suppression or deletion &gt;&gt;
    elif undo_type == "Typing" and ch: 
        &lt;&lt; "normal" keys&gt;&gt;
    elif undo_type == "Paste":
        &lt;&lt; text paste &gt;&gt;
    else: 
        # non text insertion keys (move arrow, page up, etc...)
        pass
        #if ch and len(ch) &gt; 0: self.log("unmanaged key %c" % ch, color="yellow") # just for debugging
        #self.log("unmanaged key of type %s"%(undo_type), color="yellow") # just for debugging
        
            
    self.flush_body(keywords) # send the unsent data and clean up what is necesarry.
    
    return</t>
<t tx="rodrigob.20040125154815.9"></t>
<t tx="rodrigob.20040125154815.10">def index_to_list(val):
    """
    Convert a Tkinter string index to a list of two integer elements [line, column].
    """
    if type(val) is str:
        return map(int, val.split("."))
    else:
        return val
    
def list_to_index(val):
    """
    Convert [line, column] list to a Tkinter index.
    """
    return "%i.%i"%tuple(val)</t>
<t tx="rodrigob.20040125154815.11">def in_range(index, ranges):
    """
    return true if the index is in the range. false else.
    the true value returned is the (start, end) tuple corresponding to the range that covers the indicated index.
    """
    
    index =  index_to_list(index)
    
    for i in xrange(0, len(ranges), 2):	
        start  = index_to_list(ranges[i])
        stop   = index_to_list(ranges[i+1])

        if start &lt;= index and index &lt;= stop:
            return list_to_index(start), list_to_index(stop)
        else:
            continue

    return None # did not found the index in a range

</t>
<t tx="rodrigob.20040125154815.12">def range_to_pos_and_length(start, stop, text):
    """
    Convert a Tkinter range to a (length, position) index (used for the Operations definition).
    """
        
    start = index_to_list(start)
    stop  = index_to_list(stop)
    
    assert text, "The text parameter is %s, this argument is indispensable." % text
        
    if type(text) is unicode:
        text = text.split("\n")
    
    assert type(text[0]) is unicode, "Text data has to be unicode, to be comparable with the tkinter indexes."
    
    # Tkinter count the lines from 1 to N and the columns from zero to N
    
    pos    = start[1] + reduce(lambda x,y: len(y) + x, text[:start[0]-1], 0) + (start[0]-1) # columns + rows length + "\n" chars
    length = stop [1] - start[1] + reduce(lambda x,y: len(y) + x, text[start[0]-1:stop[0]-1], 0) + (stop[0] - start[0]) # stop columns - start columns + rows length + "\n" chars
    
    #print "\nrange_to_pos_length(start=%s, stop=%s, some_text) =&gt; pos, length == %s, %s"%( start, stop, pos, length) # just for debugging
    
    return pos, length
</t>
<t tx="rodrigob.20040125154815.13"># (should check which overwritten text was already sent)
# and should create a sequence of deletion operations

self.log("text was overwritten %s;"%(old_sel), color="yellow")

# need to define the lists:
#	- text_deletion_ranges
#   - to_send_deletion_ranges

# has as input:
#   - old_to_send_ranges
#   - old_sel
#   - old_text
    
#print "old_sel", old_sel
#print "old_to_send_ranges", old_to_send_ranges

old_sel =	map(index_to_list, old_sel)
ranges =	old_to_send_ranges
t_ranges = [] # will keep the list of to_send ranges that are embedded in the old_sel range.

# first we prune the to_send_ranges to get only the ranges of interest
if not ranges:
    ranges=[]
i = 0 # if ranges is []
for i in xrange(0, len(ranges), 2):	
    start  = index_to_list(ranges[i])
    stop   = index_to_list(ranges[i+1])
    # search the initial range
    
    if start &gt;= old_sel[0]: # found the initial range
        break # lets continue with a new logic
    elif  stop &gt;= old_sel[0]:
        t_ranges.append(old_sel[0])
        t_ranges.append(min(stop, old_sel[1]))
        i += 2
        break
    else:
        continue

for i in xrange(i, len(ranges), 2):	# starting from last point
    start  = index_to_list(ranges[i])
    stop   = index_to_list(ranges[i+1])	
    
    if start &lt;= old_sel[1]: 
        t_ranges.append(start)
    else:
        break # job finished
        
    if stop &lt;= old_sel[1]:
        t_ranges.append(stop)
    else:
        t_ranges.append(old_sel[1])
        break # job finished
    
# now we convert the data to lineal ranges and check the valid deletion ranges	
ranges = to_send_deletion_ranges = t_ranges
#print "to_send_deletion_ranges", to_send_deletion_ranges
ranges.insert(0, old_sel[0])
ranges.append(old_sel[1])
t_ranges = []
for i in xrange(0, len(ranges), 2):	
    t_ranges.append( range_to_pos_and_length(ranges[i], ranges[i+1], old_text) )

ranges   = t_ranges
t_ranges = []
t_ranges = filter(lambda x: x[1] &gt; 0, ranges) # if length &gt; 0, keep it

text_deletion_ranges = t_ranges # text_deletion_ranges is a list of (pos, length) tuples that indicates the text areas that where deleted.
self.log( "text_deletion_ranges %s"%text_deletion_ranges, color="yellow") # just for debugging

# send the deletion operations
for pos, length in text_deletion_ranges:
    deferred = self.send_operation("delete_text", pos, length)
    
# mark the overwriter char					
if ch not in ['\x7f', '\x08']:
    self.text_widget.tag_add("to_send",  old_insert)		
</t>
<t tx="rodrigob.20040125154815.14"># suppression or deletion 
# if the operation was applied in a to_send char, we omit it,
# else we add it to the deletion buffer, that will be latter send over the network.
# the idea is: we sum any deletion operation until any other key is pressed, then we send it.

has_to_delete = None
ranges = old_to_send_ranges
if ch == '\x7f': #key Suppr, a suppression
    t_index = old_insert
    t_range = in_range(t_index, ranges) # return the range which touch the index
    if t_range and t_index != t_range[1]:
        self.log("supressed a to_send char", color="yellow")
        # nothing more to do
        has_to_delete = None
    else: 
        # suppressed text
        delta = 0
        has_to_delete = 1
        
elif ch == '\x08': #key, '\x08' # delete, a deletion
    t_index = old_insert
    t_range = in_range(t_index, ranges) # return the range which touch the index
    if t_range and t_index != t_range[0]:
        self.log("deleted a to_send char", color="yellow")
        # nothing more to do
        has_to_delete = None
    else: 
        # deleted text
        delta = -1
        has_to_delete = 1


if has_to_delete:
    # at his point the deletion was efectued over a non to_send char, and it need to be registered in the deletion buffer.
    # we register sequences of deletion or suppr key, if the user press any other key, deletion_buffer will be flushed by flush body. If the deletion_buffer was not flushed that means that the last key that was pressed is a deletion or suppression key.
    
    if self.deletion_buffer: # updating a deletion buffer
        &lt;&lt; update the deletion buffer &gt;&gt;
    else: # need to create a new deletion buffer
        &lt;&lt; create a new deletion buffer &gt;&gt;
</t>
<t tx="rodrigob.20040125154815.15">startpos, t_len = self.deletion_buffer
startpos += delta				
t_len += 1
self.deletion_buffer = (startpos, t_len)

#self.log("fill body: updated the deletion buffer [startpos, len] == %s" % ([startpos, t_len]), color="yellow" ) # just for debugging</t>
<t tx="rodrigob.20040125154815.16"># obtain the startpos; omiting the old_to_send ranges

old_insert = index_to_list(old_insert)
    
if t_range: # if the old_insert touch a range
    # t_range store the range that touch our index. We know that the ranges are ordered from little to bigger. So we cut the old_to_send_ranges list (but including the touching range).		
    # convert the tuple of "line.column" indexes to a list of indexes.
    iter_ranges = iter(ranges)
    ranges= []
    for t_index in iter_ranges:
        ranges.append((t_index, iter_ranges.next()))
    ranges = ranges[:ranges.index(index_to_list(t_range)) + 1]
else:
    # we gonna have to search the ranges, knowing that they do not touch our index
    t_ranges = []
    for i in xrange(0, len(ranges), 2):	
        stop   = index_to_list(ranges[i+1])
        if old_insert &gt; stop:
            start  = index_to_list(ranges[i])
            t_ranges.append((start, stop))
            
    ranges = t_ranges
    
# now we have the list of "to_send" ranges that are found in the range ["1.0", "insert"]

# we convert it to a [(pos, length), (pos, length), ...] form
old_text = old_text.split("\n")
t_ranges = []
for t_range in ranges:	
    t_ranges.append( range_to_pos_and_length(t_range[0], t_range[1], old_text) )

# we obtain the linear startpos
t_startpos  = old_insert[1] + reduce(lambda x,y: len(y) + x, old_text[:old_insert[0]-1], 0) + (old_insert[0]-1) # columns + rows length + "\n" chars


# and finally we obtain the real startpos by eliminating the to_send ranges.
startpos = t_startpos
for pos, length in t_ranges:
    if pos &lt; t_startpos:
        startpos -= min(length, t_startpos - pos)

# so we create the deletion_buffer !		
startpos += delta				
t_len = 1
self.deletion_buffer = (startpos, t_len)

#self.log("fill body: created a new deletion buffer [startpos, len] == %s"%([startpos, t_len]), color="yellow" ) # just for debugging
</t>
<t tx="rodrigob.20040125154815.17"># a 'normal' key was typed
# the flush command is called for every key OnBodyKey1
# the flush command check the deletion buffer and flush it as necessary
                    
for tag in self.text_widget.tag_names(): #clean up any other tag
    if tag not in ["sel", "to_send"]:
        self.text_widget.tag_remove(tag, old_insert)
        
# mark the actual chars					
self.text_widget.tag_add("to_send",  old_insert)		

#self.log("%s"%(ch), color="yellow") # just for debugging
</t>
<t tx="rodrigob.20040125154815.18">

# some text was pasted in the body
        
# get the old_star and old_end indexes

old_paste_start  = keywords["oldSel"][0]
old_paste_stop   = keywords["newSel"][0]

# mark the inserted chars					
self.text_widget.tag_add("to_send",  old_paste_start, old_paste_stop)		


# tadaa!</t>
<t tx="rodrigob.20040125154815.19">def flush_body(self, keywords={}, all=0):
    """
    Send all the "to_send" that acomplish the criteria, send the operation related to the deletion buffer if necessary.
    This is the function that normally generate the operations to be sent (sometimes fill_body create some of them).
    This function is called at the end of fill_body and by idle_body_key if the user press non editing keys.
    """
    
    #self.log("flush_body: being called", color="yellow") # just for debugging
                
    #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;EDIT THIS CODE should include a deferred.timeout operation that calls flush(all)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

    # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; end of experimental code

    undo_type       = keywords.get("undoType")
    ch              = keywords.get("ch")
    
    if self.deletion_buffer:
        if ((undo_type == "Typing" and ch not in ['\x7f', '\x08']) or all):  # at the end of a chunk deletion, that is, the user was deleting (using delete or suppr) but now he has pressed any other key, so we have to send the operation.
        
            # flush the deletion buffer
            deferred = self.send_operation("delete_text", self.deletion_buffer[0], self.deletion_buffer[1])
            
            self.log("deletion_buffer executed with value (%i %i)"%(self.deletion_buffer[0], self.deletion_buffer[1]), color="yellow") # just for debugging
                            
            self.deletion_buffer = ()	
    
        

    # flush the insertions
    text = self.text_widget
    #ranges = old_tags_ranges
    # flush body does not require to care about the past, only about the present.
    ranges = self.text_widget.tag_ranges("to_send")
    insert_index= "insert"
    
    for i in xrange(0, len(ranges), 2):	
        start  = ranges[i]
        stop   = ranges[i+1]
        t_text = None 

        # self.log("(%s,%s)"%(start, stop), color="yellow") # for debugging
                
        # conditions for text flushing -~-~-~-~-~-~-~-~-~-~
        tt_text = text.get("%s - 2 chars"%(stop), stop)
        
        if len(tt_text) == 2 and tt_text[1] in [' ', '\n'] and tt_text[0] != tt_text[1]: # when the user finish a word and insert a space or an enter.
            t_text = text.get(start, stop)		

        elif (		text.compare(insert_index, "&lt;", "%s - 5  chars"%(start)) 
            or  text.compare(insert_index, "&gt;", "%s + 5  chars"%(stop) ) ): # if we are 5 chars away from a chunk
            t_text = text.get(start, stop)
            
        elif (   text.compare(insert_index, "&gt;", "%s + 1 lines"%(stop) )
              or text.compare(insert_index, "&lt;", "%s - 1 lines"%(start)) ) : # if we are 1 lines away from a chunk
            t_text = text.get(start, stop)

        elif (   text.compare(stop,   "&gt;", "%s + 2 lines"%(start) )
              or text.compare(stop,   "&gt;", "%s + 30 chars"%(start)) ) : # if the chunk has more than 2 lines or is bigger than 30 chars.
            t_text = text.get(start, stop)

            
        elif all: # if we have to flush every dirty char
            t_text = text.get(start, stop)
            
        # check if the conditions trigered some text flushing  -~-~-~-~-~-~-~-~-~-~

    
        if t_text:
            #self.log(t_text, color="orange") # for debugging
            #self.log("flush_body, flushing the range (%s,%s)"%(start, stop), color="yellow") # for debugging
            
            # transform the start index to a lineal index
            startpos = len(text.get("1.0", start))
            
            # remove the tags
            text.tag_remove("to_send", start, stop)
            
            # send the data
            self.send_operation("insert_text", startpos, t_text)
            
    return
</t>
<t tx="rodrigob.20040125160038">@
Some views, for a more confortable work. Keep near, related topics.
This views does not cover all the aspects of the code. There are very important topic not put here. 
Only relevant and disemined element are represented in this code perspectives.

For more information about the code read the "LeoN.leo/Docs/developers docs/Code explanation" node.
@c
@color</t>
<t tx="rodrigob.20040125192325">def get_text_selection (self):
    """
    Return a tuple representing the selected range of body text.
    Return a tuple giving the insertion point if no range of text is selected.
    """

    text_widget = self.text_widget
    sel = text_widget.tag_ranges("sel")

    if len(sel) == 2:
        return sel
    else:
        # Return the insertion point if there is no selected text.
        insert = text_widget.index("insert")
        return insert,insert</t>
<t tx="rodrigob.20040125194534">class ChalksAvatar(pb.Avatar, pb.Referenceable):
    """
    &lt;&lt;&lt;&lt;&lt;&lt;&lt; ADD CONTENT HERE
    what other users (childrens) can do here (at the parent). 
    The avatar instance is created when the user connects to the local node, and it defines what he can do here.
    
    The server side representation of the user.
    There is one avatar instance per client connection to the server
    """
    
    def __init__(self, avatarId, mind, chalks_gui = None):
        """
        """
        
        assert chalks_gui
        self.chalks_gui = chalks_gui
        self.node = chalks_gui.node
        
        self.mind = mind # store it for later use # mind is a perspective of the client that is connecting to use
        self.avatarId = self.nickname = avatarId
        if self.mind: self.mind.nickname = avatarId
            
        # this assertion has to be relaxed to enable childrens side avatar creations
        #assert mind, ChalksError("Chalks strictly require references to the client connecting.")
    
        #if mind: assert type(mind) is pb.Reference # if mind assert it is a remote reference
        
        #pb.Avatar.__init__(self, avatarId, mind) # pb.Avatar has no __init__ method.
        

        # copy every perspective_ method in remote_ method
        perspective_methods = ['_'.join(x.split('_')[1:]) for x in dir(self) if x.split('_')[0] == "perspective"] # ugly hack
        #print "Avatar perspective_methods", perspective_methods
        for t_name in perspective_methods:
            if t_name:
                setattr(self, "remote_"+t_name, getattr(self, "perspective_"+t_name))
                #print "Added method %s to ChalksAvatar class"%("remote_"+t_name)


        return
        
    @others</t>
<t tx="rodrigob.20040125200531">class DummyChecker:
    """
    gives access to everyone
    """
    __implements__ = checkers.ICredentialsChecker

    credentialInterfaces = (credentials.IUsernamePassword, credentials.IUsernameHashedPassword)

    def requestAvatarId(self, credential):		
        """
        give access to everyone that requests it
        """
        if 1:
            return credential.username
        else:
            return failure.Failure(error.UnauthorizedLogin("'%s' is not listed in the authorized users list." % credential.username))

</t>
<t tx="rodrigob.20040125200531.1">class ChalksRealm:
    """
    Provide access to a ChalksAvatar
    """
    __implements__ = portal.IRealm
                                     
    def __init__(self, chalks_gui):
        self.chalks_gui = chalks_gui                                                                                                                             
    def requestAvatar(self, avatarId, mind, *interfaces):
        if pb.IPerspective in interfaces:
            avatar = ChalksAvatar(avatarId, mind, self.chalks_gui)
            return pb.IPerspective, avatar, avatar.logout
        else:
            raise NotImplementedError("no interface")

</t>
<t tx="rodrigob.20040125210836">@
this code is at the class Chalks level
@c</t>
<t tx="rodrigob.20040125211222">
def save_text(self,):
    """
    Effectivelly flush the text to the local file.
    """
    
    assert hasattr(self, "file"), "No open file to save in"
    
    self.file.seek(0) # go back to the start
    text= self.text_widget.get("1.0", END)
    self.file.write(text)
    self.file.truncate() # mark the end of the file
    # we are done
    
    self.saved_version_hash = hash(text) # used to check later changes
    return
</t>
<t tx="rodrigob.20040125213003">def connect_to_callback(event=None):
    """
    what happens when the "Connect to" button is pressed
    """
    # if required, request a save as 
    if self.is_dirty():
        if self.filename: 
            message = "File \"%s\" contains changes not yet saved.\nOnce connected, a new text will be downloaded.\nDo you want to save the current file before connecting ?" % self.filename
        else:
            message = "The text has not been saved.\nOnce connected, a new text will be downloaded.\nSave before connecting ?"
    
        ret = self.askYesNoCancel("Save and connect to ...", message) # ret 1, 0 or -1 for cancel
    
        if ret == 1:
            # save the file
            ret = self.onSave()
            if not ret: # did not saved
                return # do not quit

        elif ret == -1:
            print "you canceled the connection process"
            return
    
    port     = int(port_entry.get()) # connect_to_parent now expects an int as the port
    address  = address_entry.get()  
    nickname = nickname_entry.get()
    
    top.destroy() 
    # start the connection 
    self.node.connect_to_parent(address, port, nickname)
    return
</t>
<t tx="rodrigob.20040125213003.1">def validation_callback(event=None):
    """ simple callback that check every 200 ms if the filled data is valid"""

    port    = port_entry.get()
    address =  address_entry.get()  
    
    if address:
        title = "Connect to %s:%s" % (address, port)
    else:
        title = "Connect to ..."
    top.title(title)
    
    condition =  address and port.isdigit() and len(nickname_entry.get()) &gt; 3
    
    if condition:
        button_connect_to.config(state=NORMAL)
    else:
        button_connect_to.config(state=DISABLED)
        
    button_connect_to.after(200, validation_callback) # call each 200 ms
    
    return
</t>
<t tx="rodrigob.20040125223416">@
what if text is inserted while a char as typed but not yet marked by the "after_idle". That would cause a 'one char' fatal error !!!
Chars marking has to be done as soon as the char is aviable; OR the text insertion have to be done when we are sure that not pending makring exist...

does this problem exists in Chalks ?</t>
<t tx="rodrigob.20040126020116">@
The network graph is a Tree.
The upper node is the first instance, that created the original content.
Down tree we found the other sessions.
Each node has one parent and possibly many childrens.
@c</t>
<t tx="rodrigob.20040126020641"># Allow external users to start collaborating
def perspective_collaborate_in(self, site_id):
    """
    Start collaborating with the node
    proceeds with site registration and returns the necessary data to configure the client (children)
    the site_id is a unique identifier of the client (child) process
    """
        
    self.site_id = site_id
    if self.mind: self.mind.site_id = site_id
    
    assert self.mind, ChalksError("Avatar without mind trying to collaborate in")
    self.node.add_site(self.mind) # we register our perspective in the parent
    print "Registering child perspective %s" % self.mind
    
    # we obtain and return the required data to start the session in the child
    t_state = self.node.get_state(); t_state = list(t_state);
    # Convert HB Operation objects to diccionaries
    t_HB = t_state[3]; t_HB = map(dict, t_HB); t_state[3] = t_HB;
    
    # return the parent ChalksNode reference, and the data necesarry to start the collaboration
    return t_state
    

def perspective_collaborate_out(self):
    """
    Logout from the collaborative server associated to the selected node
    """

    # logout of the Collaborative Node
    self.node.del_client(self)
    
    self.site_id = None
    
    return
    </t>
<t tx="rodrigob.20040127182438">@
This are the method the Avatars are suposed to access. This are the only method that other nodes should be able to call.

The ChalksAvatar implementation have to be consistent with this ChalksNode methods.
@c</t>
<t tx="rodrigob.20040127184605">def remote_send_message(self, received_from, from_, to, txt):
    """ 
    received_from: perspective that gave to us the message
    from: string, nickname of the emitter
    to: string, nickname of the receiver
    txt: the message
    
    A remote node send a message to us
    we repeat it to every known node except from the one that gived the message to us
    if to is None, the message will be spread to all, else it will be sent only to the users named like to
    """


    if (not to) or (to == self.nickname):    
        self.log("&lt;%s&gt; %s" %(from_, txt) )
    
    
    perspectives = self.childrens_perspectives + [self.parent_perspective]

@        
    # diagnose code
    #print "&lt;%s&gt; %s" %(from_, txt)
    print "received_from %s" % received_from
    #print "perspectives %s" % perspectives
    print "[x==%s for x in %s] == %s" %(received_from, perspectives, [x==received_from for x in perspectives])
@c
@
    if self.parent_perspective: self.parent_perspective.callRemote("send_message", from_, to, txt).addErrback(lambda _, name: self.log_error("Could not send the message from user %s to user %s"), from_, to)
    return # to avoid horrible loop
@c
    
    for t_perspective in perspectives:
        if t_perspective and received_from != t_perspective:
            #print "%s.callRemote('send_message', ..." % t_perspective
            t_deferred = t_perspective.callRemote("send_message", from_, to, txt)
            t_deferred.addErrback(lambda _, name: self.log_error("Could not send the message from user %s to user %s"), from_, to)
    #print
    
    return
</t>
<t tx="rodrigob.20040128005315">def exception(self, error):
    """
    manage the exceptions
    'error' should be a Failure (or subclass) holding the MyError exception, 
    error.{type , getErrorMessage, __class__, getBriefTraceback, getTraceback}
    """	
    
    #error.trap(ChalksError) # to manage silently that exceptions
    #raise error # raise the remote error, short error message (brief traceback)
    
    # "&lt;Error!&gt; Got a remote Exception\n&lt;%s&gt;&lt;%s&gt; %s " 
    self.log_error( "&lt;Error!&gt;&lt;%s&gt;\n%s"%(error.type, error.getErrorMessage()) )
    self.log_error( "&lt;Debug&gt; %s"% error.getTraceback()) # only for debugging
    return



</t>
<t tx="rodrigob.20040128011809">@
what happen when a new node appear in the network
or when we are notified that a node quited it
@c

@others
</t>
<t tx="rodrigob.20040128011816">def receive_operation(self, in_op, *args, **kw):
    """
    This the method called when a new operation arive to the local machine (or process).
    
    Will check the data form, adapt the known information of the remote sites, and process the operation itself.
    The incoming timestamp is expected to be a dictionary, that will here be converted back to a normal timestamp (that is only valid in the local space).
    
    The received operation is repeated to all the connected sites (parent and childrens if the node), except to the emisor
    """

    # convert the data in an Operation object
    if not isinstance(in_op, Operation):
        try:
            assert len(args) == 2
            in_op = Operation(in_op, args[0], args[1])
            for k in kw:
                in_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(in_op, args, kw)
            
            
    # convert the dictionary timestamp to a normal state vector, if necesary register new sites - ---
    timestamp = in_op.get("timestamp")
    
    assert type(timestamp) is dict or in_op.get("source_site") == self.site_index, "In ConcurrentEditableNode the transmited time stamps are expected to be dictionaries that map &lt;known_site_id&gt; =&gt; &lt;num_of_operations_we_know_he_has_created&gt; OR to be a local state vector timestamp.\ntype(timestamp) == %s, timestamp == %s" % (type(timestamp), timestamp)


    if type(timestamp) is dict: # convert the dict timestamp in a normal state vector           
        for site_id, value in timestamp.items():
            t_timestamp = [0,]*len(self.sites_index)
            try:
                t_timestamp[self.sites_index[site_id]] = value
            except KeyError: # the site_id key was unknown
                # a new site apeared
                print "New site appeared, site_id == %s" % site_id # just for debuging
                self.add_site(site_id) # add a new site to the know sites list, and adapt the timestamps
                t_timestamp.append(value)
                
    elif type(timestamp) is list: # if normal state vector, obtain the dict timestamp
        t_timestamp = timestamp
        timestamp   = {}
        for site_id, pos in self.sites_index.items():
            timestamp[site_id] = t_timestamp[pos]
    else:
        raise TypeError, "expected a dict or list timestamp. Umnanaged type %s" % type(timestamp)

    # send the operation to all the other clients -- --    
    for site_id in self.connected_sites:
        if site_id == in_op["source_site"]: continue # do not send back to the emisor	
        self.send_operation(site_id, in_op) # send it
           
    # process locally --- -
    
    # overwrite the dictionary timestamp with the new list timestamp
    in_op["timestamp"] = t_timestamp
    
    
@ old weird bug
    for t_op in self.HB:
        if t_op["timestamp"] == timestamp:
            print "&lt;strange&gt; Strange network conditions have created a twin message reception. Will be omited. (twin: %s, recieved: %s)"%(t_op, str((in_op, args, kw)))
            return
@c

    ConcurrentEditable.receive_operation(self, in_op) # receive the operation
            
    return

receive_op = receive_operation # alias</t>
<t tx="rodrigob.20040128011921">@
This method have to be overwritten for network transfers support.
@c
</t>
<t tx="rodrigob.20040128011921.1">def connect_to_parent(self, parent_reference):
    """
    This method only establish the network connection with the parent. After this, 'self.collaborate_in' has to be called to enter into the collaborative edition session.
    
    Obtain a reference of the parent
    Define own node id
    
    Dummy implementation for testing purpose. This method should be overwritten to manage network methods.
    """
    
    # register the parent 
    self.parent_perspective = parent_reference
    
    self.id = id(self) # local python session unique id
    # in the network implementation this should an internet unique id (normally ip+tcp_port)
    
    
    self.receiving_parent_state = 1 # this tag is used to block incoming child conections until we set the parent state

    return



</t>
<t tx="rodrigob.20040128011939">def send_operation(self, site_index, t_op):
    """
    This function is called by 'receive operation' when the node repeat the message to his neighbors.
    This function has in charge to make sure that an operation will arive to the indicated site.
    
    This method should be overwritten for real network transmision. 
    Test implementation is presented here.
    I repeat, This method should be overwritten to send the object over the network.
    """
    
    if 1:
        if dbg&gt;=1: print "send_op; sending to S%s %s"%(site_index, t_op)
        global sent_test_operations
        sent_test_operations.append(t_op)
        
    return

</t>
<t tx="rodrigob.20040128012459">def collect_garbage(self):
    """
    Due to the possible appearance of new sites we 'keep alive' the deleted operations.
    They are reincorporated to the HB, but marked to a sure die after a timeout.
    """
    
    deleted_list = ConcurrentEditable.collect_garbage(self)
    
    raise NotImplementedError, "Too complicated (would require threads) to implement it without a twisted reactor"
    
    return


</t>
<t tx="rodrigob.20040128012627">def generate_operation(self, type, pos, data, **kws):
    """
    The site generate an operation, and apply it locally.
    """
    # create and apply
    t_op = ConcurrentEditable.generate_operation(self, type, pos, data, **kws)

    return Operation(**t_op) # return a copy of the operation
    </t>
<t tx="rodrigob.20040128013418">def __init__(self, text=u""):
    """
    &lt;&lt;&lt;&lt; EDIT THIS CONTENT
    
    OLD SERVER TEXT
    Simple Observer and operations repeater.
    It manage all the conection/disconnection syncronization problems.
    """
    
    assert type(text) is unicode, "Internal text data is managed as unicode data. Tried to initialize the ConcurrentEditableNode with data %s '%r'" % (type(text), text)
            
            
    # init the internal ConcurrentEditable
    ConcurrentEditable.__init__(self, 0, 1) # (self, site_index, num_of_sites) 
    # we consider ourself as part of the network. We are always the first of use local sites indexing
    
    self.parent_perspective = None # the perspective of the parent node
    self.connected_sites = {} # the map &lt;connected sites id&gt; =&gt; &lt;site remote perspective object&gt;
    
    self.receiving_parent_state = 0 # tag used to indicate a sensible state where other client can not connect to us
    
    self.id = None # the identifier of this node
    self.sites_index = {} # map &lt;known site id&gt; =&gt; &lt;local site index&gt;
    
    self.text_buffer = text
        
    return
</t>
<t tx="rodrigob.20040128013509">
def TestConcurrentEditable1():
    """
    The test case that we gonna use for debugging is the same case presented at "A generic operation transformation scheme for consistency maintenance in real-time cooperative editing systems", Fig 1; wich suggest an interesing scenario.
    Here the operatations are:
        - O1 Insert 0 "ABC"
        - O2 Insert O "BCD"
        - O3 Delete 1 2
        - O4 Insert 2 "c"
    So the final result should be "ABCcD" in the three sites.
    
    Site 0: (generate O1) O1 O2 O4 O3
    Site 1: (gen O2) O2 O1 (gen O3) O3 O4
    Site 2: O2 (gen 04) 03 01
    
    The event sequence is:
        S0(O1);S1(O2);S2O2;S1O1;S0O2;S2(O4);S0O4;S1(03);S2O3;S0O3;S1O4;S2O1. 
        
    It also test the garbage collector as indicated in the figure 3 of sun98achieving.pdf, page 20.
    """
    
    print "-"*15
    print "Read docstring of TestConcurrentEditable1 for more info about this test.\n"
    
    # Create three site instances
    num_sites = 3
    site0 = ConcurrentEditable(0, num_sites) # site_index, num_of_sites
    site1 = ConcurrentEditable(1, num_sites)
    site2 = ConcurrentEditable(2, num_sites)
    
    # Apply the operations in each site (following the order of the picture)
    
    O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1")  # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2") # test the alias
    site2.receive_op(O2)
    site1.receive_op(O1)
    site0.receive_op(O2)
    O4 = site2.gen_op("Insert", 2, u"c", dbg_name="O4") 
    site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3")
    site2.receive_op(O3)
    site0.receive_op(O3)
    site1.receive_op(O4)			
    site2.receive_op(O1)
    
    
    if dbg&gt;=4:
        for t_op in [ O1, O2, O3, O4]:
            print t_op
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)

        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage() # at site2 two operations should be deleted
    

    
    if dbg&gt;=0:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;MSV %s;\nHB\n\t%s\n"%(t_site.site_index, t_site.state_vector, t_site.minimum_state_vector, "\n\t".join([str(x) for x in t_site.HB]))
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [site0, site1, site2]:
        t_res = (t_site.get_text() == u"ABCcD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'ABCcD', and no delayed operations left in the buffer."


    return success

</t>
<t tx="rodrigob.20040128013523">def TestConcurrentEditableServer():
    """
    Run almost exactly the same case of TestConcurrentEditable1 but using a Star network; with one central server and three clients connecting to it.
    """
    
    #global dbg
    #dbg = 0 #1 # ;P
    
    # when dbg==1 this is a __very__ verbose test, but it allow a good tracking of every event.
    
    print "-"*15
    print "Read docstring of TestConcurrentEditableServer for more info about this test.\n"
    
    # creates server
    server = ConcurrentEditableServer()
    
    # connect site 0 and 1
    site0 = ConcurrentEditableClient(server)
    site1 = ConcurrentEditableClient(server)
    
    global sent_test_operations; 	sent_test_operations = [] # used for delaying the transmissions in the test
    
    # start editions
    # Apply the operations in each site (following the order of the picture)
    O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1", gen_site="0") # generate and apply locally the operation
    O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2", gen_site="1") # test the alias

    # O*_toS* is an operation that was sent by the server to the client. This object is delayed to simulate delays in the transmissions lines.
    # the order of reception of commands is similar of the TestConcurrentEditable1
    server.receive_op(O2); 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O2_toS0] = sent_test_operations; sent_test_operations = []	
    server.receive_operation(O1);
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    [O1_toS1] = sent_test_operations; sent_test_operations = []	
    
    # connect site 2 (to test connection during sessions)
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    
    if dbg&gt;=1:
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    sent_test_operations = []
    
    # continue editions
    site1.receive_op(O1_toS1) # receive delayed operations sent by the server
    site0.receive_op(O2_toS0)
    O4 = site2.gen_op("Insert", 2, u"c", dbg_name="O4", gen_site="2") 
    server.receive_op(O4); O4_toS0, O4_toS1 = sent_test_operations; 
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    sent_test_operations = []	

    
    # test disconnection and site_index reusage (for reconnetion connection)
    if dbg&gt;=1: 
        print "\nDisconnectiong S2"
        
    server.del_client(site2)	
    if dbg&gt;=1: print "\nReconnection S2"
    site2 = ConcurrentEditableClient()	
    site2.connect_to_server(server)
    if dbg&gt;=1: 
        print "Site2 after reconnecting"
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
    
    site0.receive_op(O4_toS0)
    O3 = site1.gen_op("Delete", 1, 2, dbg_name="O3", gen_site="1")
    server.receive_op(O3);	
    if dbg&gt;=1: print "sent_test_operations %s\n"%sent_test_operations
    O3_toS0, O3_toS2 = sent_test_operations; sent_test_operations = []	
    site2.receive_op(O3_toS2)
    site0.receive_op(O3_toS0)
    site1.receive_op(O4_toS1)
    
    # Original sequence------------------
    #O1 = site0.gen_op("Insert", 0, u"ABC", dbg_name="O1")  # generate and apply locally the operation
    #O2 = site1.gen_Op("Insert", u"BCD", 0, dbg_name="O2") # test alias
    #site2.receive_op(O2)
    #site1.receive_op(O1)
    #site0.receive_op(O2)
    #O4 = site2.gen_op("Delete", 0, 3, dbg_name="O3")
    #site0.receive_op(O4)			
    #print "\ntest blocked..."; return # please erase this line
    #O3 = site1.gen_op("Insert", 5, u"c", dbg_name="O4")
    #site2.receive_op(O3)
    #site0.receive_op(O3)
    #site1.receive_op(O4)			
    #site2.receive_op(O1)
    # ------------------

    if dbg&gt;=1:	
        print
        print "Server; %s; '%s'; HB %s"%(server.state_vector, server.get_text(), server.HB )
        print "Site 0; %s; '%s'; HB %s"%( site0.state_vector,  site0.get_text(),  site0.HB )
        print "Site 1; %s; '%s'; HB %s"%( site1.state_vector,  site1.get_text(),  site1.HB )
        print "Site 2; %s; '%s'; HB %s"%( site2.state_vector,  site2.get_text(),  site2.HB )
        print
        
    
    if dbg&gt;=1:
        print "\nDirty HBs"
        for t_site in [server, site0, site1, site2]:
            print "Site %s;%s;HB %s; delayed_ops %s"%(t_site.site_index, t_site.state_vector, t_site.HB, t_site.delayed_operations)
        print
            
    if 1:
        # this messages are the same of figure 3. sun98achieving.pdf, page 20.
        site1.update_SVT(0, site0.state_vector) # message to put to date the other sites
        site2.update_SVT(0, site0.state_vector)
        if dbg&gt;=1: print "Manually collecting the garbage in all sites"
        server.collect_garbage()
        site0.collect_garbage()
        site1.collect_garbage()
        site2.collect_garbage()
    
    # --------	
    # disconnect
    if dbg&gt;=1: print "Disconnecting the three sites."
    server.del_client(site0)	
    server.del_client(site1)	
    server.del_client(site2)	
    # --------------
        
    if dbg&gt;=0:
        print "\nFinal HBs"
        for t_site in [site0, site1, site2]:
            print "Site %s;%s;MSV %s;\nHB\n\t%s\n"%(t_site.site_index, t_site.state_vector, t_site.minimum_state_vector, "\n\t".join([str(x) for x in t_site.HB]))
    
    # Show the final result at each site (expecting "ABCC'D")

    res_text = lambda x: "OK."*x or "FAILED."*(not x)

    print "\nFinal results:"	
    
    success = 1
    for t_site in [server, site0, site1, site2]:
        t_res = (t_site.get_text() == u"AcBCD" and not t_site.delayed_operations)
        success = success and t_res
        print "Site %s;%s; '%s'; delayed_ops: %s; %s"%(t_site.site_index, t_site.state_vector, t_site.get_text(), t_site.delayed_operations, res_text(t_res))


    if success:
        print "\nTest successfull."
    else:
        print "\nTest FAILED. Expecting the same result at the three sites: 'AcBCD', and no delayed operations left in the buffer."


    return success</t>
<t tx="rodrigob.20040129130513.1"></t>
<t tx="rodrigob.20040129130513.2">def isUnicode(s):
	
	return s is None or type(s) == type(u' ')</t>
<t tx="rodrigob.20040129130513.3">def isValidEncoding (encoding):
	
	try:
		if len(encoding) == 0:
			return false
		unicode("a",encoding)
		return true
	except:
		return false
</t>
<t tx="rodrigob.20040129130513.4">def reportBadChars (s,encoding):
	
	errors = 0
	if type(s) == type(u""):
		for ch in s:
			try: ch.encode(encoding,"strict")
			except: errors += 1
		if errors:
			# import traceback ; traceback.print_stack()
			es("%d errors converting %s to %s" % 
				(errors, s.encode(encoding,"replace"),encoding))

	elif type(s) == type(""):
		for ch in s:
			try: unicode(ch,encoding,"strict")
			except: errors += 1
		if errors:
			es("%d errors converting %s (%s encoding) to unicode" % 
				(errors, unicode(s,encoding,"replace"),encoding)) # 10/23/03</t>
<t tx="rodrigob.20040129130513.5">def toUnicode (s,encoding,reportErrors=false):
	
	if s is None:
		s = u""
	if type(s) == type(""):
		try:
			s = unicode(s,encoding,"strict")
		except:
			if reportErrors:
				reportBadChars(s,encoding)
			s = unicode(s,encoding,"replace")
	return s
	
def toEncodedString (s,encoding,reportErrors=false):

	if type(s) == type(u""):
		try:
			s = s.encode(encoding,"strict")
		except:
			if reportErrors:
				reportBadChars(s,encoding)
			s = s.encode(encoding,"replace")
	return s</t>
<t tx="rodrigob.20040129130513.6">try:
	# Use Python's version of getpreferredencoding if it exists.
	# It is new in Python 2.3.
	import locale
	getpreferredencoding = locale.getpreferredencoding
except:
	# Use code copied from locale.py in Python 2.3alpha2.
	if sys.platform in ('win32', 'darwin', 'mac'):
		&lt;&lt; define getpreferredencoding using _locale &gt;&gt;
	else:
		&lt;&lt; define getpreferredencoding for *nix &gt;&gt;
</t>
<t tx="rodrigob.20040129130513.7"># On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = true):
	"""Return the charset that the user is likely using."""
	try:
		import _locale
		return _locale._getdefaultlocale()[1]
	except:
		return None</t>
<t tx="rodrigob.20040129130513.8"># On Unix, if CODESET is available, use that.
try:
	local.CODESET
except NameError:
	# Fall back to parsing environment variables :-(
	def getpreferredencoding(do_setlocale = true):
		"""Return the charset that the user is likely using,
		by looking at environment variables."""
		try:
			return locale.getdefaultlocale()[1]
		except:
			return None
else:
	def getpreferredencoding(do_setlocale = true):
		"""Return the charset that the user is likely using,
		according to the system configuration."""
		try:
			if do_setlocale:
				oldloc = locale.setlocale(LC_CTYPE)
				locale.setlocale(LC_CTYPE, "")
				result = locale.nl_langinfo(CODESET)
				locale.setlocale(LC_CTYPE, oldloc)
				return result
			else:
				return locale.nl_langinfo(CODESET)
		except:
			return None</t>
<t tx="rodrigob.20040129132740"></t>
<t tx="rodrigob.20040129141624">@
Code related to the Chalks network and his related events
@c</t>
<t tx="rodrigob.20040129150513">def logout(self,):
    """
    This methods is called when the children node is disconnecting himself
    """
    
    # &lt;&lt;&lt;&lt; EDIT CODE # has to generate the propagation of a disconnection notification to all the other nodes....
    
    print "Avatar is login out self.avatarId == %s" % self.avatarId # just for debugging
    print "User '%s' is quiting the session" % self.nickname
        
    return
</t>
<t tx="rodrigob.20040129165804">def add_site(self, site_id):
    """
    Add a site to the list of known sites.
    Known sites (normally all the nodes of the network) are possibly more than connected_sites (parent and childrens of the node)
    When adding a site, his reference is stored and the state_vectors are expanded.
    
    Assign a site index. 
    Expand the history buffer timestamps and the SVT timestamps (this mean; all the stored timestamps). Take care to expand the timestamps of the operation embedded into other ones (RA, LI, etc...).

    The known sites are listed in the .sites_index that map &lt;site_id&gt; =&gt; &lt;site_index&gt;
    """
    

    if dbg&gt;=1:
        print "Adding a site into this node."
        print "Server HB %s"%self.HB

            
    # register the client
    if site_id in self.sites_index.keys():
        raise "Site already registered connected, addition rejected."
        return
    
    # assign a site index
    site_index = len(self.sites_index) # == len(self.state_vector)
    # always add a new entry at the end of the state vectors (timestamps)
     
    # register the site
    self.sites_index[site_id] = site_index
    if site_id == self.id: # also update our self site_index (that is non zero, as it could be supossed)
        self.site_index = site_index

    &lt;&lt; expand the vectors and matrices &gt;&gt;
    
    if dbg &gt;= 1:
        print "After adding a site to the node"
        print  "Server HB", self.HB 

    return


</t>
<t tx="rodrigob.20040129165804.1">def del_site(self, site_id):
    """
    This method is called when we receive a disconnection message
    """
    
    raise NotImplementedError, "not yet"
    
    return



        
def del_client(self, client_index):
    """
    Eliminate the reference in the state_vectors of one specific client that has disconnected.
    """
    
    i = client_index
    
    # update the site_index mapping ----
        
    # shrink the vectors and matrices
    shrink = lambda x: hasattr(x, "__delslice__") and x.__delslice__(i, i+1) # delete the 'i'th item
    
    shrink(self.state_vector)
    
    for t_vector in self.state_vector_table:
        shrink(t_vector)
        
    shrink(self.state_vector_table)
    shrink(self.minimum_state_vector)

    # shrink the operations timestamp in the HB
    for t_op in self.HB:
        shrink(t_op["timestamp"])
        
        if t_op.get("base_operation"): # RA: relative address
            shrink(t_op["base_operation"]["timestamp"])
            
        if t_op.get("splitted_head") and t_op.get("splitted_tail"): # Splitted
            shrink(t_op["splitted_head"]["timestamp"])			
            shrink(t_op["splitted_tail"]["timestamp"])			
            
        if t_op.get("lost_information"): # LI: lost information
            try:
                shrink(t_op["lost_information"].get("timestamp"))
            except:
                pass
            try:
                shrink(t_op["LI_base_op" ].get("timestamp"))
            except:
                pass
                
    
    return
        




</t>
<t tx="rodrigob.20040129165804.2">def del_client(self, client_perspective):
    """
    The inverse of add_client.
    """
    
    if not self.connected_sites.has_key(client_perspective):
        return # if not connected, nothing to disconnect
    
    # delete the client
    i = self.connected_sites[client_perspective]
    
    self.indexed_sites[i] = None # mark for future reuses
    del self.connected_sites[client_perspective]
                    
    if len(self.indexed_sites) == 0: # there are no more clients connected
        # clean up the node
        self.HB = []
        self.base_text = self.get_text()
        #&gt;&gt;&gt;&gt;&gt;&gt;&gt;ADD CODE HERE (what is missing?)&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        
    return</t>
<t tx="rodrigob.20040129181502">def get_data(self,): # what and where ?
    """
    """
    
    # compute an updated base_text
    self.compute_base_text()
    # self.base_state_vector stores the state vector that corresponds to base_text
    
    # send all the necesarry data
    ops_list = []
    for t_Op in self.HB: # send the operations in the HB
        ops_list.append(dict(Operation(**t_Op)))  # copy, pass a a dict 
        
    if dbg&gt;=1:
        print	"ops_list", ops_list
        print "Now we have %s clients connected."%(len(self.connected_sites))
        print "Server HB %s"%self.HB
        print
            
    return (site_index, len(self.state_vector), self.base_state_vector, self.base_text, ops_list)
</t>
<t tx="rodrigob.20040130122927"># -------------------------------
# expand the vectors and matrices 
extra = [0]
self.state_vector.extend(extra)

for t_vector in self.state_vector_table:
    if t_vector != self.state_vector:
        t_vector.extend(extra)
    
self.state_vector_table.append([0]*len(self.state_vector))
self.minimum_state_vector.extend(extra)
#self.base_state_vector.extend(extra) #does base_state... still existing ?

#print "self.state_vector %s self.state_vector_table %s self.minimum_state_vector %s"%(self.state_vector, self.state_vector_table, self.minimum_state_vector) # just for debugging
#print "Server HB %s" % self.HB # just for debugging

assert len(self.state_vector) == len(self.state_vector_table) == len(self.minimum_state_vector)

# expand the operations timestamp in the HB and in the delayed_operations stack
for t_op in (self.HB + self.delayed_operations):
    t_op["timestamp"].extend(extra)
    
    if t_op.get("base_operation"): # RA: relative address
        t_op["base_operation"]["timestamp"].extend(extra)
        
    if t_op.get("splitted_head") and t_op.get("splitted_tail") : # Splitted
        t_op["splitted_head"]["timestamp"].extend(extra)			
        t_op["splitted_tail"]["timestamp"].extend(extra)			
        
    if t_op.get("lost_information"): # LI: lost information
        t_op["lost_information"].get("timestamp", []).extend(extra)
        t_op["LI_base_op" ].get("timestamp", []).extend(extra)

# end of references expantions -----------
</t>
<t tx="rodrigob.20040130224144">@
    site_index, num_of_sites, base_state_vector, base_text, ops_list = server_reference.add_client(self)
    # init the internal ConcurrentEditable
    ConcurrentEditable.__init__(self, site_index, num_of_sites) # site_index, num_of_sites # the clients has site_index 1, thus state_vector == [server, client]
    self.set_text(base_text)
    self.state_vector = list(base_state_vector) # copy the data # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; is this a correct idea ?
    for t_dict in ops_list: #ops_list is a list of dictionaries that define a list of operations
        self.receive_operation(Operation(**t_dict))	# instanciate and receive
    self.connected = 1
@c</t>
<t tx="rodrigob.20040130225148">def collaborate_in(self,):
    """
    Requests the current state to the parent and install it locally, using 'self.set_state'
    
    Dummy implementation for testing purpose. This method should be overwritten to manage network methods.
    """
 
    assert self.parent_perspective, "Need to be conected to a parent in order to start collaborating"

    # remote get_state
    t_state = self.parent_perspective.get_state() # &lt;&lt;&lt; this should replaced by a network call
    
    # call .set_state
    self.set_state(t_state)
    
    self.receiving_parent_state = 0
    return</t>
<t tx="rodrigob.20040130225148.1">def get_state(self,):
    """
    This returns all the data required to be fully update regarding the current editing session
    """
    
    # sites index, SVT, MSV, HB, delayed_operations, text, state_vector
    
    return (self.sites_index,
            self.state_vector_table,
            self.minimum_state_vector,
            self.HB,
            self.delayed_operations,
            self.text_buffer,
            self.state_vector)
            
</t>
<t tx="rodrigob.20040130225208">def set_state(self, state):
    """
    ovewrite all the actual state information to install a new one.
    This method is used to install the new data received by the parent, using 'get_state'
    """
    
    # sites index, SVT, MSV, HB, delayed_operations, text, state_vector
    sites_index, SVT, MSV, HB, delayed_operations, text, SV = state

    assert type(text) is unicode, "Text data is required to be unicode"
    
    # install the data
    self.text_buffer = text
    self.sites_index = sites_index
    self.state_vector_table = SVT
    self.minimum_state_vector = MSV
    self.HB = HB
    self.delayed_operations = delayed_operations
    
    # add our self to the state    
    self.add_site(self.id) # if self id is not there, add it to the actual data
    
    return</t>
<t tx="rodrigob.20040130225705">def disconnect_from_parent(self,):
    """
    Close the connection with the parent. This also will kill the conections to the childs, creating a cascade effect in the down side nodes.
    
    (in future implementations we could redirect the childrens to our parent (reference object as passable via pb ?))
        
    Dummy implementation for testing purpose. This method should be overwritten to manage network methods.
    """
    
    # delete our parent references
    
    # delete our children references

    return</t>
<t tx="rodrigob.20040824110326">@language plain</t>
<t tx="rodrigob.20040824110326.1">@nocolor

Documentation of Chalks.

Remember: Open Source is no sense if code is no usable nor reusable. To be usable the app has to be functional and documentented. To be reusable the code has to be clean, functional, commented and documented.</t>
<t tx="rodrigob.20040824110326.2">@nocolor

Code from other sources that I needed to have under my eyes.
Not interesting (mostly used in first development stages, now almost everything is in my mind or in the code and his comments).

@color
@language python</t>
<t tx="rodrigob.20040826154516">&lt;&lt;legal declaration&gt;&gt;

&lt;&lt;what is Chalks ?&gt;&gt;

&lt;&lt;features&gt;&gt;

&lt;&lt;release status&gt;&gt;

&lt;&lt;installation instructions&gt;&gt;

&lt;&lt;usage&gt;&gt;

&lt;&lt;credits&gt;&gt;




</t>
<t tx="rodrigob.20040826154614">What is Chalks ?
--------------
Chalks is a software under development for crossplatform realtime concurrent editing.
The primary focus will be ease of use and minimum requirements.

Chalks is written in Python. http://www.python.org
Chalks requires Twisted, a network module for Python. http://www.twistedmatrix.com
Chalks, Twisted and Python are open source multiplatform projects.

Chalks 2003, 2004.
http://chalks.berlios.de


</t>
<t tx="rodrigob.20040826154614.1">Features
--------

- Server/Client architecture, ultra easy usage
- Full crossplatform (inherited from python, and twisted)</t>
<t tx="rodrigob.20040826154830">###############################################################################
# This program is free software; you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program; if not, write to the Free Software                 #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
###############################################################################

This file is part of Chalks.</t>
<t tx="rodrigob.20040826154830.1">Release Status
--------------

Still in planning/design phase

Know bugs
---------

</t>
<t tx="rodrigob.20040826154830.2">Installing 
----------

To install the source package, try running, as root:

 $ python setup.py install
</t>
<t tx="rodrigob.20040826154830.3">Using
-----

To be written
</t>
<t tx="rodrigob.20040826155317">                     Chalks authors
-------------------------------------------------------------
Rodrigo Benenson Díaz (rodrigob at elo.utfsm.cl)
Ricardo Niederberger Cabral (ncabral at terra.com.br)
-------------------------------------------------------------

- The collaborative editing code is based research papers of Chengzheng Sun.

- Rendezvous.py module was written by Paul Scott-Murphy 
  (http://sourceforge.net/projects/pyzeroconf)
</t>
<t tx="rodrigob.20040831001818">@color
&lt;&lt; credits &gt;&gt;
</t>
<t tx="rodrigob.20040831002026">
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    &lt;one line to give the program's name and a brief idea of what it does.&gt;
    Copyright (C) &lt;year&gt;  &lt;name of author&gt;

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  &lt;signature of Ty Coon&gt;, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
</t>
<t tx="rodrigob.20040831002540">Files involved in the construction of a standard distribution.</t>
<t tx="rodrigob.20040831112258">@
Code related to the graphical user interface</t>
<t tx="rodrigob.20040831112258.1">@
code related to the concurrent edition system</t>
<t tx="rodrigob.20040908003956">Serious documents are wrote in Latex</t>
<t tx="rodrigob.20040908004300"></t>
<t tx="rodrigob.20040909033320">def set_text(self, new_text):
    """
    Blindly overwrite the text of this site.
    """
    
    self.text_buffer = new_text
    
    return</t>
<t tx="rodrigob.20040909060311">def start_collaborating(self, ret_tuple):
    """
    Callback for the connection procedure.        
    """

    insert_index = self.text_widget.index("insert")
    
    assert len(ret_tuple) == 7, 'wrong number of state parameters received'
    """ What's returned by get_state():
    return  self.sites_index,
            self.state_vector_table,
            self.minimum_state_vector,
            self.HB,
            self.delayed_operations,
            self.text_buffer,
            self.state_vector
    """
    #site_index, num_of_sites, base_state_vector, base_text, ops_list = ret_tuple
    t_sites_index, t_state_vector_table, t_msv, t_HB, t_delayed_operations , base_text, base_state_vector = ret_tuple

    num_of_sites = len(t_sites_index)

    # init the internal ConcurrentEditable
    from ConcurrentEditable import ConcurrentEditable
    ConcurrentEditable.__init__(self, 1,2) # site_index, num_of_sites) # site_index, num_of_sites # the clients has site_index 1, thus state_vector == [server, client] # &lt;&lt;&lt; This line seems fine, this should be managed in a different way by ConcurrentNode

    self.set_text(base_text)

    self.state_vector = base_state_vector # &lt;&lt;&lt;&lt; is this a correct idea ?

    self.log("Base state vector %s"% base_state_vector, color="yellow") # just for debugging
    self.log("Received ops_list (len == %s) %s"%( len(t_HB), t_HB), color="yellow") # just for debugging
    
    from ConcurrentEditable import Operation    
    for t_dict in t_HB: #ops_list is a list of dictionaries that define a list of operations
        self.receive_operation(Operation(**t_dict))	# instanciate and receive
    
    self.log("Setting the index mark back to his initial location: %s"% (insert_index),color="yellow")
    
    self.text_widget.mark_set("insert", insert_index) # try to keep the insert mark at the same place
    
    t_address = self.parent_perspective.broker.transport.getPeer()
    self.log("Connected to '%s:%i' as site '%s' (num_of_sites %s)"%(t_address.host, t_address.port, self.site_id, num_of_sites))
    
    self.log("HB after the connection %s"% self.HB, color="yellow") # just for debugging
    self.log("delayed_operations after the connection %s"% self.delayed_operations, color="yellow") # just for debugging
    self.log("self.state_vector %s" % self.state_vector, color="yellow") # just for debugging


    self.chalks_gui.set_connected() # set up the flag and reflect in the gui
    return
    
</t>
<t tx="rodrigob.20040912211519"></t>
<t tx="rodrigob.20040912221032">def enableChat(self):    
    """
    enables chat text entry widget
    """    
    self.chat_text_entry["state"] = NORMAL    
    self.chat_text_entry.delete('1.0', END);  
    #self.chat_text_entry.insert(END, "Enter chat text here");
    print "Chat bar now enabled"
    return
    
def disableChat(self):    
    """
    disable chat text entry widget
    """    
    self.chat_text_entry.delete('1.0', END);  
    self.chat_text_entry.insert(END, "The chat bar is disabled until someone connects to you or you connect to someone.");
    self.chat_text_entry["state"] = DISABLED
    print "Chat bar now disabled"
    
    return</t>
<t tx="rodrigob.20040912225813">@
Register/Unregister childrens in the session</t>
<t tx="rodrigob.20040912225813.1">def add_site(self, site_perspective):
    """
    Add a new children to the local node
    """
    
    if not self.connected:
        self.chalks_gui.set_connected()
        
    
    print "User %s %s is starting to collaborate" % (site_perspective.nickname, site_perspective)
    self.childrens_perspectives.append(site_perspective)
    ConcurrentEditableNode.add_site(self, site_perspective.site_id)
    
    return
    </t>
<t tx="rodrigob.20040912225813.2">def del_site(self, site_perspective):
    """
    Delete a children from the local node
    """

    print "User %s %s is quiting" % (site_perspective.nickname, site_perspective.mind)
    self.childrens_perspectives.remove(site_perspective)
    ConcurrentEditableNode.add_site(self, site_perspective.site_id)
    
    if not self.childrens_perspectives and not self.parent_perspective:
        self.connected = 0 
        self.chalks_gui.disableChat()
    return
    </t>
<t tx="rodrigob.20040913221730">def connect_to_parent(self, address, port, nickname="No name"):
    """
    Connect as a children to a parent node
    This method overwrite the ConcurrentEditableNode implementation managing the network layer
    """
    print "Requesting a connection to 'chalks://%s:%s' as '%s', please wait..." % (address, port, nickname)
    
    assert isinstance(port, int), 'port must be integer'
    self.nickname = nickname    
    
    # we will give to the parent access to a local avatar
    parent_nickname = None
    parent_mind = None
    parent_avatar = ChalksAvatar(parent_nickname, parent_mind, self.chalks_gui)
    self.parent_avatar = parent_avatar
    
    factory = pb.PBClientFactory()
    reactor.connectTCP(address, port, factory)
    deferred = factory.login(credentials.UsernamePassword(nickname, "guest"), client=parent_avatar)
    deferred.addCallbacks(self.logged_in, self.exception)

    return
    
def logged_in(self, avatar):
    """
    Start collaborating with the parent
    """

    self.avatar = avatar
    #our avatar is the our perspective to the parent ChalksNode
    self.parent_perspective = avatar
    self.parent_avatar.mind = avatar # set the avatar perspective (important)
    print "Registering parent perspective %s" % avatar 

        
    # we obtain our site_id
    t_address = self.avatar.broker.transport.getHost()
    self.site_id = hash("%s:%i" % (t_address.host, t_address.port))

    deferred = self.avatar.callRemote("collaborate_in", self.site_id)
    deferred.addCallback(self.start_collaborating).addErrback(self.exception)
                            
    return

@others</t>
<t tx="rodrigob.20040913221730.1">def disconnect_from_server(self):
    """
    Disconnect from the server.
    """

    deferred = self.avatar.callRemote("collaborate_out")
    deferred.addCallback(self.disconnected)
    deferred.addErrback(self.exception)
    
    return

def disconnected(self, *args):
    """
    Actions to be done by the ClientNode after his disconnection.
    """

    self.chalks_gui.clear_connected() # reflect in the gui the end of the connection
        
    # what should I do here ?, do I need to do something ?
    self.log("Disconnected from the old node.", color="gray") # just to do something
    
    return



</t>
<t tx="rodrigob.20040913224357">def onDisconnect(self, event=None):
    """
    Disconnect dialog
    """
    
    from tkMessageBox import askokcancel
    ret = askokcancel("Confirm disconnection",
                      "You are connected to a remote server. Opening another file will close this connection. Proceed ?")

    if not ret:
        print "Disconnection cancelled"
        return
    else:
        print "Starting disconnection"           
        
    # disconnect ourself from the network
    self.node.disconnect_from_server()
    
    return
</t>
<t tx="rodrigob.20040913232538"># where to place this node ?

def set_connected(self,):
    """
    Set the connected flag and conmute the asociated gui elements
    """
    
    # upon connection we need to enable the chat system 
    self.enableChat()
        
    # update the menu bar
    self.file_menu.entryconfig(1, label="Disconnect", command = self.onDisconnect)
    #file_menu.add_command(label="Connect to", underline=0, accelerator="Ctrl+T", command= self.onConnectTo)
    
    self.connected = 1
    return
    
def clear_connected(self,):
    """
    Clear the connected flag and conmute the asociated gui elements
    """
    
    # upon connection we need to enable the chat system 
    self.disableChat()
                
    # update the menu bar
    self.file_menu.entryconfig(1, label="Connect to", command = self.onConnectTo)
    #self.file_menu.entryconfig(1, label="Disconnect", command = self.onDisconnect)
    #file_menu.add_command(label="Connect to", underline=0, accelerator="Ctrl+T", command= self.onConnectTo)
    
    self.connected = 0
    return</t>
<t tx="rodrigob.20040913233519">@language latex
@color
\section{About the connections process}

The Children start a connection. The ChalksNode object request a connection to the parent. 

The parent receive access to the children as a reference to ChalksNode and the children gets access to the parent obtaining access to a ChalksAvatar instance created in the parent side.

ChalksNode can receive calls to the remote\_ (view\_ ) methods.
ChalksAvatar can receive calls to the perspective\_ methods.

We want the childrens able to call the ChalksNode methods. Thus when the Childrens call the collaborate\_in using his avatar on the parent side, he receive back (in a huge list of params) the parents ChalksNode reference.

The connection process occurs in this order:
\begin{enumerate}
\item ChalksNode require a connection to the parent using the {\texttt connect\_to\_parent} method. Thus a parent ChalksAvatar object is created and passed to the parent as an access to the Children. This parent ChalksAvatar instance has no {\texttt mind} object.

\item The parent receive through his {\texttt ChalksRealm} the children connection request. A children ChalksAvatar instance is created in the parent side. The parent return to the children a reference to this avatar.

\item The children receive this reference (at {\texttt logged\_in}) and register it as the parent perspective (the access of the children to the parent side). It also register this perspective as the mind of the children side parent ChalksAvatar instance.

\item Now that the children is connect he call in the parent (througth his avatar in the parent side, i.e. throught the parent perpespective) the {\texttt collaborate\_in} method.

\item The parent receive the call, register the children perspective (local children avatar mind) as one more site in the collaboration session and return to the children all the required information to start collaborating.

\end{enumerate}

It worth noting that the ChalksNode object keep only \emph{remote references} of the avatars (of the parent and of the children). When a node call a remote method in the called node receive a call from the local Avatar instance. Thus \emph{the mind} of the local Avatar is compared to the childrens and parents remote references. For a clear example look at the {\texttt send\_message} ChalksNode method.
</t>
<t tx="rodrigob.20040915120517">@
this methods are common to both children-&gt;parent calls and parent-&gt;childrens calls.
So we use only one implementation. ChalksAvatar calls ChalksNode implementation.
@c</t>
<t tx="rodrigob.20040915120517.1">def perspective_send_message(self, from_, to, txt):
    """ 
    Send a message to
    """
    return self.node.remote_send_message(self.mind, from_, to, txt)
    </t>
<t tx="rodrigob.20040915120517.2">def perspective_receive_operation(self, in_op, *args, **kw):
    """
    """
    return self.node.remote_receive_operation(self.mind, in_op, *args, **kw)
    
perspective_receive_op = perspective_receive_operation
</t>
<t tx="rodrigob.20040918184418">19/01/04 Started LeoN spinoff. RodrigoB.
21/01/04 Minor edits. RodrigoB.
23/01/04 Programming the gui. RodrigoB.
24/01/04 Working. RodrigoB.
25/01/04 Working. RodrigoB.
27/01/04 Renamed MultiEdit as Chalks. Working. RodrigoB.
28/01/04 Working. RodrigoB.
29/01/04 Working. RodrigoB.
30/01/04 Working and debugging. RodrigoB.
03/02/04 Working. RodrigoB.
12/02/04 Minor bugfix. RodrigoB.
19/02/04 Debugging. RodrigoB.

25/08/04 Project ressurected. Ricardo Niederberger Cabral joined development efforts. Logs are now keept in the svn server.
</t>
<t tx="rodrigob.20040918185607">Concurrent Editable /!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\/!\_/!\_/!\_/!\_/!\_/!\_/!\_/!\

- the base_state_vector is wrongly implemented. &lt;= DRAMA
- a posteriori connections to do not work due to error in base_state_vector and garbage collector errors! &lt;= DRAMA
=&gt; the base_text has an associated base state_vector. So we have to overwrite the system with some base state vector !

- Find a good TestConcurrentEditable2 to test LostInformation cases

- LI is absolutelly not verified
- Find the Recover_LI specifications.
- Find a better way to quit the ambiguities on the 'if else {}' operation pertenence. (save_RA, save_LI conditions ?)

</t>
<t tx="rodrigob.20040920122333">def remote_receive_operation(self, in_op, *args, **kw):
    """
    Receive an operation from a remote location
    """

    from ConcurrentEditable import Operation # this line should not be at the begining of Chalks.py ?
    
    # obtain the input operation
    if not isinstance(in_op, Operation):
        try:
            assert len(args) &gt;= 2
            t_op = Operation(in_op, args[0], args[1])
            for k in kw:
                t_op[k] = kw[k]
        except:
            raise "Error on receive_operation arguments (%s, %s, %s)"%(in_op, args, kw)
    else:
        t_op =	Operation(**in_op) # copy the operation 
        
    if dbg &gt;=1:
        print "Node applying op %s"%(t_op)
    
    # ---
    
    ConcurrentEditableNode.receive_operation(self, t_op) # apply localy
            
    return

remote_receive_op = remote_receive_operation # alias
    
</t>
</tnodes>
</leo_file>
